import {
  require_jsx_runtime
} from "/build/_shared/chunk-NMZL6IDN.js";
import {
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  useReactTable
} from "/build/_shared/chunk-C3GB7RDK.js";
import {
  __assign,
  __extends,
  __read,
  __rest,
  __spreadArray,
  __values,
  arrow,
  autoPlacement,
  autoUpdate,
  computePosition,
  detectOverflow,
  flip,
  floor,
  getComputedStyle as getComputedStyle2,
  getNodeName,
  getOverflowAncestors,
  getParentNode,
  getWindow,
  hide,
  init_floating_ui_react_dom,
  init_floating_ui_utils,
  init_floating_ui_utils_dom,
  inline,
  isElement,
  isHTMLElement,
  isLastTraversableNode,
  isShadowRoot,
  limitShift,
  offset,
  platform,
  shift,
  size,
  useFloating
} from "/build/_shared/chunk-AZ2ABKPG.js";
import {
  require_prop_types
} from "/build/_shared/chunk-HEETWZQQ.js";
import {
  _extends
} from "/build/_shared/chunk-ELWJTL4F.js";
import {
  require_react_dom
} from "/build/_shared/chunk-GIAAE3CH.js";
import {
  require_jsx_dev_runtime
} from "/build/_shared/chunk-XU7DNSPJ.js";
import {
  createHotContext
} from "/build/_shared/chunk-MEDZ44IS.js";
import "/build/_shared/chunk-UWV35TSL.js";
import {
  require_react
} from "/build/_shared/chunk-BOXFZXVX.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "/build/_shared/chunk-PNG5AS42.js";

// node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment10 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement6(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment10;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement6;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys2 = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys2.length; ++i) {
          var key = keys2[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics;
  }
});

// node_modules/lodash.mergewith/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.mergewith/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index3 = -1, result = Array(n);
      while (++index3 < n) {
        result[index3] = iteratee(index3);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject2(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index3 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length2) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index3 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length2) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index3 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index3, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      return index3 < 0 ? void 0 : data[index3][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index3][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index3 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length2) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size3 = data.size;
      data.set(key, value);
      this.size += data.size == size3 ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack2(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack2.prototype.clear = stackClear;
    Stack2.prototype["delete"] = stackDelete;
    Stack2.prototype.get = stackGet;
    Stack2.prototype.has = stackHas;
    Stack2.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length2 = array.length;
      while (length2--) {
        if (eq(array[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction5(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject2(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack2());
        if (isObject2(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject2(objValue) || isFunction5(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start2) {
      return setToString(overRest(func, start2, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index3 = -1, length2 = source.length;
      array || (array = Array(length2));
      while (++index3 < length2) {
        array[index3] = source[index3];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index3 = -1, length2 = props.length;
      while (++index3 < length2) {
        var key = props[index3];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index3 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard2 = length2 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
        if (guard2 && isIterateeCall(sources[0], sources[1], guard2)) {
          customizer = length2 < 3 ? void 0 : customizer;
          length2 = 1;
        }
        object = Object(object);
        while (++index3 < length2) {
          var source = sources[index3];
          if (source) {
            assigner(object, source, index3, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index3 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
        while (length2--) {
          var key = props[fromRight ? length2 : ++index3];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length2) {
      var type = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    function isIterateeCall(value, index3, object) {
      if (!isObject2(object)) {
        return false;
      }
      var type = typeof index3;
      if (type == "number" ? isArrayLike(object) && isIndex(index3, object.length) : type == "string" && index3 in object) {
        return eq(object[index3], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start2, transform2) {
      start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index3 = -1, length2 = nativeMax(args.length - start2, 0), array = Array(length2);
        while (++index3 < length2) {
          array[index3] = args[start2 + index3];
        }
        index3 = -1;
        var otherArgs = Array(start2 + 1);
        while (++index3 < start2) {
          otherArgs[index3] = args[index3];
        }
        otherArgs[start2] = transform2(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count2 = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count2 >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count2 = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction5(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction5(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var mergeWith6 = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = mergeWith6;
  }
});

// node_modules/react-fast-compare/index.js
var require_react_fast_compare = __commonJS({
  "node_modules/react-fast-compare/index.js"(exports, module) {
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a2, b2) {
      if (a2 === b2)
        return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor)
          return false;
        var length2, i, keys2;
        if (Array.isArray(a2)) {
          length2 = a2.length;
          if (length2 != b2.length)
            return false;
          for (i = length2; i-- !== 0; )
            if (!equal(a2[i], b2[i]))
              return false;
          return true;
        }
        var it;
        if (hasMap && a2 instanceof Map && b2 instanceof Map) {
          if (a2.size !== b2.size)
            return false;
          it = a2.entries();
          while (!(i = it.next()).done)
            if (!b2.has(i.value[0]))
              return false;
          it = a2.entries();
          while (!(i = it.next()).done)
            if (!equal(i.value[1], b2.get(i.value[0])))
              return false;
          return true;
        }
        if (hasSet && a2 instanceof Set && b2 instanceof Set) {
          if (a2.size !== b2.size)
            return false;
          it = a2.entries();
          while (!(i = it.next()).done)
            if (!b2.has(i.value[0]))
              return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
          length2 = a2.length;
          if (length2 != b2.length)
            return false;
          for (i = length2; i-- !== 0; )
            if (a2[i] !== b2[i])
              return false;
          return true;
        }
        if (a2.constructor === RegExp)
          return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b2.valueOf === "function")
          return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b2.toString === "function")
          return a2.toString() === b2.toString();
        keys2 = Object.keys(a2);
        length2 = keys2.length;
        if (length2 !== Object.keys(b2).length)
          return false;
        for (i = length2; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys2[i]))
            return false;
        if (hasElementType && a2 instanceof Element)
          return false;
        for (i = length2; i-- !== 0; ) {
          if ((keys2[i] === "_owner" || keys2[i] === "__v" || keys2[i] === "__o") && a2.$$typeof) {
            continue;
          }
          if (!equal(a2[keys2[i]], b2[keys2[i]]))
            return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    }
    module.exports = function isEqual2(a2, b2) {
      try {
        return equal(a2, b2);
      } catch (error2) {
        if ((error2.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error2;
      }
    };
  }
});

// node_modules/framer-motion/node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize4(fn2) {
  var cache = {};
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn2(arg);
    return cache[arg];
  };
}
var memoize_browser_esm_default;
var init_memoize_browser_esm = __esm({
  "node_modules/framer-motion/node_modules/@emotion/memoize/dist/memoize.browser.esm.js"() {
    memoize_browser_esm_default = memoize4;
  }
});

// node_modules/framer-motion/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js
var is_prop_valid_browser_esm_exports = {};
__export(is_prop_valid_browser_esm_exports, {
  default: () => is_prop_valid_browser_esm_default
});
var reactPropsRegex2, index, is_prop_valid_browser_esm_default;
var init_is_prop_valid_browser_esm = __esm({
  "node_modules/framer-motion/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js"() {
    init_memoize_browser_esm();
    reactPropsRegex2 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    index = memoize_browser_esm_default(
      function(prop) {
        return reactPropsRegex2.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
    is_prop_valid_browser_esm_default = index;
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// node_modules/date-fns/isDate.js
var require_isDate = __commonJS({
  "node_modules/date-fns/isDate.js"(exports) {
    "use strict";
    exports.isDate = isDate;
    function isDate(value) {
      return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
    }
  }
});

// node_modules/date-fns/toDate.js
var require_toDate = __commonJS({
  "node_modules/date-fns/toDate.js"(exports) {
    "use strict";
    exports.toDate = toDate;
    function toDate(argument) {
      const argStr = Object.prototype.toString.call(argument);
      if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
        return new argument.constructor(+argument);
      } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
        return new Date(argument);
      } else {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
  }
});

// node_modules/date-fns/isValid.js
var require_isValid = __commonJS({
  "node_modules/date-fns/isValid.js"(exports) {
    "use strict";
    exports.isValid = isValid;
    var _index = require_isDate();
    var _index2 = require_toDate();
    function isValid(date) {
      if (!(0, _index.isDate)(date) && typeof date !== "number") {
        return false;
      }
      const _date = (0, _index2.toDate)(date);
      return !isNaN(Number(_date));
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatDistance.js
var require_formatDistance = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatDistance.js"(exports) {
    "use strict";
    exports.formatDistance = void 0;
    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
      },
      xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
      },
      halfAMinute: "half a minute",
      lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
      },
      xHours: {
        one: "1 hour",
        other: "{{count}} hours"
      },
      xDays: {
        one: "1 day",
        other: "{{count}} days"
      },
      aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
      },
      xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
      },
      aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
      },
      xMonths: {
        one: "1 month",
        other: "{{count}} months"
      },
      aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
      },
      xYears: {
        one: "1 year",
        other: "{{count}} years"
      },
      overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
      },
      almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
      }
    };
    var formatDistance = (token2, count2, options) => {
      let result;
      const tokenValue = formatDistanceLocale[token2];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count2 === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count2.toString());
      }
      if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "in " + result;
        } else {
          return result + " ago";
        }
      }
      return result;
    };
    exports.formatDistance = formatDistance;
  }
});

// node_modules/date-fns/locale/_lib/buildFormatLongFn.js
var require_buildFormatLongFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildFormatLongFn.js"(exports) {
    "use strict";
    exports.buildFormatLongFn = buildFormatLongFn;
    function buildFormatLongFn(args) {
      return (options = {}) => {
        const width = options.width ? String(options.width) : args.defaultWidth;
        const format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
      };
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatLong.js
var require_formatLong = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatLong.js"(exports) {
    "use strict";
    exports.formatLong = void 0;
    var _index = require_buildFormatLongFn();
    var dateFormats = {
      full: "EEEE, MMMM do, y",
      long: "MMMM do, y",
      medium: "MMM d, y",
      short: "MM/dd/yyyy"
    };
    var timeFormats = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a"
    };
    var dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    var formatLong = exports.formatLong = {
      date: (0, _index.buildFormatLongFn)({
        formats: dateFormats,
        defaultWidth: "full"
      }),
      time: (0, _index.buildFormatLongFn)({
        formats: timeFormats,
        defaultWidth: "full"
      }),
      dateTime: (0, _index.buildFormatLongFn)({
        formats: dateTimeFormats,
        defaultWidth: "full"
      })
    };
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatRelative.js
var require_formatRelative = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatRelative.js"(exports) {
    "use strict";
    exports.formatRelative = void 0;
    var formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: "P"
    };
    var formatRelative = (token2, _date, _baseDate, _options) => formatRelativeLocale[token2];
    exports.formatRelative = formatRelative;
  }
});

// node_modules/date-fns/locale/_lib/buildLocalizeFn.js
var require_buildLocalizeFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildLocalizeFn.js"(exports) {
    "use strict";
    exports.buildLocalizeFn = buildLocalizeFn;
    function buildLocalizeFn(args) {
      return (value, options) => {
        const context = options?.context ? String(options.context) : "standalone";
        let valuesArray;
        if (context === "formatting" && args.formattingValues) {
          const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          const width = options?.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          const defaultWidth = args.defaultWidth;
          const width = options?.width ? String(options.width) : args.defaultWidth;
          valuesArray = args.values[width] || args.values[defaultWidth];
        }
        const index3 = args.argumentCallback ? args.argumentCallback(value) : value;
        return valuesArray[index3];
      };
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/localize.js
var require_localize = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/localize.js"(exports) {
    "use strict";
    exports.localize = void 0;
    var _index = require_buildLocalizeFn();
    var eraValues = {
      narrow: ["B", "A"],
      abbreviated: ["BC", "AD"],
      wide: ["Before Christ", "Anno Domini"]
    };
    var quarterValues = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    };
    var monthValues = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      wide: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    };
    var dayValues = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    };
    var dayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      }
    };
    var ordinalNumber = (dirtyNumber, _options) => {
      const number2 = Number(dirtyNumber);
      const rem100 = number2 % 100;
      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number2 + "st";
          case 2:
            return number2 + "nd";
          case 3:
            return number2 + "rd";
        }
      }
      return number2 + "th";
    };
    var localize = exports.localize = {
      ordinalNumber,
      era: (0, _index.buildLocalizeFn)({
        values: eraValues,
        defaultWidth: "wide"
      }),
      quarter: (0, _index.buildLocalizeFn)({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: (0, _index.buildLocalizeFn)({
        values: monthValues,
        defaultWidth: "wide"
      }),
      day: (0, _index.buildLocalizeFn)({
        values: dayValues,
        defaultWidth: "wide"
      }),
      dayPeriod: (0, _index.buildLocalizeFn)({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
      })
    };
  }
});

// node_modules/date-fns/locale/_lib/buildMatchFn.js
var require_buildMatchFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildMatchFn.js"(exports) {
    "use strict";
    exports.buildMatchFn = buildMatchFn;
    function buildMatchFn(args) {
      return (string, options = {}) => {
        const width = options.width;
        const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        const matchResult = string.match(matchPattern);
        if (!matchResult) {
          return null;
        }
        const matchedString = matchResult[0];
        const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
          findKey(parsePatterns, (pattern) => pattern.test(matchedString))
        );
        let value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
          options.valueCallback(value)
        ) : value;
        const rest = string.slice(matchedString.length);
        return { value, rest };
      };
    }
    function findKey(object, predicate) {
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
          return key;
        }
      }
      return void 0;
    }
    function findIndex(array, predicate) {
      for (let key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }
      return void 0;
    }
  }
});

// node_modules/date-fns/locale/_lib/buildMatchPatternFn.js
var require_buildMatchPatternFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildMatchPatternFn.js"(exports) {
    "use strict";
    exports.buildMatchPatternFn = buildMatchPatternFn;
    function buildMatchPatternFn(args) {
      return (string, options = {}) => {
        const matchResult = string.match(args.matchPattern);
        if (!matchResult)
          return null;
        const matchedString = matchResult[0];
        const parseResult = string.match(args.parsePattern);
        if (!parseResult)
          return null;
        let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        const rest = string.slice(matchedString.length);
        return { value, rest };
      };
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/match.js
var require_match = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/match.js"(exports) {
    "use strict";
    exports.match = void 0;
    var _index = require_buildMatchFn();
    var _index2 = require_buildMatchPatternFn();
    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns = {
      narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ],
      any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ]
    };
    var matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match2 = exports.match = {
      ordinalNumber: (0, _index2.buildMatchPatternFn)({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: (value) => parseInt(value, 10)
      }),
      era: (0, _index.buildMatchFn)({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
      }),
      quarter: (0, _index.buildMatchFn)({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: (index3) => index3 + 1
      }),
      month: (0, _index.buildMatchFn)({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
      }),
      day: (0, _index.buildMatchFn)({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
      }),
      dayPeriod: (0, _index.buildMatchFn)({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
      })
    };
  }
});

// node_modules/date-fns/locale/en-US.js
var require_en_US = __commonJS({
  "node_modules/date-fns/locale/en-US.js"(exports) {
    "use strict";
    exports.enUS = void 0;
    var _index = require_formatDistance();
    var _index2 = require_formatLong();
    var _index3 = require_formatRelative();
    var _index4 = require_localize();
    var _index5 = require_match();
    var enUS = exports.enUS = {
      code: "en-US",
      formatDistance: _index.formatDistance,
      formatLong: _index2.formatLong,
      formatRelative: _index3.formatRelative,
      localize: _index4.localize,
      match: _index5.match,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
  }
});

// node_modules/date-fns/_lib/defaultLocale.js
var require_defaultLocale = __commonJS({
  "node_modules/date-fns/_lib/defaultLocale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "defaultLocale", {
      enumerable: true,
      get: function() {
        return _index.enUS;
      }
    });
    var _index = require_en_US();
  }
});

// node_modules/date-fns/_lib/defaultOptions.js
var require_defaultOptions = __commonJS({
  "node_modules/date-fns/_lib/defaultOptions.js"(exports) {
    "use strict";
    exports.getDefaultOptions = getDefaultOptions;
    exports.setDefaultOptions = setDefaultOptions;
    var defaultOptions2 = {};
    function getDefaultOptions() {
      return defaultOptions2;
    }
    function setDefaultOptions(newOptions) {
      defaultOptions2 = newOptions;
    }
  }
});

// node_modules/date-fns/constants.js
var require_constants = __commonJS({
  "node_modules/date-fns/constants.js"(exports) {
    "use strict";
    exports.secondsInYear = exports.secondsInWeek = exports.secondsInQuarter = exports.secondsInMonth = exports.secondsInMinute = exports.secondsInHour = exports.secondsInDay = exports.quartersInYear = exports.monthsInYear = exports.monthsInQuarter = exports.minutesInYear = exports.minutesInMonth = exports.minutesInHour = exports.minutesInDay = exports.minTime = exports.millisecondsInWeek = exports.millisecondsInSecond = exports.millisecondsInMinute = exports.millisecondsInHour = exports.millisecondsInDay = exports.maxTime = exports.daysInYear = exports.daysInWeek = void 0;
    var daysInWeek = exports.daysInWeek = 7;
    var daysInYear = exports.daysInYear = 365.2425;
    var maxTime = exports.maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
    var minTime = exports.minTime = -maxTime;
    var millisecondsInWeek = exports.millisecondsInWeek = 6048e5;
    var millisecondsInDay = exports.millisecondsInDay = 864e5;
    var millisecondsInMinute = exports.millisecondsInMinute = 6e4;
    var millisecondsInHour = exports.millisecondsInHour = 36e5;
    var millisecondsInSecond = exports.millisecondsInSecond = 1e3;
    var minutesInYear = exports.minutesInYear = 525600;
    var minutesInMonth = exports.minutesInMonth = 43200;
    var minutesInDay = exports.minutesInDay = 1440;
    var minutesInHour = exports.minutesInHour = 60;
    var monthsInQuarter = exports.monthsInQuarter = 3;
    var monthsInYear = exports.monthsInYear = 12;
    var quartersInYear = exports.quartersInYear = 4;
    var secondsInHour = exports.secondsInHour = 3600;
    var secondsInMinute = exports.secondsInMinute = 60;
    var secondsInDay = exports.secondsInDay = secondsInHour * 24;
    var secondsInWeek = exports.secondsInWeek = secondsInDay * 7;
    var secondsInYear = exports.secondsInYear = secondsInDay * daysInYear;
    var secondsInMonth = exports.secondsInMonth = secondsInYear / 12;
    var secondsInQuarter = exports.secondsInQuarter = secondsInMonth * 3;
  }
});

// node_modules/date-fns/startOfDay.js
var require_startOfDay = __commonJS({
  "node_modules/date-fns/startOfDay.js"(exports) {
    "use strict";
    exports.startOfDay = startOfDay;
    var _index = require_toDate();
    function startOfDay(date) {
      const _date = (0, _index.toDate)(date);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
  }
});

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js
var require_getTimezoneOffsetInMilliseconds = __commonJS({
  "node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js"(exports) {
    "use strict";
    exports.getTimezoneOffsetInMilliseconds = getTimezoneOffsetInMilliseconds;
    var _index = require_toDate();
    function getTimezoneOffsetInMilliseconds(date) {
      const _date = (0, _index.toDate)(date);
      const utcDate = new Date(
        Date.UTC(
          _date.getFullYear(),
          _date.getMonth(),
          _date.getDate(),
          _date.getHours(),
          _date.getMinutes(),
          _date.getSeconds(),
          _date.getMilliseconds()
        )
      );
      utcDate.setUTCFullYear(_date.getFullYear());
      return +date - +utcDate;
    }
  }
});

// node_modules/date-fns/differenceInCalendarDays.js
var require_differenceInCalendarDays = __commonJS({
  "node_modules/date-fns/differenceInCalendarDays.js"(exports) {
    "use strict";
    exports.differenceInCalendarDays = differenceInCalendarDays;
    var _index = require_constants();
    var _index2 = require_startOfDay();
    var _index3 = require_getTimezoneOffsetInMilliseconds();
    function differenceInCalendarDays(dateLeft, dateRight) {
      const startOfDayLeft = (0, _index2.startOfDay)(dateLeft);
      const startOfDayRight = (0, _index2.startOfDay)(dateRight);
      const timestampLeft = +startOfDayLeft - (0, _index3.getTimezoneOffsetInMilliseconds)(startOfDayLeft);
      const timestampRight = +startOfDayRight - (0, _index3.getTimezoneOffsetInMilliseconds)(startOfDayRight);
      return Math.round(
        (timestampLeft - timestampRight) / _index.millisecondsInDay
      );
    }
  }
});

// node_modules/date-fns/constructFrom.js
var require_constructFrom = __commonJS({
  "node_modules/date-fns/constructFrom.js"(exports) {
    "use strict";
    exports.constructFrom = constructFrom;
    function constructFrom(date, value) {
      if (date instanceof Date) {
        return new date.constructor(value);
      } else {
        return new Date(value);
      }
    }
  }
});

// node_modules/date-fns/startOfYear.js
var require_startOfYear = __commonJS({
  "node_modules/date-fns/startOfYear.js"(exports) {
    "use strict";
    exports.startOfYear = startOfYear;
    var _index = require_toDate();
    var _index2 = require_constructFrom();
    function startOfYear(date) {
      const cleanDate = (0, _index.toDate)(date);
      const _date = (0, _index2.constructFrom)(date, 0);
      _date.setFullYear(cleanDate.getFullYear(), 0, 1);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
  }
});

// node_modules/date-fns/getDayOfYear.js
var require_getDayOfYear = __commonJS({
  "node_modules/date-fns/getDayOfYear.js"(exports) {
    "use strict";
    exports.getDayOfYear = getDayOfYear;
    var _index = require_differenceInCalendarDays();
    var _index2 = require_startOfYear();
    var _index3 = require_toDate();
    function getDayOfYear(date) {
      const _date = (0, _index3.toDate)(date);
      const diff = (0, _index.differenceInCalendarDays)(
        _date,
        (0, _index2.startOfYear)(_date)
      );
      const dayOfYear = diff + 1;
      return dayOfYear;
    }
  }
});

// node_modules/date-fns/startOfWeek.js
var require_startOfWeek = __commonJS({
  "node_modules/date-fns/startOfWeek.js"(exports) {
    "use strict";
    exports.startOfWeek = startOfWeek;
    var _index = require_toDate();
    var _index2 = require_defaultOptions();
    function startOfWeek(date, options) {
      const defaultOptions2 = (0, _index2.getDefaultOptions)();
      const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
      const _date = (0, _index.toDate)(date);
      const day = _date.getDay();
      const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      _date.setDate(_date.getDate() - diff);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
  }
});

// node_modules/date-fns/startOfISOWeek.js
var require_startOfISOWeek = __commonJS({
  "node_modules/date-fns/startOfISOWeek.js"(exports) {
    "use strict";
    exports.startOfISOWeek = startOfISOWeek;
    var _index = require_startOfWeek();
    function startOfISOWeek(date) {
      return (0, _index.startOfWeek)(date, { weekStartsOn: 1 });
    }
  }
});

// node_modules/date-fns/getISOWeekYear.js
var require_getISOWeekYear = __commonJS({
  "node_modules/date-fns/getISOWeekYear.js"(exports) {
    "use strict";
    exports.getISOWeekYear = getISOWeekYear;
    var _index = require_constructFrom();
    var _index2 = require_startOfISOWeek();
    var _index3 = require_toDate();
    function getISOWeekYear(date) {
      const _date = (0, _index3.toDate)(date);
      const year = _date.getFullYear();
      const fourthOfJanuaryOfNextYear = (0, _index.constructFrom)(date, 0);
      fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
      const startOfNextYear = (0, _index2.startOfISOWeek)(
        fourthOfJanuaryOfNextYear
      );
      const fourthOfJanuaryOfThisYear = (0, _index.constructFrom)(date, 0);
      fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
      const startOfThisYear = (0, _index2.startOfISOWeek)(
        fourthOfJanuaryOfThisYear
      );
      if (_date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (_date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
  }
});

// node_modules/date-fns/startOfISOWeekYear.js
var require_startOfISOWeekYear = __commonJS({
  "node_modules/date-fns/startOfISOWeekYear.js"(exports) {
    "use strict";
    exports.startOfISOWeekYear = startOfISOWeekYear;
    var _index = require_getISOWeekYear();
    var _index2 = require_startOfISOWeek();
    var _index3 = require_constructFrom();
    function startOfISOWeekYear(date) {
      const year = (0, _index.getISOWeekYear)(date);
      const fourthOfJanuary = (0, _index3.constructFrom)(date, 0);
      fourthOfJanuary.setFullYear(year, 0, 4);
      fourthOfJanuary.setHours(0, 0, 0, 0);
      return (0, _index2.startOfISOWeek)(fourthOfJanuary);
    }
  }
});

// node_modules/date-fns/getISOWeek.js
var require_getISOWeek = __commonJS({
  "node_modules/date-fns/getISOWeek.js"(exports) {
    "use strict";
    exports.getISOWeek = getISOWeek;
    var _index = require_constants();
    var _index2 = require_startOfISOWeek();
    var _index3 = require_startOfISOWeekYear();
    var _index4 = require_toDate();
    function getISOWeek(date) {
      const _date = (0, _index4.toDate)(date);
      const diff = +(0, _index2.startOfISOWeek)(_date) - +(0, _index3.startOfISOWeekYear)(_date);
      return Math.round(diff / _index.millisecondsInWeek) + 1;
    }
  }
});

// node_modules/date-fns/getWeekYear.js
var require_getWeekYear = __commonJS({
  "node_modules/date-fns/getWeekYear.js"(exports) {
    "use strict";
    exports.getWeekYear = getWeekYear;
    var _index = require_constructFrom();
    var _index2 = require_startOfWeek();
    var _index3 = require_toDate();
    var _index4 = require_defaultOptions();
    function getWeekYear(date, options) {
      const _date = (0, _index3.toDate)(date);
      const year = _date.getFullYear();
      const defaultOptions2 = (0, _index4.getDefaultOptions)();
      const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
      const firstWeekOfNextYear = (0, _index.constructFrom)(date, 0);
      firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setHours(0, 0, 0, 0);
      const startOfNextYear = (0, _index2.startOfWeek)(
        firstWeekOfNextYear,
        options
      );
      const firstWeekOfThisYear = (0, _index.constructFrom)(date, 0);
      firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setHours(0, 0, 0, 0);
      const startOfThisYear = (0, _index2.startOfWeek)(
        firstWeekOfThisYear,
        options
      );
      if (_date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (_date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
  }
});

// node_modules/date-fns/startOfWeekYear.js
var require_startOfWeekYear = __commonJS({
  "node_modules/date-fns/startOfWeekYear.js"(exports) {
    "use strict";
    exports.startOfWeekYear = startOfWeekYear;
    var _index = require_constructFrom();
    var _index2 = require_getWeekYear();
    var _index3 = require_startOfWeek();
    var _index4 = require_defaultOptions();
    function startOfWeekYear(date, options) {
      const defaultOptions2 = (0, _index4.getDefaultOptions)();
      const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
      const year = (0, _index2.getWeekYear)(date, options);
      const firstWeek = (0, _index.constructFrom)(date, 0);
      firstWeek.setFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setHours(0, 0, 0, 0);
      const _date = (0, _index3.startOfWeek)(firstWeek, options);
      return _date;
    }
  }
});

// node_modules/date-fns/getWeek.js
var require_getWeek = __commonJS({
  "node_modules/date-fns/getWeek.js"(exports) {
    "use strict";
    exports.getWeek = getWeek;
    var _index = require_constants();
    var _index2 = require_startOfWeek();
    var _index3 = require_startOfWeekYear();
    var _index4 = require_toDate();
    function getWeek(date, options) {
      const _date = (0, _index4.toDate)(date);
      const diff = +(0, _index2.startOfWeek)(_date, options) - +(0, _index3.startOfWeekYear)(_date, options);
      return Math.round(diff / _index.millisecondsInWeek) + 1;
    }
  }
});

// node_modules/date-fns/_lib/addLeadingZeros.js
var require_addLeadingZeros = __commonJS({
  "node_modules/date-fns/_lib/addLeadingZeros.js"(exports) {
    "use strict";
    exports.addLeadingZeros = addLeadingZeros;
    function addLeadingZeros(number2, targetLength) {
      const sign = number2 < 0 ? "-" : "";
      const output = Math.abs(number2).toString().padStart(targetLength, "0");
      return sign + output;
    }
  }
});

// node_modules/date-fns/_lib/format/lightFormatters.js
var require_lightFormatters = __commonJS({
  "node_modules/date-fns/_lib/format/lightFormatters.js"(exports) {
    "use strict";
    exports.lightFormatters = void 0;
    var _index = require_addLeadingZeros();
    var lightFormatters = exports.lightFormatters = {
      // Year
      y(date, token2) {
        const signedYear = date.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return (0, _index.addLeadingZeros)(
          token2 === "yy" ? year % 100 : year,
          token2.length
        );
      },
      // Month
      M(date, token2) {
        const month = date.getMonth();
        return token2 === "M" ? String(month + 1) : (0, _index.addLeadingZeros)(month + 1, 2);
      },
      // Day of the month
      d(date, token2) {
        return (0, _index.addLeadingZeros)(date.getDate(), token2.length);
      },
      // AM or PM
      a(date, token2) {
        const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
        switch (token2) {
          case "a":
          case "aa":
            return dayPeriodEnumValue.toUpperCase();
          case "aaa":
            return dayPeriodEnumValue;
          case "aaaaa":
            return dayPeriodEnumValue[0];
          case "aaaa":
          default:
            return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
      },
      // Hour [1-12]
      h(date, token2) {
        return (0, _index.addLeadingZeros)(
          date.getHours() % 12 || 12,
          token2.length
        );
      },
      // Hour [0-23]
      H(date, token2) {
        return (0, _index.addLeadingZeros)(date.getHours(), token2.length);
      },
      // Minute
      m(date, token2) {
        return (0, _index.addLeadingZeros)(date.getMinutes(), token2.length);
      },
      // Second
      s(date, token2) {
        return (0, _index.addLeadingZeros)(date.getSeconds(), token2.length);
      },
      // Fraction of second
      S(date, token2) {
        const numberOfDigits = token2.length;
        const milliseconds = date.getMilliseconds();
        const fractionalSeconds = Math.trunc(
          milliseconds * Math.pow(10, numberOfDigits - 3)
        );
        return (0, _index.addLeadingZeros)(fractionalSeconds, token2.length);
      }
    };
  }
});

// node_modules/date-fns/_lib/format/formatters.js
var require_formatters = __commonJS({
  "node_modules/date-fns/_lib/format/formatters.js"(exports) {
    "use strict";
    exports.formatters = void 0;
    var _index = require_getDayOfYear();
    var _index2 = require_getISOWeek();
    var _index3 = require_getISOWeekYear();
    var _index4 = require_getWeek();
    var _index5 = require_getWeekYear();
    var _index6 = require_addLeadingZeros();
    var _index7 = require_lightFormatters();
    var dayPeriodEnum = {
      am: "am",
      pm: "pm",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    };
    var formatters = exports.formatters = {
      // Era
      G: function(date, token2, localize) {
        const era = date.getFullYear() > 0 ? 1 : 0;
        switch (token2) {
          case "G":
          case "GG":
          case "GGG":
            return localize.era(era, { width: "abbreviated" });
          case "GGGGG":
            return localize.era(era, { width: "narrow" });
          case "GGGG":
          default:
            return localize.era(era, { width: "wide" });
        }
      },
      // Year
      y: function(date, token2, localize) {
        if (token2 === "yo") {
          const signedYear = date.getFullYear();
          const year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize.ordinalNumber(year, { unit: "year" });
        }
        return _index7.lightFormatters.y(date, token2);
      },
      // Local week-numbering year
      Y: function(date, token2, localize, options) {
        const signedWeekYear = (0, _index5.getWeekYear)(date, options);
        const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        if (token2 === "YY") {
          const twoDigitYear = weekYear % 100;
          return (0, _index6.addLeadingZeros)(twoDigitYear, 2);
        }
        if (token2 === "Yo") {
          return localize.ordinalNumber(weekYear, { unit: "year" });
        }
        return (0, _index6.addLeadingZeros)(weekYear, token2.length);
      },
      // ISO week-numbering year
      R: function(date, token2) {
        const isoWeekYear = (0, _index3.getISOWeekYear)(date);
        return (0, _index6.addLeadingZeros)(isoWeekYear, token2.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function(date, token2) {
        const year = date.getFullYear();
        return (0, _index6.addLeadingZeros)(year, token2.length);
      },
      // Quarter
      Q: function(date, token2, localize) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch (token2) {
          case "Q":
            return String(quarter);
          case "QQ":
            return (0, _index6.addLeadingZeros)(quarter, 2);
          case "Qo":
            return localize.ordinalNumber(quarter, { unit: "quarter" });
          case "QQQ":
            return localize.quarter(quarter, {
              width: "abbreviated",
              context: "formatting"
            });
          case "QQQQQ":
            return localize.quarter(quarter, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return localize.quarter(quarter, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone quarter
      q: function(date, token2, localize) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch (token2) {
          case "q":
            return String(quarter);
          case "qq":
            return (0, _index6.addLeadingZeros)(quarter, 2);
          case "qo":
            return localize.ordinalNumber(quarter, { unit: "quarter" });
          case "qqq":
            return localize.quarter(quarter, {
              width: "abbreviated",
              context: "standalone"
            });
          case "qqqqq":
            return localize.quarter(quarter, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return localize.quarter(quarter, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Month
      M: function(date, token2, localize) {
        const month = date.getMonth();
        switch (token2) {
          case "M":
          case "MM":
            return _index7.lightFormatters.M(date, token2);
          case "Mo":
            return localize.ordinalNumber(month + 1, { unit: "month" });
          case "MMM":
            return localize.month(month, {
              width: "abbreviated",
              context: "formatting"
            });
          case "MMMMM":
            return localize.month(month, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return localize.month(month, { width: "wide", context: "formatting" });
        }
      },
      // Stand-alone month
      L: function(date, token2, localize) {
        const month = date.getMonth();
        switch (token2) {
          case "L":
            return String(month + 1);
          case "LL":
            return (0, _index6.addLeadingZeros)(month + 1, 2);
          case "Lo":
            return localize.ordinalNumber(month + 1, { unit: "month" });
          case "LLL":
            return localize.month(month, {
              width: "abbreviated",
              context: "standalone"
            });
          case "LLLLL":
            return localize.month(month, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return localize.month(month, { width: "wide", context: "standalone" });
        }
      },
      // Local week of year
      w: function(date, token2, localize, options) {
        const week = (0, _index4.getWeek)(date, options);
        if (token2 === "wo") {
          return localize.ordinalNumber(week, { unit: "week" });
        }
        return (0, _index6.addLeadingZeros)(week, token2.length);
      },
      // ISO week of year
      I: function(date, token2, localize) {
        const isoWeek = (0, _index2.getISOWeek)(date);
        if (token2 === "Io") {
          return localize.ordinalNumber(isoWeek, { unit: "week" });
        }
        return (0, _index6.addLeadingZeros)(isoWeek, token2.length);
      },
      // Day of the month
      d: function(date, token2, localize) {
        if (token2 === "do") {
          return localize.ordinalNumber(date.getDate(), { unit: "date" });
        }
        return _index7.lightFormatters.d(date, token2);
      },
      // Day of year
      D: function(date, token2, localize) {
        const dayOfYear = (0, _index.getDayOfYear)(date);
        if (token2 === "Do") {
          return localize.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
        }
        return (0, _index6.addLeadingZeros)(dayOfYear, token2.length);
      },
      // Day of week
      E: function(date, token2, localize) {
        const dayOfWeek = date.getDay();
        switch (token2) {
          case "E":
          case "EE":
          case "EEE":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "EEEEE":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "EEEE":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Local day of week
      e: function(date, token2, localize, options) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token2) {
          case "e":
            return String(localDayOfWeek);
          case "ee":
            return (0, _index6.addLeadingZeros)(localDayOfWeek, 2);
          case "eo":
            return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
          case "eee":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "eeeee":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "eeee":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone local day of week
      c: function(date, token2, localize, options) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token2) {
          case "c":
            return String(localDayOfWeek);
          case "cc":
            return (0, _index6.addLeadingZeros)(localDayOfWeek, token2.length);
          case "co":
            return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
          case "ccc":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "standalone"
            });
          case "ccccc":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "standalone"
            });
          case "cccc":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // ISO day of week
      i: function(date, token2, localize) {
        const dayOfWeek = date.getDay();
        const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token2) {
          case "i":
            return String(isoDayOfWeek);
          case "ii":
            return (0, _index6.addLeadingZeros)(isoDayOfWeek, token2.length);
          case "io":
            return localize.ordinalNumber(isoDayOfWeek, { unit: "day" });
          case "iii":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "iiiii":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "iiiiii":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "iiii":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM or PM
      a: function(date, token2, localize) {
        const hours = date.getHours();
        const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch (token2) {
          case "a":
          case "aa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "aaa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "aaaaa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM, PM, midnight, noon
      b: function(date, token2, localize) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        }
        switch (token2) {
          case "b":
          case "bb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "bbb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "bbbbb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function(date, token2, localize) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token2) {
          case "B":
          case "BB":
          case "BBB":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "BBBBB":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Hour [1-12]
      h: function(date, token2, localize) {
        if (token2 === "ho") {
          let hours = date.getHours() % 12;
          if (hours === 0)
            hours = 12;
          return localize.ordinalNumber(hours, { unit: "hour" });
        }
        return _index7.lightFormatters.h(date, token2);
      },
      // Hour [0-23]
      H: function(date, token2, localize) {
        if (token2 === "Ho") {
          return localize.ordinalNumber(date.getHours(), { unit: "hour" });
        }
        return _index7.lightFormatters.H(date, token2);
      },
      // Hour [0-11]
      K: function(date, token2, localize) {
        const hours = date.getHours() % 12;
        if (token2 === "Ko") {
          return localize.ordinalNumber(hours, { unit: "hour" });
        }
        return (0, _index6.addLeadingZeros)(hours, token2.length);
      },
      // Hour [1-24]
      k: function(date, token2, localize) {
        let hours = date.getHours();
        if (hours === 0)
          hours = 24;
        if (token2 === "ko") {
          return localize.ordinalNumber(hours, { unit: "hour" });
        }
        return (0, _index6.addLeadingZeros)(hours, token2.length);
      },
      // Minute
      m: function(date, token2, localize) {
        if (token2 === "mo") {
          return localize.ordinalNumber(date.getMinutes(), { unit: "minute" });
        }
        return _index7.lightFormatters.m(date, token2);
      },
      // Second
      s: function(date, token2, localize) {
        if (token2 === "so") {
          return localize.ordinalNumber(date.getSeconds(), { unit: "second" });
        }
        return _index7.lightFormatters.s(date, token2);
      },
      // Fraction of second
      S: function(date, token2) {
        return _index7.lightFormatters.S(date, token2);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function(date, token2, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        if (timezoneOffset === 0) {
          return "Z";
        }
        switch (token2) {
          case "X":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "XXXX":
          case "XX":
            return formatTimezone(timezoneOffset);
          case "XXXXX":
          case "XXX":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function(date, token2, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token2) {
          case "x":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "xxxx":
          case "xx":
            return formatTimezone(timezoneOffset);
          case "xxxxx":
          case "xxx":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (GMT)
      O: function(date, token2, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token2) {
          case "O":
          case "OO":
          case "OOO":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "OOOO":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (specific non-location)
      z: function(date, token2, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token2) {
          case "z":
          case "zz":
          case "zzz":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "zzzz":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Seconds timestamp
      t: function(date, token2, _localize) {
        const timestamp = Math.trunc(date.getTime() / 1e3);
        return (0, _index6.addLeadingZeros)(timestamp, token2.length);
      },
      // Milliseconds timestamp
      T: function(date, token2, _localize) {
        const timestamp = date.getTime();
        return (0, _index6.addLeadingZeros)(timestamp, token2.length);
      }
    };
    function formatTimezoneShort(offset3, delimiter2 = "") {
      const sign = offset3 > 0 ? "-" : "+";
      const absOffset = Math.abs(offset3);
      const hours = Math.trunc(absOffset / 60);
      const minutes = absOffset % 60;
      if (minutes === 0) {
        return sign + String(hours);
      }
      return sign + String(hours) + delimiter2 + (0, _index6.addLeadingZeros)(minutes, 2);
    }
    function formatTimezoneWithOptionalMinutes(offset3, delimiter2) {
      if (offset3 % 60 === 0) {
        const sign = offset3 > 0 ? "-" : "+";
        return sign + (0, _index6.addLeadingZeros)(Math.abs(offset3) / 60, 2);
      }
      return formatTimezone(offset3, delimiter2);
    }
    function formatTimezone(offset3, delimiter2 = "") {
      const sign = offset3 > 0 ? "-" : "+";
      const absOffset = Math.abs(offset3);
      const hours = (0, _index6.addLeadingZeros)(Math.trunc(absOffset / 60), 2);
      const minutes = (0, _index6.addLeadingZeros)(absOffset % 60, 2);
      return sign + hours + delimiter2 + minutes;
    }
  }
});

// node_modules/date-fns/_lib/format/longFormatters.js
var require_longFormatters = __commonJS({
  "node_modules/date-fns/_lib/format/longFormatters.js"(exports) {
    "use strict";
    exports.longFormatters = void 0;
    var dateLongFormatter = (pattern, formatLong) => {
      switch (pattern) {
        case "P":
          return formatLong.date({ width: "short" });
        case "PP":
          return formatLong.date({ width: "medium" });
        case "PPP":
          return formatLong.date({ width: "long" });
        case "PPPP":
        default:
          return formatLong.date({ width: "full" });
      }
    };
    var timeLongFormatter = (pattern, formatLong) => {
      switch (pattern) {
        case "p":
          return formatLong.time({ width: "short" });
        case "pp":
          return formatLong.time({ width: "medium" });
        case "ppp":
          return formatLong.time({ width: "long" });
        case "pppp":
        default:
          return formatLong.time({ width: "full" });
      }
    };
    var dateTimeLongFormatter = (pattern, formatLong) => {
      const matchResult = pattern.match(/(P+)(p+)?/) || [];
      const datePattern = matchResult[1];
      const timePattern = matchResult[2];
      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong);
      }
      let dateTimeFormat;
      switch (datePattern) {
        case "P":
          dateTimeFormat = formatLong.dateTime({ width: "short" });
          break;
        case "PP":
          dateTimeFormat = formatLong.dateTime({ width: "medium" });
          break;
        case "PPP":
          dateTimeFormat = formatLong.dateTime({ width: "long" });
          break;
        case "PPPP":
        default:
          dateTimeFormat = formatLong.dateTime({ width: "full" });
          break;
      }
      return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
    };
    var longFormatters = exports.longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
  }
});

// node_modules/date-fns/_lib/protectedTokens.js
var require_protectedTokens = __commonJS({
  "node_modules/date-fns/_lib/protectedTokens.js"(exports) {
    "use strict";
    exports.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
    exports.isProtectedWeekYearToken = isProtectedWeekYearToken;
    exports.warnOrThrowProtectedError = warnOrThrowProtectedError;
    var dayOfYearTokenRE = /^D+$/;
    var weekYearTokenRE = /^Y+$/;
    var throwTokens = ["D", "DD", "YY", "YYYY"];
    function isProtectedDayOfYearToken(token2) {
      return dayOfYearTokenRE.test(token2);
    }
    function isProtectedWeekYearToken(token2) {
      return weekYearTokenRE.test(token2);
    }
    function warnOrThrowProtectedError(token2, format, input) {
      const _message = message(token2, format, input);
      console.warn(_message);
      if (throwTokens.includes(token2))
        throw new RangeError(_message);
    }
    function message(token2, format, input) {
      const subject = token2[0] === "Y" ? "years" : "days of the month";
      return `Use \`${token2.toLowerCase()}\` instead of \`${token2}\` (in \`${format}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
    }
  }
});

// node_modules/date-fns/format.js
var require_format = __commonJS({
  "node_modules/date-fns/format.js"(exports) {
    "use strict";
    exports.format = exports.formatDate = format;
    Object.defineProperty(exports, "formatters", {
      enumerable: true,
      get: function() {
        return _index3.formatters;
      }
    });
    Object.defineProperty(exports, "longFormatters", {
      enumerable: true,
      get: function() {
        return _index4.longFormatters;
      }
    });
    var _index = require_defaultLocale();
    var _index2 = require_defaultOptions();
    var _index3 = require_formatters();
    var _index4 = require_longFormatters();
    var _index5 = require_protectedTokens();
    var _index6 = require_isValid();
    var _index7 = require_toDate();
    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    function format(date, formatStr, options) {
      const defaultOptions2 = (0, _index2.getDefaultOptions)();
      const locale = options?.locale ?? defaultOptions2.locale ?? _index.defaultLocale;
      const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
      const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
      const originalDate = (0, _index7.toDate)(date);
      if (!(0, _index6.isValid)(originalDate)) {
        throw new RangeError("Invalid time value");
      }
      let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
        const firstCharacter = substring[0];
        if (firstCharacter === "p" || firstCharacter === "P") {
          const longFormatter = _index4.longFormatters[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }
        return substring;
      }).join("").match(formattingTokensRegExp).map((substring) => {
        if (substring === "''") {
          return { isToken: false, value: "'" };
        }
        const firstCharacter = substring[0];
        if (firstCharacter === "'") {
          return { isToken: false, value: cleanEscapedString(substring) };
        }
        if (_index3.formatters[firstCharacter]) {
          return { isToken: true, value: substring };
        }
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError(
            "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
          );
        }
        return { isToken: false, value: substring };
      });
      if (locale.localize.preprocessor) {
        parts = locale.localize.preprocessor(originalDate, parts);
      }
      const formatterOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale
      };
      return parts.map((part) => {
        if (!part.isToken)
          return part.value;
        const token2 = part.value;
        if (!options?.useAdditionalWeekYearTokens && (0, _index5.isProtectedWeekYearToken)(token2) || !options?.useAdditionalDayOfYearTokens && (0, _index5.isProtectedDayOfYearToken)(token2)) {
          (0, _index5.warnOrThrowProtectedError)(token2, formatStr, String(date));
        }
        const formatter = _index3.formatters[token2[0]];
        return formatter(originalDate, token2, locale.localize, formatterOptions);
      }).join("");
    }
    function cleanEscapedString(input) {
      const matched = input.match(escapedStringRegExp);
      if (!matched) {
        return input;
      }
      return matched[1].replace(doubleQuoteRegExp, "'");
    }
  }
});

// node_modules/date-fns/addMilliseconds.js
var require_addMilliseconds = __commonJS({
  "node_modules/date-fns/addMilliseconds.js"(exports) {
    "use strict";
    exports.addMilliseconds = addMilliseconds;
    var _index = require_toDate();
    var _index2 = require_constructFrom();
    function addMilliseconds(date, amount) {
      const timestamp = +(0, _index.toDate)(date);
      return (0, _index2.constructFrom)(date, timestamp + amount);
    }
  }
});

// node_modules/date-fns/addMinutes.js
var require_addMinutes = __commonJS({
  "node_modules/date-fns/addMinutes.js"(exports) {
    "use strict";
    exports.addMinutes = addMinutes;
    var _index = require_addMilliseconds();
    var _index2 = require_constants();
    function addMinutes(date, amount) {
      return (0, _index.addMilliseconds)(
        date,
        amount * _index2.millisecondsInMinute
      );
    }
  }
});

// node_modules/date-fns/addHours.js
var require_addHours = __commonJS({
  "node_modules/date-fns/addHours.js"(exports) {
    "use strict";
    exports.addHours = addHours;
    var _index = require_addMilliseconds();
    var _index2 = require_constants();
    function addHours(date, amount) {
      return (0, _index.addMilliseconds)(date, amount * _index2.millisecondsInHour);
    }
  }
});

// node_modules/date-fns/addDays.js
var require_addDays = __commonJS({
  "node_modules/date-fns/addDays.js"(exports) {
    "use strict";
    exports.addDays = addDays;
    var _index = require_toDate();
    var _index2 = require_constructFrom();
    function addDays(date, amount) {
      const _date = (0, _index.toDate)(date);
      if (isNaN(amount))
        return (0, _index2.constructFrom)(date, NaN);
      if (!amount) {
        return _date;
      }
      _date.setDate(_date.getDate() + amount);
      return _date;
    }
  }
});

// node_modules/date-fns/addWeeks.js
var require_addWeeks = __commonJS({
  "node_modules/date-fns/addWeeks.js"(exports) {
    "use strict";
    exports.addWeeks = addWeeks;
    var _index = require_addDays();
    function addWeeks(date, amount) {
      const days = amount * 7;
      return (0, _index.addDays)(date, days);
    }
  }
});

// node_modules/date-fns/addMonths.js
var require_addMonths = __commonJS({
  "node_modules/date-fns/addMonths.js"(exports) {
    "use strict";
    exports.addMonths = addMonths;
    var _index = require_toDate();
    var _index2 = require_constructFrom();
    function addMonths(date, amount) {
      const _date = (0, _index.toDate)(date);
      if (isNaN(amount))
        return (0, _index2.constructFrom)(date, NaN);
      if (!amount) {
        return _date;
      }
      const dayOfMonth = _date.getDate();
      const endOfDesiredMonth = (0, _index2.constructFrom)(date, _date.getTime());
      endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
      const daysInMonth = endOfDesiredMonth.getDate();
      if (dayOfMonth >= daysInMonth) {
        return endOfDesiredMonth;
      } else {
        _date.setFullYear(
          endOfDesiredMonth.getFullYear(),
          endOfDesiredMonth.getMonth(),
          dayOfMonth
        );
        return _date;
      }
    }
  }
});

// node_modules/date-fns/addQuarters.js
var require_addQuarters = __commonJS({
  "node_modules/date-fns/addQuarters.js"(exports) {
    "use strict";
    exports.addQuarters = addQuarters;
    var _index = require_addMonths();
    function addQuarters(date, amount) {
      const months = amount * 3;
      return (0, _index.addMonths)(date, months);
    }
  }
});

// node_modules/date-fns/addYears.js
var require_addYears = __commonJS({
  "node_modules/date-fns/addYears.js"(exports) {
    "use strict";
    exports.addYears = addYears;
    var _index = require_addMonths();
    function addYears(date, amount) {
      return (0, _index.addMonths)(date, amount * 12);
    }
  }
});

// node_modules/date-fns/subDays.js
var require_subDays = __commonJS({
  "node_modules/date-fns/subDays.js"(exports) {
    "use strict";
    exports.subDays = subDays;
    var _index = require_addDays();
    function subDays(date, amount) {
      return (0, _index.addDays)(date, -amount);
    }
  }
});

// node_modules/date-fns/subWeeks.js
var require_subWeeks = __commonJS({
  "node_modules/date-fns/subWeeks.js"(exports) {
    "use strict";
    exports.subWeeks = subWeeks;
    var _index = require_addWeeks();
    function subWeeks(date, amount) {
      return (0, _index.addWeeks)(date, -amount);
    }
  }
});

// node_modules/date-fns/subMonths.js
var require_subMonths = __commonJS({
  "node_modules/date-fns/subMonths.js"(exports) {
    "use strict";
    exports.subMonths = subMonths;
    var _index = require_addMonths();
    function subMonths(date, amount) {
      return (0, _index.addMonths)(date, -amount);
    }
  }
});

// node_modules/date-fns/subQuarters.js
var require_subQuarters = __commonJS({
  "node_modules/date-fns/subQuarters.js"(exports) {
    "use strict";
    exports.subQuarters = subQuarters;
    var _index = require_addQuarters();
    function subQuarters(date, amount) {
      return (0, _index.addQuarters)(date, -amount);
    }
  }
});

// node_modules/date-fns/subYears.js
var require_subYears = __commonJS({
  "node_modules/date-fns/subYears.js"(exports) {
    "use strict";
    exports.subYears = subYears;
    var _index = require_addYears();
    function subYears(date, amount) {
      return (0, _index.addYears)(date, -amount);
    }
  }
});

// node_modules/date-fns/getSeconds.js
var require_getSeconds = __commonJS({
  "node_modules/date-fns/getSeconds.js"(exports) {
    "use strict";
    exports.getSeconds = getSeconds;
    var _index = require_toDate();
    function getSeconds(date) {
      const _date = (0, _index.toDate)(date);
      const seconds = _date.getSeconds();
      return seconds;
    }
  }
});

// node_modules/date-fns/getMinutes.js
var require_getMinutes = __commonJS({
  "node_modules/date-fns/getMinutes.js"(exports) {
    "use strict";
    exports.getMinutes = getMinutes;
    var _index = require_toDate();
    function getMinutes(date) {
      const _date = (0, _index.toDate)(date);
      const minutes = _date.getMinutes();
      return minutes;
    }
  }
});

// node_modules/date-fns/getHours.js
var require_getHours = __commonJS({
  "node_modules/date-fns/getHours.js"(exports) {
    "use strict";
    exports.getHours = getHours;
    var _index = require_toDate();
    function getHours(date) {
      const _date = (0, _index.toDate)(date);
      const hours = _date.getHours();
      return hours;
    }
  }
});

// node_modules/date-fns/getDay.js
var require_getDay = __commonJS({
  "node_modules/date-fns/getDay.js"(exports) {
    "use strict";
    exports.getDay = getDay;
    var _index = require_toDate();
    function getDay(date) {
      const _date = (0, _index.toDate)(date);
      const day = _date.getDay();
      return day;
    }
  }
});

// node_modules/date-fns/getDate.js
var require_getDate = __commonJS({
  "node_modules/date-fns/getDate.js"(exports) {
    "use strict";
    exports.getDate = getDate;
    var _index = require_toDate();
    function getDate(date) {
      const _date = (0, _index.toDate)(date);
      const dayOfMonth = _date.getDate();
      return dayOfMonth;
    }
  }
});

// node_modules/date-fns/getMonth.js
var require_getMonth = __commonJS({
  "node_modules/date-fns/getMonth.js"(exports) {
    "use strict";
    exports.getMonth = getMonth;
    var _index = require_toDate();
    function getMonth(date) {
      const _date = (0, _index.toDate)(date);
      const month = _date.getMonth();
      return month;
    }
  }
});

// node_modules/date-fns/getQuarter.js
var require_getQuarter = __commonJS({
  "node_modules/date-fns/getQuarter.js"(exports) {
    "use strict";
    exports.getQuarter = getQuarter;
    var _index = require_toDate();
    function getQuarter(date) {
      const _date = (0, _index.toDate)(date);
      const quarter = Math.trunc(_date.getMonth() / 3) + 1;
      return quarter;
    }
  }
});

// node_modules/date-fns/getYear.js
var require_getYear = __commonJS({
  "node_modules/date-fns/getYear.js"(exports) {
    "use strict";
    exports.getYear = getYear;
    var _index = require_toDate();
    function getYear(date) {
      return (0, _index.toDate)(date).getFullYear();
    }
  }
});

// node_modules/date-fns/getTime.js
var require_getTime = __commonJS({
  "node_modules/date-fns/getTime.js"(exports) {
    "use strict";
    exports.getTime = getTime;
    var _index = require_toDate();
    function getTime(date) {
      const _date = (0, _index.toDate)(date);
      const timestamp = _date.getTime();
      return timestamp;
    }
  }
});

// node_modules/date-fns/setSeconds.js
var require_setSeconds = __commonJS({
  "node_modules/date-fns/setSeconds.js"(exports) {
    "use strict";
    exports.setSeconds = setSeconds;
    var _index = require_toDate();
    function setSeconds(date, seconds) {
      const _date = (0, _index.toDate)(date);
      _date.setSeconds(seconds);
      return _date;
    }
  }
});

// node_modules/date-fns/setMinutes.js
var require_setMinutes = __commonJS({
  "node_modules/date-fns/setMinutes.js"(exports) {
    "use strict";
    exports.setMinutes = setMinutes;
    var _index = require_toDate();
    function setMinutes(date, minutes) {
      const _date = (0, _index.toDate)(date);
      _date.setMinutes(minutes);
      return _date;
    }
  }
});

// node_modules/date-fns/setHours.js
var require_setHours = __commonJS({
  "node_modules/date-fns/setHours.js"(exports) {
    "use strict";
    exports.setHours = setHours;
    var _index = require_toDate();
    function setHours(date, hours) {
      const _date = (0, _index.toDate)(date);
      _date.setHours(hours);
      return _date;
    }
  }
});

// node_modules/date-fns/getDaysInMonth.js
var require_getDaysInMonth = __commonJS({
  "node_modules/date-fns/getDaysInMonth.js"(exports) {
    "use strict";
    exports.getDaysInMonth = getDaysInMonth;
    var _index = require_toDate();
    var _index2 = require_constructFrom();
    function getDaysInMonth(date) {
      const _date = (0, _index.toDate)(date);
      const year = _date.getFullYear();
      const monthIndex = _date.getMonth();
      const lastDayOfMonth = (0, _index2.constructFrom)(date, 0);
      lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
      lastDayOfMonth.setHours(0, 0, 0, 0);
      return lastDayOfMonth.getDate();
    }
  }
});

// node_modules/date-fns/setMonth.js
var require_setMonth = __commonJS({
  "node_modules/date-fns/setMonth.js"(exports) {
    "use strict";
    exports.setMonth = setMonth;
    var _index = require_constructFrom();
    var _index2 = require_getDaysInMonth();
    var _index3 = require_toDate();
    function setMonth(date, month) {
      const _date = (0, _index3.toDate)(date);
      const year = _date.getFullYear();
      const day = _date.getDate();
      const dateWithDesiredMonth = (0, _index.constructFrom)(date, 0);
      dateWithDesiredMonth.setFullYear(year, month, 15);
      dateWithDesiredMonth.setHours(0, 0, 0, 0);
      const daysInMonth = (0, _index2.getDaysInMonth)(dateWithDesiredMonth);
      _date.setMonth(month, Math.min(day, daysInMonth));
      return _date;
    }
  }
});

// node_modules/date-fns/setQuarter.js
var require_setQuarter = __commonJS({
  "node_modules/date-fns/setQuarter.js"(exports) {
    "use strict";
    exports.setQuarter = setQuarter;
    var _index = require_setMonth();
    var _index2 = require_toDate();
    function setQuarter(date, quarter) {
      const _date = (0, _index2.toDate)(date);
      const oldQuarter = Math.trunc(_date.getMonth() / 3) + 1;
      const diff = quarter - oldQuarter;
      return (0, _index.setMonth)(_date, _date.getMonth() + diff * 3);
    }
  }
});

// node_modules/date-fns/setYear.js
var require_setYear = __commonJS({
  "node_modules/date-fns/setYear.js"(exports) {
    "use strict";
    exports.setYear = setYear;
    var _index = require_constructFrom();
    var _index2 = require_toDate();
    function setYear(date, year) {
      const _date = (0, _index2.toDate)(date);
      if (isNaN(+_date)) {
        return (0, _index.constructFrom)(date, NaN);
      }
      _date.setFullYear(year);
      return _date;
    }
  }
});

// node_modules/date-fns/min.js
var require_min = __commonJS({
  "node_modules/date-fns/min.js"(exports) {
    "use strict";
    exports.min = min2;
    var _index = require_toDate();
    function min2(dates) {
      let result;
      dates.forEach((dirtyDate) => {
        const date = (0, _index.toDate)(dirtyDate);
        if (!result || result > date || isNaN(+date)) {
          result = date;
        }
      });
      return result || /* @__PURE__ */ new Date(NaN);
    }
  }
});

// node_modules/date-fns/max.js
var require_max = __commonJS({
  "node_modules/date-fns/max.js"(exports) {
    "use strict";
    exports.max = max2;
    var _index = require_toDate();
    function max2(dates) {
      let result;
      dates.forEach(function(dirtyDate) {
        const currentDate = (0, _index.toDate)(dirtyDate);
        if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
          result = currentDate;
        }
      });
      return result || /* @__PURE__ */ new Date(NaN);
    }
  }
});

// node_modules/date-fns/differenceInCalendarMonths.js
var require_differenceInCalendarMonths = __commonJS({
  "node_modules/date-fns/differenceInCalendarMonths.js"(exports) {
    "use strict";
    exports.differenceInCalendarMonths = differenceInCalendarMonths;
    var _index = require_toDate();
    function differenceInCalendarMonths(dateLeft, dateRight) {
      const _dateLeft = (0, _index.toDate)(dateLeft);
      const _dateRight = (0, _index.toDate)(dateRight);
      const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
      const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();
      return yearDiff * 12 + monthDiff;
    }
  }
});

// node_modules/date-fns/differenceInCalendarYears.js
var require_differenceInCalendarYears = __commonJS({
  "node_modules/date-fns/differenceInCalendarYears.js"(exports) {
    "use strict";
    exports.differenceInCalendarYears = differenceInCalendarYears;
    var _index = require_toDate();
    function differenceInCalendarYears(dateLeft, dateRight) {
      const _dateLeft = (0, _index.toDate)(dateLeft);
      const _dateRight = (0, _index.toDate)(dateRight);
      return _dateLeft.getFullYear() - _dateRight.getFullYear();
    }
  }
});

// node_modules/date-fns/startOfMonth.js
var require_startOfMonth = __commonJS({
  "node_modules/date-fns/startOfMonth.js"(exports) {
    "use strict";
    exports.startOfMonth = startOfMonth;
    var _index = require_toDate();
    function startOfMonth(date) {
      const _date = (0, _index.toDate)(date);
      _date.setDate(1);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
  }
});

// node_modules/date-fns/startOfQuarter.js
var require_startOfQuarter = __commonJS({
  "node_modules/date-fns/startOfQuarter.js"(exports) {
    "use strict";
    exports.startOfQuarter = startOfQuarter;
    var _index = require_toDate();
    function startOfQuarter(date) {
      const _date = (0, _index.toDate)(date);
      const currentMonth = _date.getMonth();
      const month = currentMonth - currentMonth % 3;
      _date.setMonth(month, 1);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
  }
});

// node_modules/date-fns/endOfDay.js
var require_endOfDay = __commonJS({
  "node_modules/date-fns/endOfDay.js"(exports) {
    "use strict";
    exports.endOfDay = endOfDay;
    var _index = require_toDate();
    function endOfDay(date) {
      const _date = (0, _index.toDate)(date);
      _date.setHours(23, 59, 59, 999);
      return _date;
    }
  }
});

// node_modules/date-fns/endOfWeek.js
var require_endOfWeek = __commonJS({
  "node_modules/date-fns/endOfWeek.js"(exports) {
    "use strict";
    exports.endOfWeek = endOfWeek;
    var _index = require_toDate();
    var _index2 = require_defaultOptions();
    function endOfWeek(date, options) {
      const defaultOptions2 = (0, _index2.getDefaultOptions)();
      const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
      const _date = (0, _index.toDate)(date);
      const day = _date.getDay();
      const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
      _date.setDate(_date.getDate() + diff);
      _date.setHours(23, 59, 59, 999);
      return _date;
    }
  }
});

// node_modules/date-fns/endOfMonth.js
var require_endOfMonth = __commonJS({
  "node_modules/date-fns/endOfMonth.js"(exports) {
    "use strict";
    exports.endOfMonth = endOfMonth;
    var _index = require_toDate();
    function endOfMonth(date) {
      const _date = (0, _index.toDate)(date);
      const month = _date.getMonth();
      _date.setFullYear(_date.getFullYear(), month + 1, 0);
      _date.setHours(23, 59, 59, 999);
      return _date;
    }
  }
});

// node_modules/date-fns/endOfYear.js
var require_endOfYear = __commonJS({
  "node_modules/date-fns/endOfYear.js"(exports) {
    "use strict";
    exports.endOfYear = endOfYear;
    var _index = require_toDate();
    function endOfYear(date) {
      const _date = (0, _index.toDate)(date);
      const year = _date.getFullYear();
      _date.setFullYear(year + 1, 0, 0);
      _date.setHours(23, 59, 59, 999);
      return _date;
    }
  }
});

// node_modules/date-fns/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/date-fns/isEqual.js"(exports) {
    "use strict";
    exports.isEqual = isEqual2;
    var _index = require_toDate();
    function isEqual2(leftDate, rightDate) {
      const _dateLeft = (0, _index.toDate)(leftDate);
      const _dateRight = (0, _index.toDate)(rightDate);
      return +_dateLeft === +_dateRight;
    }
  }
});

// node_modules/date-fns/isSameDay.js
var require_isSameDay = __commonJS({
  "node_modules/date-fns/isSameDay.js"(exports) {
    "use strict";
    exports.isSameDay = isSameDay;
    var _index = require_startOfDay();
    function isSameDay(dateLeft, dateRight) {
      const dateLeftStartOfDay = (0, _index.startOfDay)(dateLeft);
      const dateRightStartOfDay = (0, _index.startOfDay)(dateRight);
      return +dateLeftStartOfDay === +dateRightStartOfDay;
    }
  }
});

// node_modules/date-fns/isSameMonth.js
var require_isSameMonth = __commonJS({
  "node_modules/date-fns/isSameMonth.js"(exports) {
    "use strict";
    exports.isSameMonth = isSameMonth;
    var _index = require_toDate();
    function isSameMonth(dateLeft, dateRight) {
      const _dateLeft = (0, _index.toDate)(dateLeft);
      const _dateRight = (0, _index.toDate)(dateRight);
      return _dateLeft.getFullYear() === _dateRight.getFullYear() && _dateLeft.getMonth() === _dateRight.getMonth();
    }
  }
});

// node_modules/date-fns/isSameYear.js
var require_isSameYear = __commonJS({
  "node_modules/date-fns/isSameYear.js"(exports) {
    "use strict";
    exports.isSameYear = isSameYear;
    var _index = require_toDate();
    function isSameYear(dateLeft, dateRight) {
      const _dateLeft = (0, _index.toDate)(dateLeft);
      const _dateRight = (0, _index.toDate)(dateRight);
      return _dateLeft.getFullYear() === _dateRight.getFullYear();
    }
  }
});

// node_modules/date-fns/isSameQuarter.js
var require_isSameQuarter = __commonJS({
  "node_modules/date-fns/isSameQuarter.js"(exports) {
    "use strict";
    exports.isSameQuarter = isSameQuarter;
    var _index = require_startOfQuarter();
    function isSameQuarter(dateLeft, dateRight) {
      const dateLeftStartOfQuarter = (0, _index.startOfQuarter)(dateLeft);
      const dateRightStartOfQuarter = (0, _index.startOfQuarter)(dateRight);
      return +dateLeftStartOfQuarter === +dateRightStartOfQuarter;
    }
  }
});

// node_modules/date-fns/isAfter.js
var require_isAfter = __commonJS({
  "node_modules/date-fns/isAfter.js"(exports) {
    "use strict";
    exports.isAfter = isAfter;
    var _index = require_toDate();
    function isAfter(date, dateToCompare) {
      const _date = (0, _index.toDate)(date);
      const _dateToCompare = (0, _index.toDate)(dateToCompare);
      return _date.getTime() > _dateToCompare.getTime();
    }
  }
});

// node_modules/date-fns/isBefore.js
var require_isBefore = __commonJS({
  "node_modules/date-fns/isBefore.js"(exports) {
    "use strict";
    exports.isBefore = isBefore;
    var _index = require_toDate();
    function isBefore(date, dateToCompare) {
      const _date = (0, _index.toDate)(date);
      const _dateToCompare = (0, _index.toDate)(dateToCompare);
      return +_date < +_dateToCompare;
    }
  }
});

// node_modules/date-fns/isWithinInterval.js
var require_isWithinInterval = __commonJS({
  "node_modules/date-fns/isWithinInterval.js"(exports) {
    "use strict";
    exports.isWithinInterval = isWithinInterval;
    var _index = require_toDate();
    function isWithinInterval(date, interval) {
      const time = +(0, _index.toDate)(date);
      const [startTime, endTime] = [
        +(0, _index.toDate)(interval.start),
        +(0, _index.toDate)(interval.end)
      ].sort((a2, b2) => a2 - b2);
      return time >= startTime && time <= endTime;
    }
  }
});

// node_modules/date-fns/getDefaultOptions.js
var require_getDefaultOptions = __commonJS({
  "node_modules/date-fns/getDefaultOptions.js"(exports) {
    "use strict";
    exports.getDefaultOptions = getDefaultOptions;
    var _index = require_defaultOptions();
    function getDefaultOptions() {
      return Object.assign({}, (0, _index.getDefaultOptions)());
    }
  }
});

// node_modules/date-fns/transpose.js
var require_transpose = __commonJS({
  "node_modules/date-fns/transpose.js"(exports) {
    "use strict";
    exports.transpose = transpose;
    var _index = require_constructFrom();
    function transpose(fromDate, constructor) {
      const date = constructor instanceof Date ? (0, _index.constructFrom)(constructor, 0) : new constructor(0);
      date.setFullYear(
        fromDate.getFullYear(),
        fromDate.getMonth(),
        fromDate.getDate()
      );
      date.setHours(
        fromDate.getHours(),
        fromDate.getMinutes(),
        fromDate.getSeconds(),
        fromDate.getMilliseconds()
      );
      return date;
    }
  }
});

// node_modules/date-fns/parse/_lib/Setter.js
var require_Setter = __commonJS({
  "node_modules/date-fns/parse/_lib/Setter.js"(exports) {
    "use strict";
    exports.ValueSetter = exports.Setter = exports.DateToSystemTimezoneSetter = void 0;
    var _index = require_transpose();
    var _index2 = require_constructFrom();
    var TIMEZONE_UNIT_PRIORITY = 10;
    var Setter = class {
      subPriority = 0;
      validate(_utcDate, _options) {
        return true;
      }
    };
    exports.Setter = Setter;
    var ValueSetter = class extends Setter {
      constructor(value, validateValue, setValue, priority, subPriority) {
        super();
        this.value = value;
        this.validateValue = validateValue;
        this.setValue = setValue;
        this.priority = priority;
        if (subPriority) {
          this.subPriority = subPriority;
        }
      }
      validate(date, options) {
        return this.validateValue(date, this.value, options);
      }
      set(date, flags, options) {
        return this.setValue(date, flags, this.value, options);
      }
    };
    exports.ValueSetter = ValueSetter;
    var DateToSystemTimezoneSetter = class extends Setter {
      priority = TIMEZONE_UNIT_PRIORITY;
      subPriority = -1;
      set(date, flags) {
        if (flags.timestampIsSet)
          return date;
        return (0, _index2.constructFrom)(date, (0, _index.transpose)(date, Date));
      }
    };
    exports.DateToSystemTimezoneSetter = DateToSystemTimezoneSetter;
  }
});

// node_modules/date-fns/parse/_lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/date-fns/parse/_lib/Parser.js"(exports) {
    "use strict";
    exports.Parser = void 0;
    var _Setter = require_Setter();
    var Parser = class {
      run(dateString, token2, match2, options) {
        const result = this.parse(dateString, token2, match2, options);
        if (!result) {
          return null;
        }
        return {
          setter: new _Setter.ValueSetter(
            result.value,
            this.validate,
            this.set,
            this.priority,
            this.subPriority
          ),
          rest: result.rest
        };
      }
      validate(_utcDate, _value, _options) {
        return true;
      }
    };
    exports.Parser = Parser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/EraParser.js
var require_EraParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/EraParser.js"(exports) {
    "use strict";
    exports.EraParser = void 0;
    var _Parser = require_Parser();
    var EraParser = class extends _Parser.Parser {
      priority = 140;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "G":
          case "GG":
          case "GGG":
            return match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
          case "GGGGG":
            return match2.era(dateString, { width: "narrow" });
          case "GGGG":
          default:
            return match2.era(dateString, { width: "wide" }) || match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
        }
      }
      set(date, flags, value) {
        flags.era = value;
        date.setFullYear(value, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      incompatibleTokens = ["R", "u", "t", "T"];
    };
    exports.EraParser = EraParser;
  }
});

// node_modules/date-fns/parse/_lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/date-fns/parse/_lib/constants.js"(exports) {
    "use strict";
    exports.timezonePatterns = exports.numericPatterns = void 0;
    var numericPatterns = exports.numericPatterns = {
      month: /^(1[0-2]|0?\d)/,
      // 0 to 12
      date: /^(3[0-1]|[0-2]?\d)/,
      // 0 to 31
      dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
      // 0 to 366
      week: /^(5[0-3]|[0-4]?\d)/,
      // 0 to 53
      hour23h: /^(2[0-3]|[0-1]?\d)/,
      // 0 to 23
      hour24h: /^(2[0-4]|[0-1]?\d)/,
      // 0 to 24
      hour11h: /^(1[0-1]|0?\d)/,
      // 0 to 11
      hour12h: /^(1[0-2]|0?\d)/,
      // 0 to 12
      minute: /^[0-5]?\d/,
      // 0 to 59
      second: /^[0-5]?\d/,
      // 0 to 59
      singleDigit: /^\d/,
      // 0 to 9
      twoDigits: /^\d{1,2}/,
      // 0 to 99
      threeDigits: /^\d{1,3}/,
      // 0 to 999
      fourDigits: /^\d{1,4}/,
      // 0 to 9999
      anyDigitsSigned: /^-?\d+/,
      singleDigitSigned: /^-?\d/,
      // 0 to 9, -0 to -9
      twoDigitsSigned: /^-?\d{1,2}/,
      // 0 to 99, -0 to -99
      threeDigitsSigned: /^-?\d{1,3}/,
      // 0 to 999, -0 to -999
      fourDigitsSigned: /^-?\d{1,4}/
      // 0 to 9999, -0 to -9999
    };
    var timezonePatterns = exports.timezonePatterns = {
      basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
      basic: /^([+-])(\d{2})(\d{2})|Z/,
      basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
      extended: /^([+-])(\d{2}):(\d{2})|Z/,
      extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
    };
  }
});

// node_modules/date-fns/parse/_lib/utils.js
var require_utils = __commonJS({
  "node_modules/date-fns/parse/_lib/utils.js"(exports) {
    "use strict";
    exports.dayPeriodEnumToHours = dayPeriodEnumToHours;
    exports.isLeapYearIndex = isLeapYearIndex;
    exports.mapValue = mapValue;
    exports.normalizeTwoDigitYear = normalizeTwoDigitYear;
    exports.parseAnyDigitsSigned = parseAnyDigitsSigned;
    exports.parseNDigits = parseNDigits;
    exports.parseNDigitsSigned = parseNDigitsSigned;
    exports.parseNumericPattern = parseNumericPattern;
    exports.parseTimezonePattern = parseTimezonePattern;
    var _index = require_constants();
    var _constants = require_constants2();
    function mapValue(parseFnResult, mapFn) {
      if (!parseFnResult) {
        return parseFnResult;
      }
      return {
        value: mapFn(parseFnResult.value),
        rest: parseFnResult.rest
      };
    }
    function parseNumericPattern(pattern, dateString) {
      const matchResult = dateString.match(pattern);
      if (!matchResult) {
        return null;
      }
      return {
        value: parseInt(matchResult[0], 10),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseTimezonePattern(pattern, dateString) {
      const matchResult = dateString.match(pattern);
      if (!matchResult) {
        return null;
      }
      if (matchResult[0] === "Z") {
        return {
          value: 0,
          rest: dateString.slice(1)
        };
      }
      const sign = matchResult[1] === "+" ? 1 : -1;
      const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
      const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
      const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
      return {
        value: sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * _index.millisecondsInSecond),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseAnyDigitsSigned(dateString) {
      return parseNumericPattern(
        _constants.numericPatterns.anyDigitsSigned,
        dateString
      );
    }
    function parseNDigits(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(
            _constants.numericPatterns.singleDigit,
            dateString
          );
        case 2:
          return parseNumericPattern(
            _constants.numericPatterns.twoDigits,
            dateString
          );
        case 3:
          return parseNumericPattern(
            _constants.numericPatterns.threeDigits,
            dateString
          );
        case 4:
          return parseNumericPattern(
            _constants.numericPatterns.fourDigits,
            dateString
          );
        default:
          return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
      }
    }
    function parseNDigitsSigned(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(
            _constants.numericPatterns.singleDigitSigned,
            dateString
          );
        case 2:
          return parseNumericPattern(
            _constants.numericPatterns.twoDigitsSigned,
            dateString
          );
        case 3:
          return parseNumericPattern(
            _constants.numericPatterns.threeDigitsSigned,
            dateString
          );
        case 4:
          return parseNumericPattern(
            _constants.numericPatterns.fourDigitsSigned,
            dateString
          );
        default:
          return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
      }
    }
    function dayPeriodEnumToHours(dayPeriod) {
      switch (dayPeriod) {
        case "morning":
          return 4;
        case "evening":
          return 17;
        case "pm":
        case "noon":
        case "afternoon":
          return 12;
        case "am":
        case "midnight":
        case "night":
        default:
          return 0;
      }
    }
    function normalizeTwoDigitYear(twoDigitYear, currentYear) {
      const isCommonEra = currentYear > 0;
      const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
      let result;
      if (absCurrentYear <= 50) {
        result = twoDigitYear || 100;
      } else {
        const rangeEnd = absCurrentYear + 50;
        const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
        const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
        result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
      }
      return isCommonEra ? result : 1 - result;
    }
    function isLeapYearIndex(year) {
      return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
    }
  }
});

// node_modules/date-fns/parse/_lib/parsers/YearParser.js
var require_YearParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/YearParser.js"(exports) {
    "use strict";
    exports.YearParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var YearParser = class extends _Parser.Parser {
      priority = 130;
      incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];
      parse(dateString, token2, match2) {
        const valueCallback = (year) => ({
          year,
          isTwoDigitYear: token2 === "yy"
        });
        switch (token2) {
          case "y":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(4, dateString),
              valueCallback
            );
          case "yo":
            return (0, _utils.mapValue)(
              match2.ordinalNumber(dateString, {
                unit: "year"
              }),
              valueCallback
            );
          default:
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(token2.length, dateString),
              valueCallback
            );
        }
      }
      validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }
      set(date, flags, value) {
        const currentYear = date.getFullYear();
        if (value.isTwoDigitYear) {
          const normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(
            value.year,
            currentYear
          );
          date.setFullYear(normalizedTwoDigitYear, 0, 1);
          date.setHours(0, 0, 0, 0);
          return date;
        }
        const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setFullYear(year, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.YearParser = YearParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js
var require_LocalWeekYearParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js"(exports) {
    "use strict";
    exports.LocalWeekYearParser = void 0;
    var _index = require_getWeekYear();
    var _index2 = require_startOfWeek();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var LocalWeekYearParser = class extends _Parser.Parser {
      priority = 130;
      parse(dateString, token2, match2) {
        const valueCallback = (year) => ({
          year,
          isTwoDigitYear: token2 === "YY"
        });
        switch (token2) {
          case "Y":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(4, dateString),
              valueCallback
            );
          case "Yo":
            return (0, _utils.mapValue)(
              match2.ordinalNumber(dateString, {
                unit: "year"
              }),
              valueCallback
            );
          default:
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(token2.length, dateString),
              valueCallback
            );
        }
      }
      validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }
      set(date, flags, value, options) {
        const currentYear = (0, _index.getWeekYear)(date, options);
        if (value.isTwoDigitYear) {
          const normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(
            value.year,
            currentYear
          );
          date.setFullYear(
            normalizedTwoDigitYear,
            0,
            options.firstWeekContainsDate
          );
          date.setHours(0, 0, 0, 0);
          return (0, _index2.startOfWeek)(date, options);
        }
        const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setFullYear(year, 0, options.firstWeekContainsDate);
        date.setHours(0, 0, 0, 0);
        return (0, _index2.startOfWeek)(date, options);
      }
      incompatibleTokens = [
        "y",
        "R",
        "u",
        "Q",
        "q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "i",
        "t",
        "T"
      ];
    };
    exports.LocalWeekYearParser = LocalWeekYearParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js
var require_ISOWeekYearParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js"(exports) {
    "use strict";
    exports.ISOWeekYearParser = void 0;
    var _index = require_startOfISOWeek();
    var _index2 = require_constructFrom();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ISOWeekYearParser = class extends _Parser.Parser {
      priority = 130;
      parse(dateString, token2) {
        if (token2 === "R") {
          return (0, _utils.parseNDigitsSigned)(4, dateString);
        }
        return (0, _utils.parseNDigitsSigned)(token2.length, dateString);
      }
      set(date, _flags, value) {
        const firstWeekOfYear = (0, _index2.constructFrom)(date, 0);
        firstWeekOfYear.setFullYear(value, 0, 4);
        firstWeekOfYear.setHours(0, 0, 0, 0);
        return (0, _index.startOfISOWeek)(firstWeekOfYear);
      }
      incompatibleTokens = [
        "G",
        "y",
        "Y",
        "u",
        "Q",
        "q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "e",
        "c",
        "t",
        "T"
      ];
    };
    exports.ISOWeekYearParser = ISOWeekYearParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js
var require_ExtendedYearParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js"(exports) {
    "use strict";
    exports.ExtendedYearParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ExtendedYearParser = class extends _Parser.Parser {
      priority = 130;
      parse(dateString, token2) {
        if (token2 === "u") {
          return (0, _utils.parseNDigitsSigned)(4, dateString);
        }
        return (0, _utils.parseNDigitsSigned)(token2.length, dateString);
      }
      set(date, _flags, value) {
        date.setFullYear(value, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
    };
    exports.ExtendedYearParser = ExtendedYearParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/QuarterParser.js
var require_QuarterParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/QuarterParser.js"(exports) {
    "use strict";
    exports.QuarterParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var QuarterParser = class extends _Parser.Parser {
      priority = 120;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "Q":
          case "QQ":
            return (0, _utils.parseNDigits)(token2.length, dateString);
          case "Qo":
            return match2.ordinalNumber(dateString, { unit: "quarter" });
          case "QQQ":
            return match2.quarter(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQQ":
            return match2.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return match2.quarter(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.quarter(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 4;
      }
      set(date, _flags, value) {
        date.setMonth((value - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      incompatibleTokens = [
        "Y",
        "R",
        "q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ];
    };
    exports.QuarterParser = QuarterParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js
var require_StandAloneQuarterParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js"(exports) {
    "use strict";
    exports.StandAloneQuarterParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var StandAloneQuarterParser = class extends _Parser.Parser {
      priority = 120;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "q":
          case "qq":
            return (0, _utils.parseNDigits)(token2.length, dateString);
          case "qo":
            return match2.ordinalNumber(dateString, { unit: "quarter" });
          case "qqq":
            return match2.quarter(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqqq":
            return match2.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return match2.quarter(dateString, {
              width: "wide",
              context: "standalone"
            }) || match2.quarter(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 4;
      }
      set(date, _flags, value) {
        date.setMonth((value - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      incompatibleTokens = [
        "Y",
        "R",
        "Q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ];
    };
    exports.StandAloneQuarterParser = StandAloneQuarterParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/MonthParser.js
var require_MonthParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/MonthParser.js"(exports) {
    "use strict";
    exports.MonthParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var MonthParser = class extends _Parser.Parser {
      incompatibleTokens = [
        "Y",
        "R",
        "q",
        "Q",
        "L",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ];
      priority = 110;
      parse(dateString, token2, match2) {
        const valueCallback = (value) => value - 1;
        switch (token2) {
          case "M":
            return (0, _utils.mapValue)(
              (0, _utils.parseNumericPattern)(
                _constants.numericPatterns.month,
                dateString
              ),
              valueCallback
            );
          case "MM":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(2, dateString),
              valueCallback
            );
          case "Mo":
            return (0, _utils.mapValue)(
              match2.ordinalNumber(dateString, {
                unit: "month"
              }),
              valueCallback
            );
          case "MMM":
            return match2.month(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.month(dateString, { width: "narrow", context: "formatting" });
          case "MMMMM":
            return match2.month(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return match2.month(dateString, { width: "wide", context: "formatting" }) || match2.month(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.month(dateString, { width: "narrow", context: "formatting" });
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 11;
      }
      set(date, _flags, value) {
        date.setMonth(value, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.MonthParser = MonthParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js
var require_StandAloneMonthParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js"(exports) {
    "use strict";
    exports.StandAloneMonthParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var StandAloneMonthParser = class extends _Parser.Parser {
      priority = 110;
      parse(dateString, token2, match2) {
        const valueCallback = (value) => value - 1;
        switch (token2) {
          case "L":
            return (0, _utils.mapValue)(
              (0, _utils.parseNumericPattern)(
                _constants.numericPatterns.month,
                dateString
              ),
              valueCallback
            );
          case "LL":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(2, dateString),
              valueCallback
            );
          case "Lo":
            return (0, _utils.mapValue)(
              match2.ordinalNumber(dateString, {
                unit: "month"
              }),
              valueCallback
            );
          case "LLL":
            return match2.month(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.month(dateString, { width: "narrow", context: "standalone" });
          case "LLLLL":
            return match2.month(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return match2.month(dateString, { width: "wide", context: "standalone" }) || match2.month(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.month(dateString, { width: "narrow", context: "standalone" });
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 11;
      }
      set(date, _flags, value) {
        date.setMonth(value, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      incompatibleTokens = [
        "Y",
        "R",
        "q",
        "Q",
        "M",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ];
    };
    exports.StandAloneMonthParser = StandAloneMonthParser;
  }
});

// node_modules/date-fns/setWeek.js
var require_setWeek = __commonJS({
  "node_modules/date-fns/setWeek.js"(exports) {
    "use strict";
    exports.setWeek = setWeek;
    var _index = require_getWeek();
    var _index2 = require_toDate();
    function setWeek(date, week, options) {
      const _date = (0, _index2.toDate)(date);
      const diff = (0, _index.getWeek)(_date, options) - week;
      _date.setDate(_date.getDate() - diff * 7);
      return _date;
    }
  }
});

// node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js
var require_LocalWeekParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js"(exports) {
    "use strict";
    exports.LocalWeekParser = void 0;
    var _index = require_setWeek();
    var _index2 = require_startOfWeek();
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var LocalWeekParser = class extends _Parser.Parser {
      priority = 100;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "w":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.week,
              dateString
            );
          case "wo":
            return match2.ordinalNumber(dateString, { unit: "week" });
          default:
            return (0, _utils.parseNDigits)(token2.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 53;
      }
      set(date, _flags, value, options) {
        return (0, _index2.startOfWeek)(
          (0, _index.setWeek)(date, value, options),
          options
        );
      }
      incompatibleTokens = [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "i",
        "t",
        "T"
      ];
    };
    exports.LocalWeekParser = LocalWeekParser;
  }
});

// node_modules/date-fns/setISOWeek.js
var require_setISOWeek = __commonJS({
  "node_modules/date-fns/setISOWeek.js"(exports) {
    "use strict";
    exports.setISOWeek = setISOWeek;
    var _index = require_getISOWeek();
    var _index2 = require_toDate();
    function setISOWeek(date, week) {
      const _date = (0, _index2.toDate)(date);
      const diff = (0, _index.getISOWeek)(_date) - week;
      _date.setDate(_date.getDate() - diff * 7);
      return _date;
    }
  }
});

// node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js
var require_ISOWeekParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js"(exports) {
    "use strict";
    exports.ISOWeekParser = void 0;
    var _index = require_setISOWeek();
    var _index2 = require_startOfISOWeek();
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ISOWeekParser = class extends _Parser.Parser {
      priority = 100;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "I":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.week,
              dateString
            );
          case "Io":
            return match2.ordinalNumber(dateString, { unit: "week" });
          default:
            return (0, _utils.parseNDigits)(token2.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 53;
      }
      set(date, _flags, value) {
        return (0, _index2.startOfISOWeek)((0, _index.setISOWeek)(date, value));
      }
      incompatibleTokens = [
        "y",
        "Y",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "e",
        "c",
        "t",
        "T"
      ];
    };
    exports.ISOWeekParser = ISOWeekParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/DateParser.js
var require_DateParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/DateParser.js"(exports) {
    "use strict";
    exports.DateParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var DAYS_IN_MONTH_LEAP_YEAR = [
      31,
      29,
      31,
      30,
      31,
      30,
      31,
      31,
      30,
      31,
      30,
      31
    ];
    var DateParser = class extends _Parser.Parser {
      priority = 90;
      subPriority = 1;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "d":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.date,
              dateString
            );
          case "do":
            return match2.ordinalNumber(dateString, { unit: "date" });
          default:
            return (0, _utils.parseNDigits)(token2.length, dateString);
        }
      }
      validate(date, value) {
        const year = date.getFullYear();
        const isLeapYear = (0, _utils.isLeapYearIndex)(year);
        const month = date.getMonth();
        if (isLeapYear) {
          return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
        } else {
          return value >= 1 && value <= DAYS_IN_MONTH[month];
        }
      }
      set(date, _flags, value) {
        date.setDate(value);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      incompatibleTokens = [
        "Y",
        "R",
        "q",
        "Q",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ];
    };
    exports.DateParser = DateParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js
var require_DayOfYearParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js"(exports) {
    "use strict";
    exports.DayOfYearParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var DayOfYearParser = class extends _Parser.Parser {
      priority = 90;
      subpriority = 1;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "D":
          case "DD":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.dayOfYear,
              dateString
            );
          case "Do":
            return match2.ordinalNumber(dateString, { unit: "date" });
          default:
            return (0, _utils.parseNDigits)(token2.length, dateString);
        }
      }
      validate(date, value) {
        const year = date.getFullYear();
        const isLeapYear = (0, _utils.isLeapYearIndex)(year);
        if (isLeapYear) {
          return value >= 1 && value <= 366;
        } else {
          return value >= 1 && value <= 365;
        }
      }
      set(date, _flags, value) {
        date.setMonth(0, value);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      incompatibleTokens = [
        "Y",
        "R",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "E",
        "i",
        "e",
        "c",
        "t",
        "T"
      ];
    };
    exports.DayOfYearParser = DayOfYearParser;
  }
});

// node_modules/date-fns/setDay.js
var require_setDay = __commonJS({
  "node_modules/date-fns/setDay.js"(exports) {
    "use strict";
    exports.setDay = setDay;
    var _index = require_addDays();
    var _index2 = require_toDate();
    var _index3 = require_defaultOptions();
    function setDay(date, day, options) {
      const defaultOptions2 = (0, _index3.getDefaultOptions)();
      const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
      const _date = (0, _index2.toDate)(date);
      const currentDay = _date.getDay();
      const remainder = day % 7;
      const dayIndex = (remainder + 7) % 7;
      const delta = 7 - weekStartsOn;
      const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
      return (0, _index.addDays)(_date, diff);
    }
  }
});

// node_modules/date-fns/parse/_lib/parsers/DayParser.js
var require_DayParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/DayParser.js"(exports) {
    "use strict";
    exports.DayParser = void 0;
    var _index = require_setDay();
    var _Parser = require_Parser();
    var DayParser = class extends _Parser.Parser {
      priority = 90;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "E":
          case "EE":
          case "EEE":
            return match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
          case "EEEEE":
            return match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
          case "EEEE":
          default:
            return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 6;
      }
      set(date, _flags, value, options) {
        date = (0, _index.setDay)(date, value, options);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
    };
    exports.DayParser = DayParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js
var require_LocalDayParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js"(exports) {
    "use strict";
    exports.LocalDayParser = void 0;
    var _index = require_setDay();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var LocalDayParser = class extends _Parser.Parser {
      priority = 90;
      parse(dateString, token2, match2, options) {
        const valueCallback = (value) => {
          const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token2) {
          case "e":
          case "ee":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(token2.length, dateString),
              valueCallback
            );
          case "eo":
            return (0, _utils.mapValue)(
              match2.ordinalNumber(dateString, {
                unit: "day"
              }),
              valueCallback
            );
          case "eee":
            return match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
          case "eeeee":
            return match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
          case "eeee":
          default:
            return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 6;
      }
      set(date, _flags, value, options) {
        date = (0, _index.setDay)(date, value, options);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      incompatibleTokens = [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "E",
        "i",
        "c",
        "t",
        "T"
      ];
    };
    exports.LocalDayParser = LocalDayParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js
var require_StandAloneLocalDayParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js"(exports) {
    "use strict";
    exports.StandAloneLocalDayParser = void 0;
    var _index = require_setDay();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var StandAloneLocalDayParser = class extends _Parser.Parser {
      priority = 90;
      parse(dateString, token2, match2, options) {
        const valueCallback = (value) => {
          const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token2) {
          case "c":
          case "cc":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(token2.length, dateString),
              valueCallback
            );
          case "co":
            return (0, _utils.mapValue)(
              match2.ordinalNumber(dateString, {
                unit: "day"
              }),
              valueCallback
            );
          case "ccc":
            return match2.day(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
          case "ccccc":
            return match2.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
          case "cccc":
          default:
            return match2.day(dateString, { width: "wide", context: "standalone" }) || match2.day(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 6;
      }
      set(date, _flags, value, options) {
        date = (0, _index.setDay)(date, value, options);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      incompatibleTokens = [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "E",
        "i",
        "e",
        "t",
        "T"
      ];
    };
    exports.StandAloneLocalDayParser = StandAloneLocalDayParser;
  }
});

// node_modules/date-fns/getISODay.js
var require_getISODay = __commonJS({
  "node_modules/date-fns/getISODay.js"(exports) {
    "use strict";
    exports.getISODay = getISODay;
    var _index = require_toDate();
    function getISODay(date) {
      const _date = (0, _index.toDate)(date);
      let day = _date.getDay();
      if (day === 0) {
        day = 7;
      }
      return day;
    }
  }
});

// node_modules/date-fns/setISODay.js
var require_setISODay = __commonJS({
  "node_modules/date-fns/setISODay.js"(exports) {
    "use strict";
    exports.setISODay = setISODay;
    var _index = require_addDays();
    var _index2 = require_getISODay();
    var _index3 = require_toDate();
    function setISODay(date, day) {
      const _date = (0, _index3.toDate)(date);
      const currentDay = (0, _index2.getISODay)(_date);
      const diff = day - currentDay;
      return (0, _index.addDays)(_date, diff);
    }
  }
});

// node_modules/date-fns/parse/_lib/parsers/ISODayParser.js
var require_ISODayParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ISODayParser.js"(exports) {
    "use strict";
    exports.ISODayParser = void 0;
    var _index = require_setISODay();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ISODayParser = class extends _Parser.Parser {
      priority = 90;
      parse(dateString, token2, match2) {
        const valueCallback = (value) => {
          if (value === 0) {
            return 7;
          }
          return value;
        };
        switch (token2) {
          case "i":
          case "ii":
            return (0, _utils.parseNDigits)(token2.length, dateString);
          case "io":
            return match2.ordinalNumber(dateString, { unit: "day" });
          case "iii":
            return (0, _utils.mapValue)(
              match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }),
              valueCallback
            );
          case "iiiii":
            return (0, _utils.mapValue)(
              match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }),
              valueCallback
            );
          case "iiiiii":
            return (0, _utils.mapValue)(
              match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }),
              valueCallback
            );
          case "iiii":
          default:
            return (0, _utils.mapValue)(
              match2.day(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }),
              valueCallback
            );
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 7;
      }
      set(date, _flags, value) {
        date = (0, _index.setISODay)(date, value);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      incompatibleTokens = [
        "y",
        "Y",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "E",
        "e",
        "c",
        "t",
        "T"
      ];
    };
    exports.ISODayParser = ISODayParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/AMPMParser.js
var require_AMPMParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/AMPMParser.js"(exports) {
    "use strict";
    exports.AMPMParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var AMPMParser = class extends _Parser.Parser {
      priority = 80;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "a":
          case "aa":
          case "aaa":
            return match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaaa":
            return match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return match2.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
      set(date, _flags, value) {
        date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date;
      }
      incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
    };
    exports.AMPMParser = AMPMParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js
var require_AMPMMidnightParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js"(exports) {
    "use strict";
    exports.AMPMMidnightParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var AMPMMidnightParser = class extends _Parser.Parser {
      priority = 80;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "b":
          case "bb":
          case "bbb":
            return match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbbb":
            return match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return match2.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
      set(date, _flags, value) {
        date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date;
      }
      incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
    };
    exports.AMPMMidnightParser = AMPMMidnightParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js
var require_DayPeriodParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js"(exports) {
    "use strict";
    exports.DayPeriodParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var DayPeriodParser = class extends _Parser.Parser {
      priority = 80;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "B":
          case "BB":
          case "BBB":
            return match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBBB":
            return match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return match2.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
      set(date, _flags, value) {
        date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date;
      }
      incompatibleTokens = ["a", "b", "t", "T"];
    };
    exports.DayPeriodParser = DayPeriodParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js
var require_Hour1to12Parser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js"(exports) {
    "use strict";
    exports.Hour1to12Parser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var Hour1to12Parser = class extends _Parser.Parser {
      priority = 70;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "h":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.hour12h,
              dateString
            );
          case "ho":
            return match2.ordinalNumber(dateString, { unit: "hour" });
          default:
            return (0, _utils.parseNDigits)(token2.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 12;
      }
      set(date, _flags, value) {
        const isPM = date.getHours() >= 12;
        if (isPM && value < 12) {
          date.setHours(value + 12, 0, 0, 0);
        } else if (!isPM && value === 12) {
          date.setHours(0, 0, 0, 0);
        } else {
          date.setHours(value, 0, 0, 0);
        }
        return date;
      }
      incompatibleTokens = ["H", "K", "k", "t", "T"];
    };
    exports.Hour1to12Parser = Hour1to12Parser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js
var require_Hour0to23Parser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js"(exports) {
    "use strict";
    exports.Hour0to23Parser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var Hour0to23Parser = class extends _Parser.Parser {
      priority = 70;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "H":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.hour23h,
              dateString
            );
          case "Ho":
            return match2.ordinalNumber(dateString, { unit: "hour" });
          default:
            return (0, _utils.parseNDigits)(token2.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 23;
      }
      set(date, _flags, value) {
        date.setHours(value, 0, 0, 0);
        return date;
      }
      incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
    };
    exports.Hour0to23Parser = Hour0to23Parser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js
var require_Hour0To11Parser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js"(exports) {
    "use strict";
    exports.Hour0To11Parser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var Hour0To11Parser = class extends _Parser.Parser {
      priority = 70;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "K":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.hour11h,
              dateString
            );
          case "Ko":
            return match2.ordinalNumber(dateString, { unit: "hour" });
          default:
            return (0, _utils.parseNDigits)(token2.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 11;
      }
      set(date, _flags, value) {
        const isPM = date.getHours() >= 12;
        if (isPM && value < 12) {
          date.setHours(value + 12, 0, 0, 0);
        } else {
          date.setHours(value, 0, 0, 0);
        }
        return date;
      }
      incompatibleTokens = ["h", "H", "k", "t", "T"];
    };
    exports.Hour0To11Parser = Hour0To11Parser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js
var require_Hour1To24Parser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js"(exports) {
    "use strict";
    exports.Hour1To24Parser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var Hour1To24Parser = class extends _Parser.Parser {
      priority = 70;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "k":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.hour24h,
              dateString
            );
          case "ko":
            return match2.ordinalNumber(dateString, { unit: "hour" });
          default:
            return (0, _utils.parseNDigits)(token2.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 24;
      }
      set(date, _flags, value) {
        const hours = value <= 24 ? value % 24 : value;
        date.setHours(hours, 0, 0, 0);
        return date;
      }
      incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
    };
    exports.Hour1To24Parser = Hour1To24Parser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/MinuteParser.js
var require_MinuteParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/MinuteParser.js"(exports) {
    "use strict";
    exports.MinuteParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var MinuteParser = class extends _Parser.Parser {
      priority = 60;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "m":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.minute,
              dateString
            );
          case "mo":
            return match2.ordinalNumber(dateString, { unit: "minute" });
          default:
            return (0, _utils.parseNDigits)(token2.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 59;
      }
      set(date, _flags, value) {
        date.setMinutes(value, 0, 0);
        return date;
      }
      incompatibleTokens = ["t", "T"];
    };
    exports.MinuteParser = MinuteParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/SecondParser.js
var require_SecondParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/SecondParser.js"(exports) {
    "use strict";
    exports.SecondParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var SecondParser = class extends _Parser.Parser {
      priority = 50;
      parse(dateString, token2, match2) {
        switch (token2) {
          case "s":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.second,
              dateString
            );
          case "so":
            return match2.ordinalNumber(dateString, { unit: "second" });
          default:
            return (0, _utils.parseNDigits)(token2.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 59;
      }
      set(date, _flags, value) {
        date.setSeconds(value, 0);
        return date;
      }
      incompatibleTokens = ["t", "T"];
    };
    exports.SecondParser = SecondParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js
var require_FractionOfSecondParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js"(exports) {
    "use strict";
    exports.FractionOfSecondParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var FractionOfSecondParser = class extends _Parser.Parser {
      priority = 30;
      parse(dateString, token2) {
        const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token2.length + 3));
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(token2.length, dateString),
          valueCallback
        );
      }
      set(date, _flags, value) {
        date.setMilliseconds(value);
        return date;
      }
      incompatibleTokens = ["t", "T"];
    };
    exports.FractionOfSecondParser = FractionOfSecondParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js
var require_ISOTimezoneWithZParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js"(exports) {
    "use strict";
    exports.ISOTimezoneWithZParser = void 0;
    var _index = require_constructFrom();
    var _index2 = require_getTimezoneOffsetInMilliseconds();
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ISOTimezoneWithZParser = class extends _Parser.Parser {
      priority = 10;
      parse(dateString, token2) {
        switch (token2) {
          case "X":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basicOptionalMinutes,
              dateString
            );
          case "XX":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basic,
              dateString
            );
          case "XXXX":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basicOptionalSeconds,
              dateString
            );
          case "XXXXX":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.extendedOptionalSeconds,
              dateString
            );
          case "XXX":
          default:
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.extended,
              dateString
            );
        }
      }
      set(date, flags, value) {
        if (flags.timestampIsSet)
          return date;
        return (0, _index.constructFrom)(
          date,
          date.getTime() - (0, _index2.getTimezoneOffsetInMilliseconds)(date) - value
        );
      }
      incompatibleTokens = ["t", "T", "x"];
    };
    exports.ISOTimezoneWithZParser = ISOTimezoneWithZParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js
var require_ISOTimezoneParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js"(exports) {
    "use strict";
    exports.ISOTimezoneParser = void 0;
    var _index = require_constructFrom();
    var _index2 = require_getTimezoneOffsetInMilliseconds();
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ISOTimezoneParser = class extends _Parser.Parser {
      priority = 10;
      parse(dateString, token2) {
        switch (token2) {
          case "x":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basicOptionalMinutes,
              dateString
            );
          case "xx":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basic,
              dateString
            );
          case "xxxx":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basicOptionalSeconds,
              dateString
            );
          case "xxxxx":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.extendedOptionalSeconds,
              dateString
            );
          case "xxx":
          default:
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.extended,
              dateString
            );
        }
      }
      set(date, flags, value) {
        if (flags.timestampIsSet)
          return date;
        return (0, _index.constructFrom)(
          date,
          date.getTime() - (0, _index2.getTimezoneOffsetInMilliseconds)(date) - value
        );
      }
      incompatibleTokens = ["t", "T", "X"];
    };
    exports.ISOTimezoneParser = ISOTimezoneParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js
var require_TimestampSecondsParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js"(exports) {
    "use strict";
    exports.TimestampSecondsParser = void 0;
    var _index = require_constructFrom();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var TimestampSecondsParser = class extends _Parser.Parser {
      priority = 40;
      parse(dateString) {
        return (0, _utils.parseAnyDigitsSigned)(dateString);
      }
      set(date, _flags, value) {
        return [
          (0, _index.constructFrom)(date, value * 1e3),
          { timestampIsSet: true }
        ];
      }
      incompatibleTokens = "*";
    };
    exports.TimestampSecondsParser = TimestampSecondsParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js
var require_TimestampMillisecondsParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js"(exports) {
    "use strict";
    exports.TimestampMillisecondsParser = void 0;
    var _index = require_constructFrom();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var TimestampMillisecondsParser = class extends _Parser.Parser {
      priority = 20;
      parse(dateString) {
        return (0, _utils.parseAnyDigitsSigned)(dateString);
      }
      set(date, _flags, value) {
        return [(0, _index.constructFrom)(date, value), { timestampIsSet: true }];
      }
      incompatibleTokens = "*";
    };
    exports.TimestampMillisecondsParser = TimestampMillisecondsParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers.js
var require_parsers = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers.js"(exports) {
    "use strict";
    exports.parsers = void 0;
    var _EraParser = require_EraParser();
    var _YearParser = require_YearParser();
    var _LocalWeekYearParser = require_LocalWeekYearParser();
    var _ISOWeekYearParser = require_ISOWeekYearParser();
    var _ExtendedYearParser = require_ExtendedYearParser();
    var _QuarterParser = require_QuarterParser();
    var _StandAloneQuarterParser = require_StandAloneQuarterParser();
    var _MonthParser = require_MonthParser();
    var _StandAloneMonthParser = require_StandAloneMonthParser();
    var _LocalWeekParser = require_LocalWeekParser();
    var _ISOWeekParser = require_ISOWeekParser();
    var _DateParser = require_DateParser();
    var _DayOfYearParser = require_DayOfYearParser();
    var _DayParser = require_DayParser();
    var _LocalDayParser = require_LocalDayParser();
    var _StandAloneLocalDayParser = require_StandAloneLocalDayParser();
    var _ISODayParser = require_ISODayParser();
    var _AMPMParser = require_AMPMParser();
    var _AMPMMidnightParser = require_AMPMMidnightParser();
    var _DayPeriodParser = require_DayPeriodParser();
    var _Hour1to12Parser = require_Hour1to12Parser();
    var _Hour0to23Parser = require_Hour0to23Parser();
    var _Hour0To11Parser = require_Hour0To11Parser();
    var _Hour1To24Parser = require_Hour1To24Parser();
    var _MinuteParser = require_MinuteParser();
    var _SecondParser = require_SecondParser();
    var _FractionOfSecondParser = require_FractionOfSecondParser();
    var _ISOTimezoneWithZParser = require_ISOTimezoneWithZParser();
    var _ISOTimezoneParser = require_ISOTimezoneParser();
    var _TimestampSecondsParser = require_TimestampSecondsParser();
    var _TimestampMillisecondsParser = require_TimestampMillisecondsParser();
    var parsers = exports.parsers = {
      G: new _EraParser.EraParser(),
      y: new _YearParser.YearParser(),
      Y: new _LocalWeekYearParser.LocalWeekYearParser(),
      R: new _ISOWeekYearParser.ISOWeekYearParser(),
      u: new _ExtendedYearParser.ExtendedYearParser(),
      Q: new _QuarterParser.QuarterParser(),
      q: new _StandAloneQuarterParser.StandAloneQuarterParser(),
      M: new _MonthParser.MonthParser(),
      L: new _StandAloneMonthParser.StandAloneMonthParser(),
      w: new _LocalWeekParser.LocalWeekParser(),
      I: new _ISOWeekParser.ISOWeekParser(),
      d: new _DateParser.DateParser(),
      D: new _DayOfYearParser.DayOfYearParser(),
      E: new _DayParser.DayParser(),
      e: new _LocalDayParser.LocalDayParser(),
      c: new _StandAloneLocalDayParser.StandAloneLocalDayParser(),
      i: new _ISODayParser.ISODayParser(),
      a: new _AMPMParser.AMPMParser(),
      b: new _AMPMMidnightParser.AMPMMidnightParser(),
      B: new _DayPeriodParser.DayPeriodParser(),
      h: new _Hour1to12Parser.Hour1to12Parser(),
      H: new _Hour0to23Parser.Hour0to23Parser(),
      K: new _Hour0To11Parser.Hour0To11Parser(),
      k: new _Hour1To24Parser.Hour1To24Parser(),
      m: new _MinuteParser.MinuteParser(),
      s: new _SecondParser.SecondParser(),
      S: new _FractionOfSecondParser.FractionOfSecondParser(),
      X: new _ISOTimezoneWithZParser.ISOTimezoneWithZParser(),
      x: new _ISOTimezoneParser.ISOTimezoneParser(),
      t: new _TimestampSecondsParser.TimestampSecondsParser(),
      T: new _TimestampMillisecondsParser.TimestampMillisecondsParser()
    };
  }
});

// node_modules/date-fns/parse.js
var require_parse = __commonJS({
  "node_modules/date-fns/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "longFormatters", {
      enumerable: true,
      get: function() {
        return _index5.longFormatters;
      }
    });
    exports.parse = parse3;
    Object.defineProperty(exports, "parsers", {
      enumerable: true,
      get: function() {
        return _index7.parsers;
      }
    });
    var _index = require_constructFrom();
    var _index2 = require_getDefaultOptions();
    var _index3 = require_en_US();
    var _index4 = require_toDate();
    var _index5 = require_longFormatters();
    var _index6 = require_protectedTokens();
    var _index7 = require_parsers();
    var _Setter = require_Setter();
    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var notWhitespaceRegExp = /\S/;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    function parse3(dateStr, formatStr, referenceDate, options) {
      const defaultOptions2 = (0, _index2.getDefaultOptions)();
      const locale = options?.locale ?? defaultOptions2.locale ?? _index3.enUS;
      const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
      const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
      if (formatStr === "") {
        if (dateStr === "") {
          return (0, _index4.toDate)(referenceDate);
        } else {
          return (0, _index.constructFrom)(referenceDate, NaN);
        }
      }
      const subFnOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale
      };
      const setters = [new _Setter.DateToSystemTimezoneSetter()];
      const tokens2 = formatStr.match(longFormattingTokensRegExp).map((substring) => {
        const firstCharacter = substring[0];
        if (firstCharacter in _index5.longFormatters) {
          const longFormatter = _index5.longFormatters[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }
        return substring;
      }).join("").match(formattingTokensRegExp);
      const usedTokens = [];
      for (let token2 of tokens2) {
        if (!options?.useAdditionalWeekYearTokens && (0, _index6.isProtectedWeekYearToken)(token2)) {
          (0, _index6.warnOrThrowProtectedError)(token2, formatStr, dateStr);
        }
        if (!options?.useAdditionalDayOfYearTokens && (0, _index6.isProtectedDayOfYearToken)(token2)) {
          (0, _index6.warnOrThrowProtectedError)(token2, formatStr, dateStr);
        }
        const firstCharacter = token2[0];
        const parser = _index7.parsers[firstCharacter];
        if (parser) {
          const { incompatibleTokens } = parser;
          if (Array.isArray(incompatibleTokens)) {
            const incompatibleToken = usedTokens.find(
              (usedToken) => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter
            );
            if (incompatibleToken) {
              throw new RangeError(
                `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token2}\` at the same time`
              );
            }
          } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
            throw new RangeError(
              `The format string mustn't contain \`${token2}\` and any other token at the same time`
            );
          }
          usedTokens.push({ token: firstCharacter, fullToken: token2 });
          const parseResult = parser.run(
            dateStr,
            token2,
            locale.match,
            subFnOptions
          );
          if (!parseResult) {
            return (0, _index.constructFrom)(referenceDate, NaN);
          }
          setters.push(parseResult.setter);
          dateStr = parseResult.rest;
        } else {
          if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
            throw new RangeError(
              "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
            );
          }
          if (token2 === "''") {
            token2 = "'";
          } else if (firstCharacter === "'") {
            token2 = cleanEscapedString(token2);
          }
          if (dateStr.indexOf(token2) === 0) {
            dateStr = dateStr.slice(token2.length);
          } else {
            return (0, _index.constructFrom)(referenceDate, NaN);
          }
        }
      }
      if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
        return (0, _index.constructFrom)(referenceDate, NaN);
      }
      const uniquePrioritySetters = setters.map((setter) => setter.priority).sort((a2, b2) => b2 - a2).filter((priority, index3, array) => array.indexOf(priority) === index3).map(
        (priority) => setters.filter((setter) => setter.priority === priority).sort((a2, b2) => b2.subPriority - a2.subPriority)
      ).map((setterArray) => setterArray[0]);
      let date = (0, _index4.toDate)(referenceDate);
      if (isNaN(date.getTime())) {
        return (0, _index.constructFrom)(referenceDate, NaN);
      }
      const flags = {};
      for (const setter of uniquePrioritySetters) {
        if (!setter.validate(date, subFnOptions)) {
          return (0, _index.constructFrom)(referenceDate, NaN);
        }
        const result = setter.set(date, flags, subFnOptions);
        if (Array.isArray(result)) {
          date = result[0];
          Object.assign(flags, result[1]);
        } else {
          date = result;
        }
      }
      return (0, _index.constructFrom)(referenceDate, date);
    }
    function cleanEscapedString(input) {
      return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
    }
  }
});

// node_modules/date-fns/parseISO.js
var require_parseISO = __commonJS({
  "node_modules/date-fns/parseISO.js"(exports) {
    "use strict";
    exports.parseISO = parseISO;
    var _index = require_constants();
    function parseISO(argument, options) {
      const additionalDigits = options?.additionalDigits ?? 2;
      const dateStrings = splitDateString(argument);
      let date;
      if (dateStrings.date) {
        const parseYearResult = parseYear(dateStrings.date, additionalDigits);
        date = parseDate(parseYearResult.restDateString, parseYearResult.year);
      }
      if (!date || isNaN(date.getTime())) {
        return /* @__PURE__ */ new Date(NaN);
      }
      const timestamp = date.getTime();
      let time = 0;
      let offset3;
      if (dateStrings.time) {
        time = parseTime(dateStrings.time);
        if (isNaN(time)) {
          return /* @__PURE__ */ new Date(NaN);
        }
      }
      if (dateStrings.timezone) {
        offset3 = parseTimezone(dateStrings.timezone);
        if (isNaN(offset3)) {
          return /* @__PURE__ */ new Date(NaN);
        }
      } else {
        const dirtyDate = new Date(timestamp + time);
        const result = /* @__PURE__ */ new Date(0);
        result.setFullYear(
          dirtyDate.getUTCFullYear(),
          dirtyDate.getUTCMonth(),
          dirtyDate.getUTCDate()
        );
        result.setHours(
          dirtyDate.getUTCHours(),
          dirtyDate.getUTCMinutes(),
          dirtyDate.getUTCSeconds(),
          dirtyDate.getUTCMilliseconds()
        );
        return result;
      }
      return new Date(timestamp + time + offset3);
    }
    var patterns = {
      dateTimeDelimiter: /[T ]/,
      timeZoneDelimiter: /[Z ]/i,
      timezone: /([Z+-].*)$/
    };
    var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
    var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
    var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
    function splitDateString(dateString) {
      const dateStrings = {};
      const array = dateString.split(patterns.dateTimeDelimiter);
      let timeString;
      if (array.length > 2) {
        return dateStrings;
      }
      if (/:/.test(array[0])) {
        timeString = array[0];
      } else {
        dateStrings.date = array[0];
        timeString = array[1];
        if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
          dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
          timeString = dateString.substr(
            dateStrings.date.length,
            dateString.length
          );
        }
      }
      if (timeString) {
        const token2 = patterns.timezone.exec(timeString);
        if (token2) {
          dateStrings.time = timeString.replace(token2[1], "");
          dateStrings.timezone = token2[1];
        } else {
          dateStrings.time = timeString;
        }
      }
      return dateStrings;
    }
    function parseYear(dateString, additionalDigits) {
      const regex = new RegExp(
        "^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)"
      );
      const captures = dateString.match(regex);
      if (!captures)
        return { year: NaN, restDateString: "" };
      const year = captures[1] ? parseInt(captures[1]) : null;
      const century = captures[2] ? parseInt(captures[2]) : null;
      return {
        year: century === null ? year : century * 100,
        restDateString: dateString.slice((captures[1] || captures[2]).length)
      };
    }
    function parseDate(dateString, year) {
      if (year === null)
        return /* @__PURE__ */ new Date(NaN);
      const captures = dateString.match(dateRegex);
      if (!captures)
        return /* @__PURE__ */ new Date(NaN);
      const isWeekDate = !!captures[4];
      const dayOfYear = parseDateUnit(captures[1]);
      const month = parseDateUnit(captures[2]) - 1;
      const day = parseDateUnit(captures[3]);
      const week = parseDateUnit(captures[4]);
      const dayOfWeek = parseDateUnit(captures[5]) - 1;
      if (isWeekDate) {
        if (!validateWeekDate(year, week, dayOfWeek)) {
          return /* @__PURE__ */ new Date(NaN);
        }
        return dayOfISOWeekYear(year, week, dayOfWeek);
      } else {
        const date = /* @__PURE__ */ new Date(0);
        if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
          return /* @__PURE__ */ new Date(NaN);
        }
        date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
        return date;
      }
    }
    function parseDateUnit(value) {
      return value ? parseInt(value) : 1;
    }
    function parseTime(timeString) {
      const captures = timeString.match(timeRegex);
      if (!captures)
        return NaN;
      const hours = parseTimeUnit(captures[1]);
      const minutes = parseTimeUnit(captures[2]);
      const seconds = parseTimeUnit(captures[3]);
      if (!validateTime(hours, minutes, seconds)) {
        return NaN;
      }
      return hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * 1e3;
    }
    function parseTimeUnit(value) {
      return value && parseFloat(value.replace(",", ".")) || 0;
    }
    function parseTimezone(timezoneString) {
      if (timezoneString === "Z")
        return 0;
      const captures = timezoneString.match(timezoneRegex);
      if (!captures)
        return 0;
      const sign = captures[1] === "+" ? -1 : 1;
      const hours = parseInt(captures[2]);
      const minutes = captures[3] && parseInt(captures[3]) || 0;
      if (!validateTimezone(hours, minutes)) {
        return NaN;
      }
      return sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute);
    }
    function dayOfISOWeekYear(isoWeekYear, week, day) {
      const date = /* @__PURE__ */ new Date(0);
      date.setUTCFullYear(isoWeekYear, 0, 4);
      const fourthOfJanuaryDay = date.getUTCDay() || 7;
      const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date;
    }
    var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function isLeapYearIndex(year) {
      return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
    }
    function validateDate(year, month, date) {
      return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
    }
    function validateDayOfYearDate(year, dayOfYear) {
      return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
    }
    function validateWeekDate(_year, week, day) {
      return week >= 1 && week <= 53 && day >= 0 && day <= 6;
    }
    function validateTime(hours, minutes, seconds) {
      if (hours === 24) {
        return minutes === 0 && seconds === 0;
      }
      return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
    }
    function validateTimezone(_hours, minutes) {
      return minutes >= 0 && minutes <= 59;
    }
  }
});

// node_modules/react-onclickoutside/dist/react-onclickoutside.es.js
var react_onclickoutside_es_exports = {};
__export(react_onclickoutside_es_exports, {
  IGNORE_CLASS_NAME: () => IGNORE_CLASS_NAME,
  default: () => react_onclickoutside_es_default
});
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function isNodeFound(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  if (current.correspondingElement) {
    return current.correspondingElement.classList.contains(ignoreClass);
  }
  return current.classList.contains(ignoreClass);
}
function findHighest(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  while (current.parentNode || current.host) {
    if (current.parentNode && isNodeFound(current, componentNode, ignoreClass)) {
      return true;
    }
    current = current.parentNode || current.host;
  }
  return current;
}
function clickedScrollbar(evt) {
  return document.documentElement.clientWidth <= evt.clientX || document.documentElement.clientHeight <= evt.clientY;
}
function autoInc(seed) {
  if (seed === void 0) {
    seed = 0;
  }
  return function() {
    return ++seed;
  };
}
function getEventHandlerOptions(instance, eventName) {
  var handlerOptions = {};
  var isTouchEvent2 = touchEvents.indexOf(eventName) !== -1;
  if (isTouchEvent2 && passiveEventSupport) {
    handlerOptions.passive = !instance.props.preventDefault;
  }
  return handlerOptions;
}
function onClickOutsideHOC(WrappedComponent, config2) {
  var _class, _temp;
  var componentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
  return _temp = _class = /* @__PURE__ */ function(_Component) {
    _inheritsLoose(onClickOutside, _Component);
    function onClickOutside(props) {
      var _this;
      _this = _Component.call(this, props) || this;
      _this.__outsideClickHandler = function(event) {
        if (typeof _this.__clickOutsideHandlerProp === "function") {
          _this.__clickOutsideHandlerProp(event);
          return;
        }
        var instance = _this.getInstance();
        if (typeof instance.props.handleClickOutside === "function") {
          instance.props.handleClickOutside(event);
          return;
        }
        if (typeof instance.handleClickOutside === "function") {
          instance.handleClickOutside(event);
          return;
        }
        throw new Error("WrappedComponent: " + componentName + " lacks a handleClickOutside(event) function for processing outside click events.");
      };
      _this.__getComponentNode = function() {
        var instance = _this.getInstance();
        if (config2 && typeof config2.setClickOutsideRef === "function") {
          return config2.setClickOutsideRef()(instance);
        }
        if (typeof instance.setClickOutsideRef === "function") {
          return instance.setClickOutsideRef();
        }
        return (0, import_react_dom2.findDOMNode)(instance);
      };
      _this.enableOnClickOutside = function() {
        if (typeof document === "undefined" || enabledInstances[_this._uid]) {
          return;
        }
        if (typeof passiveEventSupport === "undefined") {
          passiveEventSupport = testPassiveEventSupport();
        }
        enabledInstances[_this._uid] = true;
        var events = _this.props.eventTypes;
        if (!events.forEach) {
          events = [events];
        }
        handlersMap[_this._uid] = function(event) {
          if (_this.componentNode === null)
            return;
          if (_this.props.preventDefault) {
            event.preventDefault();
          }
          if (_this.props.stopPropagation) {
            event.stopPropagation();
          }
          if (_this.props.excludeScrollbar && clickedScrollbar(event))
            return;
          var current = event.composed && event.composedPath && event.composedPath().shift() || event.target;
          if (findHighest(current, _this.componentNode, _this.props.outsideClickIgnoreClass) !== document) {
            return;
          }
          _this.__outsideClickHandler(event);
        };
        events.forEach(function(eventName) {
          document.addEventListener(eventName, handlersMap[_this._uid], getEventHandlerOptions(_assertThisInitialized(_this), eventName));
        });
      };
      _this.disableOnClickOutside = function() {
        delete enabledInstances[_this._uid];
        var fn2 = handlersMap[_this._uid];
        if (fn2 && typeof document !== "undefined") {
          var events = _this.props.eventTypes;
          if (!events.forEach) {
            events = [events];
          }
          events.forEach(function(eventName) {
            return document.removeEventListener(eventName, fn2, getEventHandlerOptions(_assertThisInitialized(_this), eventName));
          });
          delete handlersMap[_this._uid];
        }
      };
      _this.getRef = function(ref) {
        return _this.instanceRef = ref;
      };
      _this._uid = uid();
      return _this;
    }
    var _proto = onClickOutside.prototype;
    _proto.getInstance = function getInstance() {
      if (WrappedComponent.prototype && !WrappedComponent.prototype.isReactComponent) {
        return this;
      }
      var ref = this.instanceRef;
      return ref.getInstance ? ref.getInstance() : ref;
    };
    _proto.componentDidMount = function componentDidMount() {
      if (typeof document === "undefined" || !document.createElement) {
        return;
      }
      var instance = this.getInstance();
      if (config2 && typeof config2.handleClickOutside === "function") {
        this.__clickOutsideHandlerProp = config2.handleClickOutside(instance);
        if (typeof this.__clickOutsideHandlerProp !== "function") {
          throw new Error("WrappedComponent: " + componentName + " lacks a function for processing outside click events specified by the handleClickOutside config option.");
        }
      }
      this.componentNode = this.__getComponentNode();
      if (this.props.disableOnClickOutside)
        return;
      this.enableOnClickOutside();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      this.componentNode = this.__getComponentNode();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.disableOnClickOutside();
    };
    _proto.render = function render() {
      var _this$props = this.props;
      _this$props.excludeScrollbar;
      var props = _objectWithoutPropertiesLoose(_this$props, ["excludeScrollbar"]);
      if (WrappedComponent.prototype && WrappedComponent.prototype.isReactComponent) {
        props.ref = this.getRef;
      } else {
        props.wrappedRef = this.getRef;
      }
      props.disableOnClickOutside = this.disableOnClickOutside;
      props.enableOnClickOutside = this.enableOnClickOutside;
      return (0, import_react88.createElement)(WrappedComponent, props);
    };
    return onClickOutside;
  }(import_react88.Component), _class.displayName = "OnClickOutside(" + componentName + ")", _class.defaultProps = {
    eventTypes: ["mousedown", "touchstart"],
    excludeScrollbar: config2 && config2.excludeScrollbar || false,
    outsideClickIgnoreClass: IGNORE_CLASS_NAME,
    preventDefault: false,
    stopPropagation: false
  }, _class.getClass = function() {
    return WrappedComponent.getClass ? WrappedComponent.getClass() : WrappedComponent;
  }, _temp;
}
var import_react88, import_react_dom2, testPassiveEventSupport, uid, passiveEventSupport, handlersMap, enabledInstances, touchEvents, IGNORE_CLASS_NAME, react_onclickoutside_es_default;
var init_react_onclickoutside_es = __esm({
  "node_modules/react-onclickoutside/dist/react-onclickoutside.es.js"() {
    import_react88 = __toESM(require_react());
    import_react_dom2 = __toESM(require_react_dom());
    testPassiveEventSupport = function testPassiveEventSupport2() {
      if (typeof window === "undefined" || typeof window.addEventListener !== "function") {
        return;
      }
      var passive2 = false;
      var options = Object.defineProperty({}, "passive", {
        get: function get3() {
          passive2 = true;
        }
      });
      var noop3 = function noop4() {
      };
      window.addEventListener("testPassiveEventSupport", noop3, options);
      window.removeEventListener("testPassiveEventSupport", noop3, options);
      return passive2;
    };
    uid = autoInc();
    handlersMap = {};
    enabledInstances = {};
    touchEvents = ["touchstart", "touchmove"];
    IGNORE_CLASS_NAME = "ignore-react-onclickoutside";
    react_onclickoutside_es_default = onClickOutsideHOC;
  }
});

// node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  while (((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains4(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next2 = child;
    while (next2) {
      if (parent === next2) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    }
  }
  return false;
}
function getPlatform2() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }
  if (isAndroid() && event.pointerType) {
    return event.type === "click" && event.buttons === 1;
  }
  return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  if (isJSDOM())
    return false;
  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || // iOS VoiceOver returns 0.333 for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isSafari2() {
  return /apple/i.test(navigator.vendor);
}
function isAndroid() {
  const re = /android/i;
  return re.test(getPlatform2()) || re.test(getUserAgent());
}
function isMac() {
  return getPlatform2().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
function isMouseLikePointerType(pointerType, strict) {
  const values = ["mouse", "pen"];
  if (!strict) {
    values.push("", void 0);
  }
  return values.includes(pointerType);
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node2) {
  return (node2 == null ? void 0 : node2.ownerDocument) || document;
}
function isEventTargetWithin(event, node2) {
  if (node2 == null) {
    return false;
  }
  if ("composedPath" in event) {
    return event.composedPath().includes(node2);
  }
  const e = event;
  return e.target != null && node2.contains(e.target);
}
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
function isTypeableCombobox(element) {
  if (!element)
    return false;
  return element.getAttribute("role") === "combobox" && isTypeableElement(element);
}
var TYPEABLE_SELECTOR;
var init_floating_ui_react_utils = __esm({
  "node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs"() {
    init_floating_ui_utils_dom();
    TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
  }
});

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors, candidateSelector, NoElement, matches, getRootNode, isInert, isContentEditable2, getCandidates, getCandidatesIteratively, hasTabIndex2, getTabIndex, getSortOrderTabIndex, sortOrderedTabbables, isInput, isHiddenInput, isDetailsWithSummary, getCheckedRadio, isTabbableRadio, isRadio, isNonTabbableRadio, isNodeAttached, isZeroArea, isHidden2, isDisabledFromFieldset, isNodeMatchingSelectorFocusable, isNodeMatchingSelectorTabbable, isValidShadowRootTabbable, sortByOrder, tabbable;
var init_index_esm = __esm({
  "node_modules/tabbable/dist/index.esm.js"() {
    candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
    candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
    NoElement = typeof Element === "undefined";
    matches = NoElement ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
      var _element$getRootNode;
      return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
    } : function(element) {
      return element === null || element === void 0 ? void 0 : element.ownerDocument;
    };
    isInert = function isInert2(node2, lookUp) {
      var _node$getAttribute;
      if (lookUp === void 0) {
        lookUp = true;
      }
      var inertAtt = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "inert");
      var inert = inertAtt === "" || inertAtt === "true";
      var result = inert || lookUp && node2 && isInert2(node2.parentNode);
      return result;
    };
    isContentEditable2 = function isContentEditable3(node2) {
      var _node$getAttribute2;
      var attValue = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute2 = node2.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node2, "contenteditable");
      return attValue === "" || attValue === "true";
    };
    getCandidates = function getCandidates2(el, includeContainer, filter3) {
      if (isInert(el)) {
        return [];
      }
      var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
      if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
      }
      candidates = candidates.filter(filter3);
      return candidates;
    };
    getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
      var candidates = [];
      var elementsToCheck = Array.from(elements);
      while (elementsToCheck.length) {
        var element = elementsToCheck.shift();
        if (isInert(element, false)) {
          continue;
        }
        if (element.tagName === "SLOT") {
          var assigned = element.assignedElements();
          var content = assigned.length ? assigned : element.children;
          var nestedCandidates = getCandidatesIteratively2(content, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element,
              candidates: nestedCandidates
            });
          }
        } else {
          var validCandidate = matches.call(element, candidateSelector);
          if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
            candidates.push(element);
          }
          var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
          typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
          var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
          if (shadowRoot && validShadowRoot) {
            var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
            if (options.flatten) {
              candidates.push.apply(candidates, _nestedCandidates);
            } else {
              candidates.push({
                scopeParent: element,
                candidates: _nestedCandidates
              });
            }
          } else {
            elementsToCheck.unshift.apply(elementsToCheck, element.children);
          }
        }
      }
      return candidates;
    };
    hasTabIndex2 = function hasTabIndex3(node2) {
      return !isNaN(parseInt(node2.getAttribute("tabindex"), 10));
    };
    getTabIndex = function getTabIndex2(node2) {
      if (!node2) {
        throw new Error("No node provided");
      }
      if (node2.tabIndex < 0) {
        if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node2.tagName) || isContentEditable2(node2)) && !hasTabIndex2(node2)) {
          return 0;
        }
      }
      return node2.tabIndex;
    };
    getSortOrderTabIndex = function getSortOrderTabIndex2(node2, isScope) {
      var tabIndex = getTabIndex(node2);
      if (tabIndex < 0 && isScope && !hasTabIndex2(node2)) {
        return 0;
      }
      return tabIndex;
    };
    sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
      return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
    };
    isInput = function isInput2(node2) {
      return node2.tagName === "INPUT";
    };
    isHiddenInput = function isHiddenInput2(node2) {
      return isInput(node2) && node2.type === "hidden";
    };
    isDetailsWithSummary = function isDetailsWithSummary2(node2) {
      var r2 = node2.tagName === "DETAILS" && Array.prototype.slice.apply(node2.children).some(function(child) {
        return child.tagName === "SUMMARY";
      });
      return r2;
    };
    getCheckedRadio = function getCheckedRadio2(nodes, form) {
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].checked && nodes[i].form === form) {
          return nodes[i];
        }
      }
    };
    isTabbableRadio = function isTabbableRadio2(node2) {
      if (!node2.name) {
        return true;
      }
      var radioScope = node2.form || getRootNode(node2);
      var queryRadios = function queryRadios2(name) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
      };
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node2.name));
      } else {
        try {
          radioSet = queryRadios(node2.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node2.form);
      return !checked || checked === node2;
    };
    isRadio = function isRadio2(node2) {
      return isInput(node2) && node2.type === "radio";
    };
    isNonTabbableRadio = function isNonTabbableRadio2(node2) {
      return isRadio(node2) && !isTabbableRadio(node2);
    };
    isNodeAttached = function isNodeAttached2(node2) {
      var _nodeRoot;
      var nodeRoot = node2 && getRootNode(node2);
      var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
      var attached = false;
      if (nodeRoot && nodeRoot !== node2) {
        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
        attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node2 !== null && node2 !== void 0 && (_node$ownerDocument = node2.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node2));
        while (!attached && nodeRootHost) {
          var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
          nodeRoot = getRootNode(nodeRootHost);
          nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
          attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
        }
      }
      return attached;
    };
    isZeroArea = function isZeroArea2(node2) {
      var _node$getBoundingClie = node2.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
      return width === 0 && height === 0;
    };
    isHidden2 = function isHidden3(node2, _ref) {
      var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
      if (getComputedStyle(node2).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches.call(node2, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node2.parentElement : node2;
      if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
        if (typeof getShadowRoot === "function") {
          var originalNode = node2;
          while (node2) {
            var parentElement = node2.parentElement;
            var rootNode = getRootNode(node2);
            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
              return isZeroArea(node2);
            } else if (node2.assignedSlot) {
              node2 = node2.assignedSlot;
            } else if (!parentElement && rootNode !== node2.ownerDocument) {
              node2 = rootNode.host;
            } else {
              node2 = parentElement;
            }
          }
          node2 = originalNode;
        }
        if (isNodeAttached(node2)) {
          return !node2.getClientRects().length;
        }
        if (displayCheck !== "legacy-full") {
          return true;
        }
      } else if (displayCheck === "non-zero-area") {
        return isZeroArea(node2);
      }
      return false;
    };
    isDisabledFromFieldset = function isDisabledFromFieldset2(node2) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node2.tagName)) {
        var parentNode = node2.parentElement;
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i);
              if (child.tagName === "LEGEND") {
                return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node2);
              }
            }
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      return false;
    };
    isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node2) {
      if (node2.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
      //  because we're limited in the type of selectors we can use in JSDom (see related
      //  note related to `candidateSelectors`)
      isInert(node2) || isHiddenInput(node2) || isHidden2(node2, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node2) || isDisabledFromFieldset(node2)) {
        return false;
      }
      return true;
    };
    isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node2) {
      if (isNonTabbableRadio(node2) || getTabIndex(node2) < 0 || !isNodeMatchingSelectorFocusable(options, node2)) {
        return false;
      }
      return true;
    };
    isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
      var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
      if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
      }
      return false;
    };
    sortByOrder = function sortByOrder2(candidates) {
      var regularTabbables = [];
      var orderedTabbables = [];
      candidates.forEach(function(item, i) {
        var isScope = !!item.scopeParent;
        var element = isScope ? item.scopeParent : item;
        var candidateTabindex = getSortOrderTabIndex(element, isScope);
        var elements = isScope ? sortByOrder2(item.candidates) : element;
        if (candidateTabindex === 0) {
          isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
        } else {
          orderedTabbables.push({
            documentOrder: i,
            tabIndex: candidateTabindex,
            item,
            isScope,
            content: elements
          });
        }
      });
      return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
        return acc;
      }, []).concat(regularTabbables);
    };
    tabbable = function tabbable2(container2, options) {
      options = options || {};
      var candidates;
      if (options.getShadowRoot) {
        candidates = getCandidatesIteratively([container2], options.includeContainer, {
          filter: isNodeMatchingSelectorTabbable.bind(null, options),
          flatten: false,
          getShadowRoot: options.getShadowRoot,
          shadowRootFilter: isValidShadowRootTabbable
        });
      } else {
        candidates = getCandidates(container2, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
      }
      return sortByOrder(candidates);
    };
  }
});

// node_modules/@floating-ui/react/dist/floating-ui.react.esm.js
var floating_ui_react_esm_exports = {};
__export(floating_ui_react_esm_exports, {
  Composite: () => Composite,
  CompositeItem: () => CompositeItem,
  FloatingArrow: () => FloatingArrow,
  FloatingDelayGroup: () => FloatingDelayGroup,
  FloatingFocusManager: () => FloatingFocusManager,
  FloatingList: () => FloatingList,
  FloatingNode: () => FloatingNode,
  FloatingOverlay: () => FloatingOverlay,
  FloatingPortal: () => FloatingPortal,
  FloatingTree: () => FloatingTree,
  arrow: () => arrow,
  autoPlacement: () => autoPlacement,
  autoUpdate: () => autoUpdate,
  computePosition: () => computePosition,
  detectOverflow: () => detectOverflow,
  flip: () => flip,
  getOverflowAncestors: () => getOverflowAncestors,
  hide: () => hide,
  inline: () => inline,
  inner: () => inner,
  limitShift: () => limitShift,
  offset: () => offset,
  platform: () => platform,
  safePolygon: () => safePolygon,
  shift: () => shift,
  size: () => size,
  useClick: () => useClick,
  useClientPoint: () => useClientPoint,
  useDelayGroup: () => useDelayGroup,
  useDelayGroupContext: () => useDelayGroupContext,
  useDismiss: () => useDismiss,
  useFloating: () => useFloating2,
  useFloatingNodeId: () => useFloatingNodeId,
  useFloatingParentNodeId: () => useFloatingParentNodeId,
  useFloatingPortalNode: () => useFloatingPortalNode,
  useFloatingTree: () => useFloatingTree,
  useFocus: () => useFocus,
  useHover: () => useHover,
  useId: () => useId6,
  useInnerOffset: () => useInnerOffset,
  useInteractions: () => useInteractions,
  useListItem: () => useListItem,
  useListNavigation: () => useListNavigation,
  useMergeRefs: () => useMergeRefs2,
  useRole: () => useRole,
  useTransitionStatus: () => useTransitionStatus,
  useTransitionStyles: () => useTransitionStyles,
  useTypeahead: () => useTypeahead
});
function useMergeRefs2(refs) {
  return React10.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
function useEffectEvent(callback) {
  const ref = React10.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React10.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
function isDifferentRow(index3, cols, prevRow) {
  return Math.floor(index3 / cols) !== prevRow;
}
function isIndexOutOfBounds(listRef, index3) {
  return index3 < 0 || index3 >= listRef.current.length;
}
function getMinIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    disabledIndices
  });
}
function getMaxIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  const list2 = listRef.current;
  const isDisabledIndex = disabledIndices ? (index4) => disabledIndices.includes(index4) : (index4) => {
    const element = list2[index4];
    return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
  };
  let index3 = startingIndex;
  do {
    index3 += decrement ? -amount : amount;
  } while (index3 >= 0 && index3 <= list2.length - 1 && isDisabledIndex(index3));
  return index3;
}
function getGridNavigatedIndex(elementsRef, _ref) {
  let {
    event,
    orientation,
    loop,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false
  } = _ref;
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = maxIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: nextIndex,
        amount: cols,
        decrement: true,
        disabledIndices
      });
      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
        const col = prevIndex % cols;
        const maxCol = maxIndex % cols;
        const offset3 = maxIndex - (maxCol - col);
        if (maxCol === col) {
          nextIndex = maxIndex;
        } else {
          nextIndex = maxCol > col ? offset3 : offset3 - cols;
        }
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (event.key === ARROW_DOWN) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = minIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: prevIndex,
        amount: cols,
        disabledIndices
      });
      if (loop && prevIndex + cols > maxIndex) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex % cols - cols,
          amount: cols,
          disabledIndices
        });
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === ARROW_RIGHT) {
      stop && stopEvent(event);
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === ARROW_LEFT) {
      stop && stopEvent(event);
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          disabledIndices,
          decrement: true
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex + (cols - prevIndex % cols),
          decrement: true,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      if (loop && lastRow) {
        nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function buildCellMap(sizes24, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes24.forEach((_ref2, index3) => {
    let {
      width,
      height
    } = _ref2;
    if (width > cols) {
      if (true) {
        throw new Error("[Floating UI]: Invalid grid - item width at index " + index3 + " is greater than grid columns");
      }
    }
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i = 0; i < width; i++) {
        for (let j = 0; j < height; j++) {
          targetCells.push(startIndex + i + j * cols);
        }
      }
      if (startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null)) {
        targetCells.forEach((cell) => {
          cellMap[cell] = index3;
        });
        itemPlaced = true;
      } else {
        startIndex++;
      }
    }
  });
  return [...cellMap];
}
function getCellIndexOfCorner(index3, sizes24, cellMap, cols, corner) {
  if (index3 === -1)
    return -1;
  const firstCellIndex = cellMap.indexOf(index3);
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      return firstCellIndex + sizes24[index3].width - 1;
    case "bl":
      return firstCellIndex + (sizes24[index3].height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index3);
  }
}
function getCellIndices(indices, cellMap) {
  return cellMap.flatMap((index3, cellIndex) => indices.includes(index3) ? [cellIndex] : []);
}
function enqueueFocus(el, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    preventScroll = false,
    cancelPrevious = true,
    sync: sync3 = false
  } = options;
  cancelPrevious && cancelAnimationFrame(rafId);
  const exec = () => el == null ? void 0 : el.focus({
    preventScroll
  });
  if (sync3) {
    exec();
  } else {
    rafId = requestAnimationFrame(exec);
  }
}
function sortByDocumentPosition(a2, b2) {
  const position3 = a2.compareDocumentPosition(b2);
  if (position3 & Node.DOCUMENT_POSITION_FOLLOWING || position3 & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position3 & Node.DOCUMENT_POSITION_PRECEDING || position3 & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
function areMapsEqual(map1, map2) {
  if (map1.size !== map2.size) {
    return false;
  }
  for (const [key, value] of map1.entries()) {
    if (value !== map2.get(key)) {
      return false;
    }
  }
  return true;
}
function FloatingList(_ref) {
  let {
    children,
    elementsRef,
    labelsRef
  } = _ref;
  const [map, setMap] = React10.useState(() => /* @__PURE__ */ new Map());
  const register = React10.useCallback((node2) => {
    setMap((prevMap) => new Map(prevMap).set(node2, null));
  }, []);
  const unregister = React10.useCallback((node2) => {
    setMap((prevMap) => {
      const map2 = new Map(prevMap);
      map2.delete(node2);
      return map2;
    });
  }, []);
  index2(() => {
    const newMap = new Map(map);
    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);
    nodes.forEach((node2, index3) => {
      newMap.set(node2, index3);
    });
    if (!areMapsEqual(map, newMap)) {
      setMap(newMap);
    }
  }, [map]);
  return /* @__PURE__ */ React10.createElement(FloatingListContext.Provider, {
    value: React10.useMemo(() => ({
      register,
      unregister,
      map,
      elementsRef,
      labelsRef
    }), [register, unregister, map, elementsRef, labelsRef])
  }, children);
}
function useListItem(_temp) {
  let {
    label
  } = _temp === void 0 ? {} : _temp;
  const [index$1, setIndex] = React10.useState(null);
  const componentRef = React10.useRef(null);
  const {
    register,
    unregister,
    map,
    elementsRef,
    labelsRef
  } = React10.useContext(FloatingListContext);
  const ref = React10.useCallback((node2) => {
    componentRef.current = node2;
    if (index$1 !== null) {
      elementsRef.current[index$1] = node2;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label !== void 0;
        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node2 == null ? void 0 : node2.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index$1, elementsRef, labelsRef, label]);
  index2(() => {
    const node2 = componentRef.current;
    if (node2) {
      register(node2);
      return () => {
        unregister(node2);
      };
    }
  }, [register, unregister]);
  index2(() => {
    const index3 = componentRef.current ? map.get(componentRef.current) : null;
    if (index3 != null) {
      setIndex(index3);
    }
  }, [map]);
  return React10.useMemo(() => ({
    ref,
    index: index$1 == null ? -1 : index$1
  }), [index$1, ref]);
}
function renderJsx(render, computedProps) {
  if (typeof render === "function") {
    return render(computedProps);
  }
  if (render) {
    return /* @__PURE__ */ React10.cloneElement(render, computedProps);
  }
  return /* @__PURE__ */ React10.createElement("div", computedProps);
}
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function useFloatingId() {
  const [id2, setId] = React10.useState(() => serverHandoffComplete ? genId() : void 0);
  index2(() => {
    if (id2 == null) {
      setId(genId());
    }
  }, []);
  React10.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id2;
}
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l) => l !== listener)) || []);
    }
  };
}
function useFloatingNodeId(customParentId) {
  const id2 = useId6();
  const tree = useFloatingTree();
  const reactParentId = useFloatingParentNodeId();
  const parentId = customParentId || reactParentId;
  index2(() => {
    const node2 = {
      id: id2,
      parentId
    };
    tree == null || tree.addNode(node2);
    return () => {
      tree == null || tree.removeNode(node2);
    };
  }, [tree, id2, parentId]);
  return id2;
}
function FloatingNode(_ref) {
  let {
    children,
    id: id2
  } = _ref;
  const parentId = useFloatingParentNodeId();
  return /* @__PURE__ */ React10.createElement(FloatingNodeContext.Provider, {
    value: React10.useMemo(() => ({
      id: id2,
      parentId
    }), [id2, parentId])
  }, children);
}
function FloatingTree(_ref2) {
  let {
    children
  } = _ref2;
  const nodesRef = React10.useRef([]);
  const addNode = React10.useCallback((node2) => {
    nodesRef.current = [...nodesRef.current, node2];
  }, []);
  const removeNode = React10.useCallback((node2) => {
    nodesRef.current = nodesRef.current.filter((n) => n !== node2);
  }, []);
  const events = React10.useState(() => createPubSub())[0];
  return /* @__PURE__ */ React10.createElement(FloatingTreeContext.Provider, {
    value: React10.useMemo(() => ({
      nodesRef,
      addNode,
      removeNode,
      events
    }), [addNode, removeNode, events])
  }, children);
}
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function useLatestRef(value) {
  const ref = (0, import_react89.useRef)(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  return value == null ? void 0 : value[prop];
}
function useHover(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements: {
      domReference,
      floating
    },
    refs
  } = context;
  const {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef(handleClose);
  const delayRef = useLatestRef(delay);
  const pointerTypeRef = React10.useRef();
  const timeoutRef = React10.useRef();
  const handlerRef = React10.useRef();
  const restTimeoutRef = React10.useRef();
  const blockMouseMoveRef = React10.useRef(true);
  const performedPointerEventsMutationRef = React10.useRef(false);
  const unbindMouseMoveRef = React10.useRef(() => {
  });
  const isHoverOpen = React10.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  }, [dataRef]);
  React10.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      if (!open2) {
        clearTimeout(timeoutRef.current);
        clearTimeout(restTimeoutRef.current);
        blockMouseMoveRef.current = true;
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled, events]);
  React10.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open) {
      return;
    }
    function onLeave(event) {
      if (isHoverOpen()) {
        onOpenChange(false, event, "hover");
      }
    }
    const html = getDocument(floating).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React10.useCallback(function(event, runElseBranch, reason) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    if (reason === void 0) {
      reason = "hover";
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = setTimeout(() => onOpenChange(false, event, reason), closeDelay);
    } else if (runElseBranch) {
      clearTimeout(timeoutRef.current);
      onOpenChange(false, event, reason);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = React10.useCallback(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  }, []);
  const clearPointerEvents = React10.useCallback(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(refs.floating.current).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  }, [refs]);
  React10.useEffect(() => {
    if (!enabled) {
      return;
    }
    function isClickLikeOpenEvent() {
      return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
    }
    function onMouseEnter(event) {
      clearTimeout(timeoutRef.current);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, "open") === 0) {
        return;
      }
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = setTimeout(() => {
          onOpenChange(true, event, "hover");
        }, openDelay);
      } else {
        onOpenChange(true, event, "hover");
      }
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument(floating);
      clearTimeout(restTimeoutRef.current);
      if (handleCloseRef.current) {
        if (!open) {
          clearTimeout(timeoutRef.current);
        }
        handlerRef.current = handleCloseRef.current({
          ...context,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            closeWithDelay(event, true, "safe-polygon");
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === "touch" ? !contains4(floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      handleCloseRef.current == null || handleCloseRef.current({
        ...context,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          closeWithDelay(event);
        }
      })(event);
    }
    if (isElement(domReference)) {
      const ref = domReference;
      open && ref.addEventListener("mouseleave", onScrollMouseLeave);
      floating == null || floating.addEventListener("mouseleave", onScrollMouseLeave);
      move && ref.addEventListener("mousemove", onMouseEnter, {
        once: true
      });
      ref.addEventListener("mouseenter", onMouseEnter);
      ref.addEventListener("mouseleave", onMouseLeave);
      return () => {
        open && ref.removeEventListener("mouseleave", onScrollMouseLeave);
        floating == null || floating.removeEventListener("mouseleave", onScrollMouseLeave);
        move && ref.removeEventListener("mousemove", onMouseEnter);
        ref.removeEventListener("mouseenter", onMouseEnter);
        ref.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);
  index2(() => {
    var _handleCloseRef$curre;
    if (!enabled) {
      return;
    }
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      const body = getDocument(floating).body;
      body.setAttribute(safePolygonIdentifier, "");
      body.style.pointerEvents = "none";
      performedPointerEventsMutationRef.current = true;
      if (isElement(domReference) && floating) {
        var _tree$nodesRef$curren;
        const ref = domReference;
        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node2) => node2.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        ref.style.pointerEvents = "auto";
        floating.style.pointerEvents = "auto";
        return () => {
          ref.style.pointerEvents = "";
          floating.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, isHoverOpen]);
  index2(() => {
    if (!open) {
      pointerTypeRef.current = void 0;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  React10.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      clearPointerEvents();
    };
  }, [enabled, domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  return React10.useMemo(() => {
    if (!enabled) {
      return {};
    }
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      reference: {
        onPointerDown: setPointerRef,
        onPointerEnter: setPointerRef,
        onMouseMove(event) {
          if (open || restMs === 0) {
            return;
          }
          clearTimeout(restTimeoutRef.current);
          restTimeoutRef.current = setTimeout(() => {
            if (!blockMouseMoveRef.current) {
              onOpenChange(true, event.nativeEvent, "hover");
            }
          }, restMs);
        }
      },
      floating: {
        onMouseEnter() {
          clearTimeout(timeoutRef.current);
        },
        onMouseLeave(event) {
          closeWithDelay(event.nativeEvent, false);
        }
      }
    };
  }, [enabled, restMs, open, onOpenChange, closeWithDelay]);
}
function getAncestors(nodes, id2) {
  var _nodes$find;
  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes.find((node2) => node2.id === id2)) == null ? void 0 : _nodes$find.parentId;
  while (currentParentId) {
    const currentNode = nodes.find((node2) => node2.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;
    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }
  return allAncestors;
}
function getChildren(nodes, id2) {
  let allChildren = nodes.filter((node2) => {
    var _node$context;
    return node2.parentId === id2 && ((_node$context = node2.context) == null ? void 0 : _node$context.open);
  });
  let currentChildren = allChildren;
  while (currentChildren.length) {
    currentChildren = nodes.filter((node2) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n) => {
        var _node$context2;
        return node2.parentId === n.id && ((_node$context2 = node2.context) == null ? void 0 : _node$context2.open);
      });
    });
    allChildren = allChildren.concat(currentChildren);
  }
  return allChildren;
}
function getDeepestNode(nodes, id2) {
  let deepestNodeId;
  let maxDepth2 = -1;
  function findDeepest(nodeId, depth) {
    if (depth > maxDepth2) {
      deepestNodeId = nodeId;
      maxDepth2 = depth;
    }
    const children = getChildren(nodes, nodeId);
    children.forEach((child) => {
      findDeepest(child.id, depth + 1);
    });
  }
  findDeepest(id2, 0);
  return nodes.find((node2) => node2.id === deepestNodeId);
}
function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {
  const markerName = "data-floating-ui-inert";
  const controlAttribute = inert ? "inert" : ariaHidden ? "aria-hidden" : null;
  const avoidElements = correctElements(body, uncorrectedAvoidElements);
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(avoidElements);
  const hiddenElements = [];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  avoidElements.forEach(keep);
  deep(body);
  elementsToKeep.clear();
  function keep(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    el.parentNode && keep(el.parentNode);
  }
  function deep(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, (node2) => {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        const attr2 = controlAttribute ? node2.getAttribute(controlAttribute) : null;
        const alreadyHidden = attr2 !== null && attr2 !== "false";
        const counterValue = (counterMap.get(node2) || 0) + 1;
        const markerValue = (markerCounter.get(node2) || 0) + 1;
        counterMap.set(node2, counterValue);
        markerCounter.set(node2, markerValue);
        hiddenElements.push(node2);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledElementsSet.add(node2);
        }
        if (markerValue === 1) {
          node2.setAttribute(markerName, "");
        }
        if (!alreadyHidden && controlAttribute) {
          node2.setAttribute(controlAttribute, "true");
        }
      }
    });
  }
  lockCount++;
  return () => {
    hiddenElements.forEach((element) => {
      const counterValue = (counterMap.get(element) || 0) - 1;
      const markerValue = (markerCounter.get(element) || 0) - 1;
      counterMap.set(element, counterValue);
      markerCounter.set(element, markerValue);
      if (!counterValue) {
        if (!uncontrolledElementsSet.has(element) && controlAttribute) {
          element.removeAttribute(controlAttribute);
        }
        uncontrolledElementsSet.delete(element);
      }
      if (!markerValue) {
        element.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
      markerMap = {};
    }
  };
}
function markOthers(avoidElements, ariaHidden, inert) {
  if (ariaHidden === void 0) {
    ariaHidden = false;
  }
  if (inert === void 0) {
    inert = false;
  }
  const body = getDocument(avoidElements[0]).body;
  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll("[aria-live]"))), body, ariaHidden, inert);
}
function getTabbableIn(container2, direction2) {
  const allTabbable = tabbable(container2, getTabbableOptions());
  if (direction2 === "prev") {
    allTabbable.reverse();
  }
  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container2)));
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getNextTabbable() {
  return getTabbableIn(document.body, "next");
}
function getPreviousTabbable() {
  return getTabbableIn(document.body, "prev");
}
function isOutsideEvent(event, container2) {
  const containerElement = container2 || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains4(containerElement, relatedTarget);
}
function disableFocusInside(container2) {
  const tabbableElements = tabbable(container2, getTabbableOptions());
  tabbableElements.forEach((element) => {
    element.dataset.tabindex = element.getAttribute("tabindex") || "";
    element.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container2) {
  const elements = container2.querySelectorAll("[data-tabindex]");
  elements.forEach((element) => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex;
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  });
}
function setActiveElementOnTab(event) {
  if (event.key === "Tab") {
    event.target;
    clearTimeout(timeoutId);
  }
}
function useFloatingPortalNode(_temp) {
  let {
    id: id2,
    root
  } = _temp === void 0 ? {} : _temp;
  const [portalNode, setPortalNode] = React10.useState(null);
  const uniqueId = useId6();
  const portalContext = usePortalContext2();
  const portalNodeRef = React10.useRef(null);
  index2(() => {
    return () => {
      portalNode == null || portalNode.remove();
      queueMicrotask(() => {
        portalNodeRef.current = null;
      });
    };
  }, [portalNode]);
  index2(() => {
    if (portalNodeRef.current)
      return;
    const existingIdRoot = id2 ? document.getElementById(id2) : null;
    if (!existingIdRoot)
      return;
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    existingIdRoot.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id2, uniqueId]);
  index2(() => {
    if (portalNodeRef.current)
      return;
    let container2 = root || (portalContext == null ? void 0 : portalContext.portalNode);
    if (container2 && !isElement(container2))
      container2 = container2.current;
    container2 = container2 || document.body;
    let idWrapper = null;
    if (id2) {
      idWrapper = document.createElement("div");
      idWrapper.id = id2;
      container2.appendChild(idWrapper);
    }
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    container2 = idWrapper || container2;
    container2.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id2, root, uniqueId, portalContext]);
  return portalNode;
}
function FloatingPortal(_ref) {
  let {
    children,
    id: id2,
    root = null,
    preserveTabOrder = true
  } = _ref;
  const portalNode = useFloatingPortalNode({
    id: id2,
    root
  });
  const [focusManagerState, setFocusManagerState] = React10.useState(null);
  const beforeOutsideRef = React10.useRef(null);
  const afterOutsideRef = React10.useRef(null);
  const beforeInsideRef = React10.useRef(null);
  const afterInsideRef = React10.useRef(null);
  const shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && // Don't render if unmount is transitioning.
    focusManagerState.open && preserveTabOrder && !!(root || portalNode)
  );
  React10.useEffect(() => {
    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {
      return;
    }
    function onFocus(event) {
      if (portalNode && isOutsideEvent(event)) {
        const focusing = event.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    portalNode.addEventListener("focusin", onFocus, true);
    portalNode.addEventListener("focusout", onFocus, true);
    return () => {
      portalNode.removeEventListener("focusin", onFocus, true);
      portalNode.removeEventListener("focusout", onFocus, true);
    };
  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);
  return /* @__PURE__ */ React10.createElement(PortalContext.Provider, {
    value: React10.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode])
  }, shouldRenderGuards && portalNode && /* @__PURE__ */ React10.createElement(FocusGuard, {
    "data-type": "outside",
    ref: beforeOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _beforeInsideRef$curr;
        (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();
      } else {
        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        prevTabbable == null || prevTabbable.focus();
      }
    }
  }), shouldRenderGuards && portalNode && /* @__PURE__ */ React10.createElement("span", {
    "aria-owns": portalNode.id,
    style: HIDDEN_STYLES
  }), portalNode && /* @__PURE__ */ (0, import_react_dom5.createPortal)(children, portalNode), shouldRenderGuards && portalNode && /* @__PURE__ */ React10.createElement(FocusGuard, {
    "data-type": "outside",
    ref: afterOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _afterInsideRef$curre;
        (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();
      } else {
        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        nextTabbable == null || nextTabbable.focus();
        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));
      }
    }
  }));
}
function addPreviouslyFocusedElement(element) {
  previouslyFocusedElements = previouslyFocusedElements.filter((el) => el.isConnected);
  if (element && getNodeName(element) !== "body") {
    previouslyFocusedElements.push(element);
    if (previouslyFocusedElements.length > LIST_LIMIT) {
      previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);
    }
  }
}
function getPreviouslyFocusedElement() {
  return previouslyFocusedElements.slice().reverse().find((el) => el.isConnected);
}
function FloatingFocusManager(props) {
  const {
    context,
    children,
    disabled = false,
    order: order3 = ["content"],
    guards: _guards = true,
    initialFocus = 0,
    returnFocus = true,
    modal = true,
    visuallyHiddenDismiss = false,
    closeOnFocusOut = true
  } = props;
  const {
    open,
    refs,
    nodeId,
    onOpenChange,
    events,
    dataRef,
    elements: {
      domReference,
      floating
    }
  } = context;
  const ignoreInitialFocus = typeof initialFocus === "number" && initialFocus < 0;
  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;
  const guards = supportsInert() ? _guards : true;
  const orderRef = useLatestRef(order3);
  const initialFocusRef = useLatestRef(initialFocus);
  const returnFocusRef = useLatestRef(returnFocus);
  const tree = useFloatingTree();
  const portalContext = usePortalContext2();
  const startDismissButtonRef = React10.useRef(null);
  const endDismissButtonRef = React10.useRef(null);
  const preventReturnFocusRef = React10.useRef(false);
  const isPointerDownRef = React10.useRef(false);
  const isInsidePortal = portalContext != null;
  const getTabbableContent = React10.useCallback(function(container2) {
    if (container2 === void 0) {
      container2 = floating;
    }
    return container2 ? tabbable(container2, getTabbableOptions()) : [];
  }, [floating]);
  const getTabbableElements = React10.useCallback((container2) => {
    const content = getTabbableContent(container2);
    return orderRef.current.map((type) => {
      if (domReference && type === "reference") {
        return domReference;
      }
      if (floating && type === "floating") {
        return floating;
      }
      return content;
    }).filter(Boolean).flat();
  }, [domReference, floating, orderRef, getTabbableContent]);
  React10.useEffect(() => {
    if (disabled || !modal)
      return;
    function onKeyDown(event) {
      if (event.key === "Tab") {
        if (contains4(floating, activeElement(getDocument(floating))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {
          stopEvent(event);
        }
        const els = getTabbableElements();
        const target = getTarget(event);
        if (orderRef.current[0] === "reference" && target === domReference) {
          stopEvent(event);
          if (event.shiftKey) {
            enqueueFocus(els[els.length - 1]);
          } else {
            enqueueFocus(els[1]);
          }
        }
        if (orderRef.current[1] === "floating" && target === floating && event.shiftKey) {
          stopEvent(event);
          enqueueFocus(els[0]);
        }
      }
    }
    const doc = getDocument(floating);
    doc.addEventListener("keydown", onKeyDown);
    return () => {
      doc.removeEventListener("keydown", onKeyDown);
    };
  }, [disabled, domReference, floating, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);
  React10.useEffect(() => {
    if (disabled || !closeOnFocusOut)
      return;
    function handlePointerDown() {
      isPointerDownRef.current = true;
      setTimeout(() => {
        isPointerDownRef.current = false;
      });
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget;
      queueMicrotask(() => {
        const movedToUnrelatedNode = !(contains4(domReference, relatedTarget) || contains4(floating, relatedTarget) || contains4(relatedTarget, floating) || contains4(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute("focus-guard")) || tree && (getChildren(tree.nodesRef.current, nodeId).find((node2) => {
          var _node$context, _node$context2;
          return contains4((_node$context = node2.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains4((_node$context2 = node2.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);
        }) || getAncestors(tree.nodesRef.current, nodeId).find((node2) => {
          var _node$context3, _node$context4;
          return ((_node$context3 = node2.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node2.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;
        })));
        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        relatedTarget !== getPreviouslyFocusedElement()) {
          preventReturnFocusRef.current = true;
          onOpenChange(false, event);
        }
      });
    }
    if (floating && isHTMLElement(domReference)) {
      domReference.addEventListener("focusout", handleFocusOutside);
      domReference.addEventListener("pointerdown", handlePointerDown);
      !modal && floating.addEventListener("focusout", handleFocusOutside);
      return () => {
        domReference.removeEventListener("focusout", handleFocusOutside);
        domReference.removeEventListener("pointerdown", handlePointerDown);
        !modal && floating.removeEventListener("focusout", handleFocusOutside);
      };
    }
  }, [disabled, domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);
  React10.useEffect(() => {
    var _portalContext$portal;
    if (disabled)
      return;
    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll("[" + createAttribute("portal") + "]")) || []);
    if (floating) {
      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes("reference") || isUntrappedTypeableCombobox ? domReference : null].filter((x) => x != null);
      const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);
      return () => {
        cleanup();
      };
    }
  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);
  index2(() => {
    if (disabled || !floating)
      return;
    const doc = getDocument(floating);
    const previouslyFocusedElement = activeElement(doc);
    queueMicrotask(() => {
      const focusableElements = getTabbableElements(floating);
      const initialFocusValue = initialFocusRef.current;
      const elToFocus = (typeof initialFocusValue === "number" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;
      const focusAlreadyInsideFloatingEl = contains4(floating, previouslyFocusedElement);
      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {
        enqueueFocus(elToFocus, {
          preventScroll: elToFocus === floating
        });
      }
    });
  }, [disabled, open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);
  index2(() => {
    if (disabled || !floating)
      return;
    let preventReturnFocusScroll = false;
    const doc = getDocument(floating);
    const previouslyFocusedElement = activeElement(doc);
    const contextData = dataRef.current;
    addPreviouslyFocusedElement(previouslyFocusedElement);
    function onOpenChange2(_ref) {
      let {
        reason,
        event,
        nested
      } = _ref;
      if (reason === "escape-key" && refs.domReference.current) {
        addPreviouslyFocusedElement(refs.domReference.current);
      }
      if (reason === "hover" && event.type === "mouseleave") {
        preventReturnFocusRef.current = true;
      }
      if (reason !== "outside-press")
        return;
      if (nested) {
        preventReturnFocusRef.current = false;
        preventReturnFocusScroll = true;
      } else {
        preventReturnFocusRef.current = !(isVirtualClick(event) || isVirtualPointerEvent(event));
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
      const activeEl = activeElement(doc);
      const isFocusInsideFloatingTree = contains4(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some((node2) => {
        var _node$context5;
        return contains4((_node$context5 = node2.context) == null ? void 0 : _node$context5.elements.floating, activeEl);
      });
      const shouldFocusReference = isFocusInsideFloatingTree || contextData.openEvent && ["click", "mousedown"].includes(contextData.openEvent.type);
      if (shouldFocusReference && refs.domReference.current) {
        addPreviouslyFocusedElement(refs.domReference.current);
      }
      const returnElement = getPreviouslyFocusedElement();
      if (returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && // If the focus moved somewhere else after mount, avoid returning focus
      // since it likely entered a different element which should be
      // respected: https://github.com/floating-ui/floating-ui/issues/2607
      (returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {
        enqueueFocus(returnElement, {
          // When dismissing nested floating elements, by the time the rAF has
          // executed, the menus will all have been unmounted. When they try
          // to get focused, the calls get ignored  leaving the root
          // reference focused as desired.
          cancelPrevious: false,
          preventScroll: preventReturnFocusScroll
        });
      }
    };
  }, [disabled, floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);
  index2(() => {
    if (disabled || !portalContext)
      return;
    portalContext.setFocusManagerState({
      modal,
      closeOnFocusOut,
      open,
      onOpenChange,
      refs
    });
    return () => {
      portalContext.setFocusManagerState(null);
    };
  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);
  index2(() => {
    if (disabled || !floating || typeof MutationObserver !== "function" || ignoreInitialFocus) {
      return;
    }
    const handleMutation = () => {
      const tabIndex = floating.getAttribute("tabindex");
      if (orderRef.current.includes("floating") || activeElement(getDocument(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {
        if (tabIndex !== "0") {
          floating.setAttribute("tabindex", "0");
        }
      } else if (tabIndex !== "-1") {
        floating.setAttribute("tabindex", "-1");
      }
    };
    handleMutation();
    const observer = new MutationObserver(handleMutation);
    observer.observe(floating, {
      childList: true,
      subtree: true,
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [disabled, floating, refs, orderRef, getTabbableContent, ignoreInitialFocus]);
  function renderDismissButton(location) {
    if (disabled || !visuallyHiddenDismiss || !modal) {
      return null;
    }
    return /* @__PURE__ */ React10.createElement(VisuallyHiddenDismiss, {
      ref: location === "start" ? startDismissButtonRef : endDismissButtonRef,
      onClick: (event) => onOpenChange(false, event.nativeEvent)
    }, typeof visuallyHiddenDismiss === "string" ? visuallyHiddenDismiss : "Dismiss");
  }
  const shouldRenderGuards = !disabled && guards && (isInsidePortal || modal);
  return /* @__PURE__ */ React10.createElement(React10.Fragment, null, shouldRenderGuards && /* @__PURE__ */ React10.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,
    onFocus: (event) => {
      if (modal) {
        const els = getTabbableElements();
        enqueueFocus(order3[0] === "reference" ? els[0] : els[els.length - 1]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        preventReturnFocusRef.current = false;
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const nextTabbable = getNextTabbable() || domReference;
          nextTabbable == null || nextTabbable.focus();
        } else {
          var _portalContext$before;
          (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();
        }
      }
    }
  }), !isUntrappedTypeableCombobox && renderDismissButton("start"), children, renderDismissButton("end"), shouldRenderGuards && /* @__PURE__ */ React10.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,
    onFocus: (event) => {
      if (modal) {
        enqueueFocus(getTabbableElements()[0]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        if (closeOnFocusOut) {
          preventReturnFocusRef.current = true;
        }
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const prevTabbable = getPreviousTabbable() || domReference;
          prevTabbable == null || prevTabbable.focus();
        } else {
          var _portalContext$afterO;
          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();
        }
      }
    }
  }));
}
function isButtonTarget(event) {
  return isHTMLElement(event.target) && event.target.tagName === "BUTTON";
}
function isSpaceIgnored(element) {
  return isTypeableElement(element);
}
function useClick(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    elements: {
      domReference
    }
  } = context;
  const {
    enabled = true,
    event: eventOption = "click",
    toggle = true,
    ignoreMouse = false,
    keyboardHandlers = true
  } = props;
  const pointerTypeRef = React10.useRef();
  const didKeyDownRef = React10.useRef(false);
  return React10.useMemo(() => {
    if (!enabled)
      return {};
    return {
      reference: {
        onPointerDown(event) {
          pointerTypeRef.current = event.pointerType;
        },
        onMouseDown(event) {
          if (event.button !== 0) {
            return;
          }
          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {
            return;
          }
          if (eventOption === "click") {
            return;
          }
          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "mousedown" : true)) {
            onOpenChange(false, event.nativeEvent, "click");
          } else {
            event.preventDefault();
            onOpenChange(true, event.nativeEvent, "click");
          }
        },
        onClick(event) {
          if (eventOption === "mousedown" && pointerTypeRef.current) {
            pointerTypeRef.current = void 0;
            return;
          }
          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {
            return;
          }
          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "click" : true)) {
            onOpenChange(false, event.nativeEvent, "click");
          } else {
            onOpenChange(true, event.nativeEvent, "click");
          }
        },
        onKeyDown(event) {
          pointerTypeRef.current = void 0;
          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {
            return;
          }
          if (event.key === " " && !isSpaceIgnored(domReference)) {
            event.preventDefault();
            didKeyDownRef.current = true;
          }
          if (event.key === "Enter") {
            if (open && toggle) {
              onOpenChange(false, event.nativeEvent, "click");
            } else {
              onOpenChange(true, event.nativeEvent, "click");
            }
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {
            return;
          }
          if (event.key === " " && didKeyDownRef.current) {
            didKeyDownRef.current = false;
            if (open && toggle) {
              onOpenChange(false, event.nativeEvent, "click");
            } else {
              onOpenChange(true, event.nativeEvent, "click");
            }
          }
        }
      }
    };
  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);
}
function createVirtualElement(domRef, data) {
  let offsetX = null;
  let offsetY = null;
  let isAutoUpdateEvent = false;
  return {
    contextElement: domRef.current || void 0,
    getBoundingClientRect() {
      var _domRef$current, _data$dataRef$current;
      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      };
      const isXAxis = data.axis === "x" || data.axis === "both";
      const isYAxis = data.axis === "y" || data.axis === "both";
      const canTrackCursorOnAutoUpdate = ["mouseenter", "mousemove"].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || "") && data.pointerType !== "touch";
      let width = domRect.width;
      let height = domRect.height;
      let x = domRect.x;
      let y = domRect.y;
      if (offsetX == null && data.x && isXAxis) {
        offsetX = domRect.x - data.x;
      }
      if (offsetY == null && data.y && isYAxis) {
        offsetY = domRect.y - data.y;
      }
      x -= offsetX || 0;
      y -= offsetY || 0;
      width = 0;
      height = 0;
      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {
        width = data.axis === "y" ? domRect.width : 0;
        height = data.axis === "x" ? domRect.height : 0;
        x = isXAxis && data.x != null ? data.x : x;
        y = isYAxis && data.y != null ? data.y : y;
      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {
        height = data.axis === "x" ? domRect.height : height;
        width = data.axis === "y" ? domRect.width : width;
      }
      isAutoUpdateEvent = true;
      return {
        width,
        height,
        x,
        y,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x
      };
    }
  };
}
function isMouseBasedEvent(event) {
  return event != null && event.clientX != null;
}
function useClientPoint(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    refs,
    dataRef,
    elements: {
      floating
    }
  } = context;
  const {
    enabled = true,
    axis = "both",
    x = null,
    y = null
  } = props;
  const initialRef = React10.useRef(false);
  const cleanupListenerRef = React10.useRef(null);
  const [pointerType, setPointerType] = React10.useState();
  const [reactive, setReactive] = React10.useState([]);
  const setReference = useEffectEvent((x2, y2) => {
    if (initialRef.current)
      return;
    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {
      return;
    }
    refs.setPositionReference(createVirtualElement(refs.domReference, {
      x: x2,
      y: y2,
      axis,
      dataRef,
      pointerType
    }));
  });
  const handleReferenceEnterOrMove = useEffectEvent((event) => {
    if (x != null || y != null)
      return;
    if (!open) {
      setReference(event.clientX, event.clientY);
    } else if (!cleanupListenerRef.current) {
      setReactive([]);
    }
  });
  const openCheck = isMouseLikePointerType(pointerType) ? floating : open;
  const addListener = React10.useCallback(() => {
    if (!openCheck || !enabled || x != null || y != null)
      return;
    const win = getWindow(refs.floating.current);
    function handleMouseMove(event) {
      const target = getTarget(event);
      if (!contains4(refs.floating.current, target)) {
        setReference(event.clientX, event.clientY);
      } else {
        win.removeEventListener("mousemove", handleMouseMove);
        cleanupListenerRef.current = null;
      }
    }
    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {
      win.addEventListener("mousemove", handleMouseMove);
      const cleanup = () => {
        win.removeEventListener("mousemove", handleMouseMove);
        cleanupListenerRef.current = null;
      };
      cleanupListenerRef.current = cleanup;
      return cleanup;
    }
    refs.setPositionReference(refs.domReference.current);
  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);
  React10.useEffect(() => {
    return addListener();
  }, [addListener, reactive]);
  React10.useEffect(() => {
    if (enabled && !floating) {
      initialRef.current = false;
    }
  }, [enabled, floating]);
  React10.useEffect(() => {
    if (!enabled && open) {
      initialRef.current = true;
    }
  }, [enabled, open]);
  index2(() => {
    if (enabled && (x != null || y != null)) {
      initialRef.current = false;
      setReference(x, y);
    }
  }, [enabled, x, y, setReference]);
  return React10.useMemo(() => {
    if (!enabled)
      return {};
    function setPointerTypeRef(_ref) {
      let {
        pointerType: pointerType2
      } = _ref;
      setPointerType(pointerType2);
    }
    return {
      reference: {
        onPointerDown: setPointerTypeRef,
        onPointerEnter: setPointerTypeRef,
        onMouseMove: handleReferenceEnterOrMove,
        onMouseEnter: handleReferenceEnterOrMove
      }
    };
  }, [enabled, handleReferenceEnterOrMove]);
}
function useDismiss(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    nodeId,
    elements: {
      reference: reference2,
      domReference,
      floating
    },
    dataRef
  } = context;
  const {
    enabled = true,
    escapeKey = true,
    outsidePress: unstable_outsidePress = true,
    outsidePressEvent = "pointerdown",
    referencePress = false,
    referencePressEvent = "pointerdown",
    ancestorScroll = false,
    bubbles,
    capture
  } = props;
  const tree = useFloatingTree();
  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
  const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
  const insideReactTreeRef = React10.useRef(false);
  const endedOrStartedInsideRef = React10.useRef(false);
  const {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles);
  const {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture);
  const closeOnEscapeKeyDown = useEffectEvent((event) => {
    if (!open || !enabled || !escapeKey || event.key !== "Escape") {
      return;
    }
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles) {
      event.stopPropagation();
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _child$context;
          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
    }
    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  });
  const closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event);
      (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  });
  const closeOnPressOutside = useEffectEvent((event) => {
    const insideReactTree = insideReactTreeRef.current;
    insideReactTreeRef.current = false;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    endedOrStartedInsideRef.current = false;
    if (outsidePressEvent === "click" && endedOrStartedInside) {
      return;
    }
    if (insideReactTree) {
      return;
    }
    if (typeof outsidePress === "function" && !outsidePress(event)) {
      return;
    }
    const target = getTarget(event);
    const inertSelector = "[" + createAttribute("inert") + "]";
    const markers = getDocument(floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {
        break;
      }
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains4(target, floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains4(targetRootAncestor, marker))) {
      return;
    }
    if (isHTMLElement(target) && floating) {
      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      let xCond = canScrollY && event.offsetX > target.clientWidth;
      if (canScrollY) {
        const isRTL = getComputedStyle2(target).direction === "rtl";
        if (isRTL) {
          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
        }
      }
      if (xCond || canScrollX && event.offsetY > target.clientHeight) {
        return;
      }
    }
    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node2) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node2.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {
      return;
    }
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = true;
      children.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = false;
          return;
        }
      });
      if (!shouldDismiss) {
        return;
      }
    }
    onOpenChange(false, event, "outside-press");
  });
  const closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event);
      (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React10.useEffect(() => {
    if (!open || !enabled) {
      return;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    function onScroll(event) {
      onOpenChange(false, event, "ancestor-scroll");
    }
    const doc = getDocument(floating);
    escapeKey && doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement(domReference)) {
        ancestors = getOverflowAncestors(domReference);
      }
      if (isElement(floating)) {
        ancestors = ancestors.concat(getOverflowAncestors(floating));
      }
      if (!isElement(reference2) && reference2 && reference2.contextElement) {
        ancestors = ancestors.concat(getOverflowAncestors(reference2.contextElement));
      }
    }
    ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    });
    ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    return () => {
      escapeKey && doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
      ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      });
    };
  }, [dataRef, floating, domReference, reference2, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
  React10.useEffect(() => {
    insideReactTreeRef.current = false;
  }, [outsidePress, outsidePressEvent]);
  return React10.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      reference: {
        onKeyDown: closeOnEscapeKeyDown,
        [bubbleHandlerKeys[referencePressEvent]]: (event) => {
          if (referencePress) {
            onOpenChange(false, event.nativeEvent, "reference-press");
          }
        }
      },
      floating: {
        onKeyDown: closeOnEscapeKeyDown,
        onMouseDown() {
          endedOrStartedInsideRef.current = true;
        },
        onMouseUp() {
          endedOrStartedInsideRef.current = true;
        },
        [captureHandlerKeys[outsidePressEvent]]: () => {
          insideReactTreeRef.current = true;
        }
      }
    };
  }, [enabled, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);
}
function useFloating2(options) {
  var _options$elements2;
  if (options === void 0) {
    options = {};
  }
  const {
    open = false,
    onOpenChange: unstable_onOpenChange,
    nodeId
  } = options;
  if (true) {
    var _options$elements;
    const err = "Floating UI: Cannot pass a virtual element to the `elements.reference` option, as it must be a real DOM element. Use `refs.setPositionReference` instead.";
    if ((_options$elements = options.elements) != null && _options$elements.reference && !isElement(options.elements.reference)) {
      var _devMessageSet;
      if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {
        var _devMessageSet2;
        (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(err);
        console.error(err);
      }
    }
  }
  const [_domReference, setDomReference] = React10.useState(null);
  const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;
  const position3 = useFloating(options);
  const tree = useFloatingTree();
  const nested = useFloatingParentNodeId() != null;
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    if (open2) {
      dataRef.current.openEvent = event;
    }
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    unstable_onOpenChange == null || unstable_onOpenChange(open2, event, reason);
  });
  const domReferenceRef = React10.useRef(null);
  const dataRef = React10.useRef({});
  const events = React10.useState(() => createPubSub())[0];
  const floatingId = useId6();
  const setPositionReference = React10.useCallback((node2) => {
    const positionReference = isElement(node2) ? {
      getBoundingClientRect: () => node2.getBoundingClientRect(),
      contextElement: node2
    } : node2;
    position3.refs.setReference(positionReference);
  }, [position3.refs]);
  const setReference = React10.useCallback((node2) => {
    if (isElement(node2) || node2 === null) {
      domReferenceRef.current = node2;
      setDomReference(node2);
    }
    if (isElement(position3.refs.reference.current) || position3.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node2 !== null && !isElement(node2)) {
      position3.refs.setReference(node2);
    }
  }, [position3.refs]);
  const refs = React10.useMemo(() => ({
    ...position3.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position3.refs, setReference, setPositionReference]);
  const elements = React10.useMemo(() => ({
    ...position3.elements,
    domReference
  }), [position3.elements, domReference]);
  const context = React10.useMemo(() => ({
    ...position3,
    refs,
    elements,
    dataRef,
    nodeId,
    floatingId,
    events,
    open,
    onOpenChange
  }), [position3, nodeId, floatingId, events, open, onOpenChange, refs, elements]);
  index2(() => {
    const node2 = tree == null ? void 0 : tree.nodesRef.current.find((node3) => node3.id === nodeId);
    if (node2) {
      node2.context = context;
    }
  });
  return React10.useMemo(() => ({
    ...position3,
    context,
    refs,
    elements
  }), [position3, refs, elements, context]);
}
function useFocus(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    events,
    refs,
    elements: {
      domReference
    }
  } = context;
  const {
    enabled = true,
    visibleOnly = true
  } = props;
  const blockFocusRef = React10.useRef(false);
  const timeoutRef = React10.useRef();
  const keyboardModalityRef = React10.useRef(true);
  React10.useEffect(() => {
    if (!enabled) {
      return;
    }
    const win = getWindow(domReference);
    function onBlur() {
      if (!open && isHTMLElement(domReference) && domReference === activeElement(getDocument(domReference))) {
        blockFocusRef.current = true;
      }
    }
    function onKeyDown() {
      keyboardModalityRef.current = true;
    }
    win.addEventListener("blur", onBlur);
    win.addEventListener("keydown", onKeyDown, true);
    return () => {
      win.removeEventListener("blur", onBlur);
      win.removeEventListener("keydown", onKeyDown, true);
    };
  }, [domReference, open, enabled]);
  React10.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onOpenChange2(_ref) {
      let {
        reason
      } = _ref;
      if (reason === "reference-press" || reason === "escape-key") {
        blockFocusRef.current = true;
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
    };
  }, [events, enabled]);
  React10.useEffect(() => {
    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, []);
  return React10.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      reference: {
        onPointerDown(event) {
          if (isVirtualPointerEvent(event.nativeEvent))
            return;
          keyboardModalityRef.current = false;
        },
        onMouseLeave() {
          blockFocusRef.current = false;
        },
        onFocus(event) {
          if (blockFocusRef.current)
            return;
          const target = getTarget(event.nativeEvent);
          if (visibleOnly && isElement(target)) {
            try {
              if (isSafari2() && isMac())
                throw Error();
              if (!target.matches(":focus-visible"))
                return;
            } catch (e) {
              if (!keyboardModalityRef.current && !isTypeableElement(target)) {
                return;
              }
            }
          }
          onOpenChange(true, event.nativeEvent, "focus");
        },
        onBlur(event) {
          blockFocusRef.current = false;
          const relatedTarget = event.relatedTarget;
          const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
          timeoutRef.current = window.setTimeout(() => {
            const activeEl = activeElement(domReference ? domReference.ownerDocument : document);
            if (!relatedTarget && activeEl === domReference)
              return;
            if (contains4(refs.floating.current, activeEl) || contains4(domReference, activeEl) || movedToFocusGuard) {
              return;
            }
            onOpenChange(false, event.nativeEvent, "focus");
          });
        }
      }
    };
  }, [enabled, visibleOnly, domReference, refs, onOpenChange]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn2) => fn2(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const deps = propsList;
  const getReferenceProps = React10.useCallback((userProps) => mergeProps(userProps, propsList, "reference"), deps);
  const getFloatingProps = React10.useCallback((userProps) => mergeProps(userProps, propsList, "floating"), deps);
  const getItemProps = React10.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    propsList.map((key) => key == null ? void 0 : key.item)
  );
  return React10.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function doSwitch(orientation, vertical, horizontal) {
  switch (orientation) {
    case "vertical":
      return vertical;
    case "horizontal":
      return horizontal;
    default:
      return vertical || horizontal;
  }
}
function isMainOrientationKey(key, orientation) {
  const vertical = key === ARROW_UP || key === ARROW_DOWN;
  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal);
}
function isMainOrientationToEndKey(key, orientation, rtl) {
  const vertical = key === ARROW_DOWN;
  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal) || key === "Enter" || key === " " || key === "";
}
function isCrossOrientationOpenKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  const horizontal = key === ARROW_DOWN;
  return doSwitch(orientation, vertical, horizontal);
}
function isCrossOrientationCloseKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;
  const horizontal = key === ARROW_UP;
  return doSwitch(orientation, vertical, horizontal);
}
function useListNavigation(context, props) {
  const {
    open,
    onOpenChange,
    refs,
    elements: {
      domReference,
      floating
    }
  } = context;
  const {
    listRef,
    activeIndex,
    onNavigate: unstable_onNavigate = () => {
    },
    enabled = true,
    selectedIndex = null,
    allowEscape = false,
    loop = false,
    nested = false,
    rtl = false,
    virtual = false,
    focusItemOnOpen = "auto",
    focusItemOnHover = true,
    openOnArrowKeyDown = true,
    disabledIndices = void 0,
    orientation = "vertical",
    cols = 1,
    scrollItemIntoView = true,
    virtualItemRef,
    itemSizes,
    dense = false
  } = props;
  if (true) {
    if (allowEscape) {
      if (!loop) {
        console.warn(["Floating UI: `useListNavigation` looping must be enabled to allow", "escaping."].join(" "));
      }
      if (!virtual) {
        console.warn(["Floating UI: `useListNavigation` must be virtual to allow", "escaping."].join(" "));
      }
    }
    if (orientation === "vertical" && cols > 1) {
      console.warn(["Floating UI: In grid list navigation mode (`cols` > 1), the", '`orientation` should be either "horizontal" or "both".'].join(" "));
    }
  }
  const parentId = useFloatingParentNodeId();
  const tree = useFloatingTree();
  const onNavigate = useEffectEvent(unstable_onNavigate);
  const focusItemOnOpenRef = React10.useRef(focusItemOnOpen);
  const indexRef = React10.useRef(selectedIndex != null ? selectedIndex : -1);
  const keyRef = React10.useRef(null);
  const isPointerModalityRef = React10.useRef(true);
  const previousOnNavigateRef = React10.useRef(onNavigate);
  const previousMountedRef = React10.useRef(!!floating);
  const forceSyncFocus = React10.useRef(false);
  const forceScrollIntoViewRef = React10.useRef(false);
  const disabledIndicesRef = useLatestRef(disabledIndices);
  const latestOpenRef = useLatestRef(open);
  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);
  const [activeId, setActiveId] = React10.useState();
  const [virtualId, setVirtualId] = React10.useState();
  const focusItem = useEffectEvent(function(listRef2, indexRef2, forceScrollIntoView) {
    if (forceScrollIntoView === void 0) {
      forceScrollIntoView = false;
    }
    const item2 = listRef2.current[indexRef2.current];
    if (!item2)
      return;
    if (virtual) {
      setActiveId(item2.id);
      tree == null || tree.events.emit("virtualfocus", item2);
      if (virtualItemRef) {
        virtualItemRef.current = item2;
      }
    } else {
      enqueueFocus(item2, {
        preventScroll: true,
        // Mac Safari does not move the virtual cursor unless the focus call
        // is sync. However, for the very first focus call, we need to wait
        // for the position to be ready in order to prevent unwanted
        // scrolling. This means the virtual cursor will not move to the first
        // item when first opening the floating element, but will on
        // subsequent calls. `preventScroll` is supported in modern Safari,
        // so we can use that instead.
        // iOS Safari must be async or the first item will not be focused.
        sync: isMac() && isSafari2() ? isPreventScrollSupported || forceSyncFocus.current : false
      });
    }
    requestAnimationFrame(() => {
      const scrollIntoViewOptions = scrollItemIntoViewRef.current;
      const shouldScrollIntoView = scrollIntoViewOptions && item2 && (forceScrollIntoView || !isPointerModalityRef.current);
      if (shouldScrollIntoView) {
        item2.scrollIntoView == null || item2.scrollIntoView(typeof scrollIntoViewOptions === "boolean" ? {
          block: "nearest",
          inline: "nearest"
        } : scrollIntoViewOptions);
      }
    });
  });
  index2(() => {
    document.createElement("div").focus({
      get preventScroll() {
        isPreventScrollSupported = true;
        return false;
      }
    });
  }, []);
  index2(() => {
    if (!enabled) {
      return;
    }
    if (open && floating) {
      if (focusItemOnOpenRef.current && selectedIndex != null) {
        forceScrollIntoViewRef.current = true;
        indexRef.current = selectedIndex;
        onNavigate(selectedIndex);
      }
    } else if (previousMountedRef.current) {
      indexRef.current = -1;
      previousOnNavigateRef.current(null);
    }
  }, [enabled, open, floating, selectedIndex, onNavigate]);
  index2(() => {
    if (!enabled) {
      return;
    }
    if (open && floating) {
      if (activeIndex == null) {
        forceSyncFocus.current = false;
        if (selectedIndex != null) {
          return;
        }
        if (previousMountedRef.current) {
          indexRef.current = -1;
          focusItem(listRef, indexRef);
        }
        if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {
          let runs = 0;
          const waitForListPopulated = () => {
            if (listRef.current[0] == null) {
              if (runs < 2) {
                const scheduler = runs ? requestAnimationFrame : queueMicrotask;
                scheduler(waitForListPopulated);
              }
              runs++;
            } else {
              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);
              keyRef.current = null;
              onNavigate(indexRef.current);
            }
          };
          waitForListPopulated();
        }
      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {
        indexRef.current = activeIndex;
        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);
        forceScrollIntoViewRef.current = false;
      }
    }
  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
  index2(() => {
    var _nodes$find;
    if (!enabled || floating || !tree || virtual || !previousMountedRef.current) {
      return;
    }
    const nodes = tree.nodesRef.current;
    const parent = (_nodes$find = nodes.find((node2) => node2.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;
    const activeEl = activeElement(getDocument(floating));
    const treeContainsActiveEl = nodes.some((node2) => node2.context && contains4(node2.context.elements.floating, activeEl));
    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {
      parent.focus({
        preventScroll: true
      });
    }
  }, [enabled, floating, tree, parentId, virtual]);
  index2(() => {
    if (!enabled || !tree || !virtual || parentId)
      return;
    function handleVirtualFocus(item2) {
      setVirtualId(item2.id);
      if (virtualItemRef) {
        virtualItemRef.current = item2;
      }
    }
    tree.events.on("virtualfocus", handleVirtualFocus);
    return () => {
      tree.events.off("virtualfocus", handleVirtualFocus);
    };
  }, [enabled, tree, virtual, parentId, virtualItemRef]);
  index2(() => {
    previousOnNavigateRef.current = onNavigate;
    previousMountedRef.current = !!floating;
  });
  index2(() => {
    if (!open) {
      keyRef.current = null;
    }
  }, [open]);
  const hasActiveIndex = activeIndex != null;
  const item = React10.useMemo(() => {
    function syncCurrentTarget(currentTarget) {
      if (!open)
        return;
      const index3 = listRef.current.indexOf(currentTarget);
      if (index3 !== -1) {
        onNavigate(index3);
      }
    }
    const props2 = {
      onFocus(_ref) {
        let {
          currentTarget
        } = _ref;
        syncCurrentTarget(currentTarget);
      },
      onClick: (_ref2) => {
        let {
          currentTarget
        } = _ref2;
        return currentTarget.focus({
          preventScroll: true
        });
      },
      // Safari
      ...focusItemOnHover && {
        onMouseMove(_ref3) {
          let {
            currentTarget
          } = _ref3;
          syncCurrentTarget(currentTarget);
        },
        onPointerLeave(_ref4) {
          let {
            pointerType
          } = _ref4;
          if (!isPointerModalityRef.current || pointerType === "touch") {
            return;
          }
          indexRef.current = -1;
          focusItem(listRef, indexRef);
          onNavigate(null);
          if (!virtual) {
            enqueueFocus(refs.floating.current, {
              preventScroll: true
            });
          }
        }
      }
    };
    return props2;
  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);
  return React10.useMemo(() => {
    if (!enabled) {
      return {};
    }
    const disabledIndices2 = disabledIndicesRef.current;
    function onKeyDown(event) {
      isPointerModalityRef.current = false;
      forceSyncFocus.current = true;
      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {
        return;
      }
      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {
        stopEvent(event);
        onOpenChange(false, event.nativeEvent, "list-navigation");
        if (isHTMLElement(domReference) && !virtual) {
          domReference.focus();
        }
        return;
      }
      const currentIndex = indexRef.current;
      const minIndex = getMinIndex(listRef, disabledIndices2);
      const maxIndex = getMaxIndex(listRef, disabledIndices2);
      if (event.key === "Home") {
        stopEvent(event);
        indexRef.current = minIndex;
        onNavigate(indexRef.current);
      }
      if (event.key === "End") {
        stopEvent(event);
        indexRef.current = maxIndex;
        onNavigate(indexRef.current);
      }
      if (cols > 1) {
        const sizes24 = itemSizes || Array.from({
          length: listRef.current.length
        }, () => ({
          width: 1,
          height: 1
        }));
        const cellMap = buildCellMap(sizes24, cols, dense);
        const minGridIndex = cellMap.findIndex((index3) => index3 != null && !(disabledIndices2 != null && disabledIndices2.includes(index3)));
        const maxGridIndex = cellMap.reduce((foundIndex, index3, cellIndex) => index3 != null && !(disabledIndices2 != null && disabledIndices2.includes(index3)) ? cellIndex : foundIndex, -1);
        indexRef.current = cellMap[getGridNavigatedIndex({
          current: cellMap.map((itemIndex) => itemIndex != null ? listRef.current[itemIndex] : null)
        }, {
          event,
          orientation,
          loop,
          cols,
          // treat undefined (empty grid spaces) as disabled indices so we
          // don't end up in them
          disabledIndices: getCellIndices([...disabledIndices2 || [], void 0], cellMap),
          minIndex: minGridIndex,
          maxIndex: maxGridIndex,
          prevIndex: getCellIndexOfCorner(
            indexRef.current,
            sizes24,
            cellMap,
            cols,
            // use a corner matching the edge closest to the direction
            // we're moving in so we don't end up in the same item. Prefer
            // top/left over bottom/right.
            event.key === ARROW_DOWN ? "bl" : event.key === ARROW_RIGHT ? "tr" : "tl"
          ),
          stopEvent: true
        })];
        onNavigate(indexRef.current);
        if (orientation === "both") {
          return;
        }
      }
      if (isMainOrientationKey(event.key, orientation)) {
        stopEvent(event);
        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {
          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;
          onNavigate(indexRef.current);
          return;
        }
        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
          if (loop) {
            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices: disabledIndices2
            });
          } else {
            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices: disabledIndices2
            }));
          }
        } else {
          if (loop) {
            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              decrement: true,
              disabledIndices: disabledIndices2
            });
          } else {
            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              decrement: true,
              disabledIndices: disabledIndices2
            }));
          }
        }
        if (isIndexOutOfBounds(listRef, indexRef.current)) {
          onNavigate(null);
        } else {
          onNavigate(indexRef.current);
        }
      }
    }
    function checkVirtualMouse(event) {
      if (focusItemOnOpen === "auto" && isVirtualClick(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    function checkVirtualPointer(event) {
      focusItemOnOpenRef.current = focusItemOnOpen;
      if (focusItemOnOpen === "auto" && isVirtualPointerEvent(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {
      "aria-activedescendant": virtualId || activeId
    };
    const activeItem = listRef.current.find((item2) => (item2 == null ? void 0 : item2.id) === activeId);
    return {
      reference: {
        ...ariaActiveDescendantProp,
        onKeyDown(event) {
          isPointerModalityRef.current = false;
          const isArrowKey = event.key.indexOf("Arrow") === 0;
          const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);
          const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);
          const isMainKey = isMainOrientationKey(event.key, orientation);
          const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === "Enter" || event.key.trim() === "";
          if (virtual && open) {
            const rootNode = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.parentId == null);
            const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;
            if (isArrowKey && deepestNode && virtualItemRef) {
              const eventObject = new KeyboardEvent("keydown", {
                key: event.key,
                bubbles: true
              });
              if (isCrossOpenKey || isCrossCloseKey) {
                var _deepestNode$context, _deepestNode$context2;
                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;
                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? activeItem : null;
                if (dispatchItem) {
                  stopEvent(event);
                  dispatchItem.dispatchEvent(eventObject);
                  setVirtualId(void 0);
                }
              }
              if (isMainKey && deepestNode.context) {
                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {
                  var _deepestNode$context$;
                  stopEvent(event);
                  (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);
                  return;
                }
              }
            }
            return onKeyDown(event);
          }
          if (!open && !openOnArrowKeyDown && isArrowKey) {
            return;
          }
          if (isNavigationKey) {
            keyRef.current = nested && isMainKey ? null : event.key;
          }
          if (nested) {
            if (isCrossOpenKey) {
              stopEvent(event);
              if (open) {
                indexRef.current = getMinIndex(listRef, disabledIndices2);
                onNavigate(indexRef.current);
              } else {
                onOpenChange(true, event.nativeEvent, "list-navigation");
              }
            }
            return;
          }
          if (isMainKey) {
            if (selectedIndex != null) {
              indexRef.current = selectedIndex;
            }
            stopEvent(event);
            if (!open && openOnArrowKeyDown) {
              onOpenChange(true, event.nativeEvent, "list-navigation");
            } else {
              onKeyDown(event);
            }
            if (open) {
              onNavigate(indexRef.current);
            }
          }
        },
        onFocus() {
          if (open) {
            onNavigate(null);
          }
        },
        onPointerDown: checkVirtualPointer,
        onMouseDown: checkVirtualMouse,
        onClick: checkVirtualMouse
      },
      floating: {
        "aria-orientation": orientation === "both" ? void 0 : orientation,
        ...!isTypeableCombobox(domReference) && ariaActiveDescendantProp,
        onKeyDown,
        onPointerMove() {
          isPointerModalityRef.current = true;
        }
      },
      item
    };
  }, [domReference, refs, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);
}
function useRole(context, props) {
  var _componentRoleToAriaR;
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    floatingId
  } = context;
  const {
    enabled = true,
    role = "dialog"
  } = props;
  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;
  const referenceId = useId6();
  const parentId = useFloatingParentNodeId();
  const isNested = parentId != null;
  return React10.useMemo(() => {
    if (!enabled)
      return {};
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    if (ariaRole === "tooltip" || role === "label") {
      return {
        reference: {
          ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
        },
        floating: floatingProps
      };
    }
    return {
      reference: {
        "aria-expanded": open ? "true" : "false",
        "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
        "aria-controls": open ? floatingId : void 0,
        ...ariaRole === "listbox" && {
          role: "combobox"
        },
        ...ariaRole === "menu" && {
          id: referenceId
        },
        ...ariaRole === "menu" && isNested && {
          role: "menuitem"
        },
        ...role === "select" && {
          "aria-autocomplete": "none"
        },
        ...role === "combobox" && {
          "aria-autocomplete": "list"
        }
      },
      floating: {
        ...floatingProps,
        ...ariaRole === "menu" && {
          "aria-labelledby": referenceId
        }
      },
      item(_ref) {
        let {
          active,
          selected
        } = _ref;
        const commonProps = {
          role: "option",
          ...active && {
            id: floatingId + "-option"
          }
        };
        switch (role) {
          case "select":
            return {
              ...commonProps,
              "aria-selected": active && selected
            };
          case "combobox": {
            return {
              ...commonProps,
              ...active && {
                "aria-selected": true
              }
            };
          }
        }
        return {};
      }
    };
  }, [enabled, role, ariaRole, open, floatingId, referenceId, isNested]);
}
function execWithArgsOrReturn(valueOrFn, args) {
  return typeof valueOrFn === "function" ? valueOrFn(args) : valueOrFn;
}
function useDelayUnmount(open, durationMs) {
  const [isMounted, setIsMounted] = React10.useState(open);
  if (open && !isMounted) {
    setIsMounted(true);
  }
  React10.useEffect(() => {
    if (!open) {
      const timeout = setTimeout(() => setIsMounted(false), durationMs);
      return () => clearTimeout(timeout);
    }
  }, [open, durationMs]);
  return isMounted;
}
function useTransitionStatus(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    elements: {
      floating
    }
  } = context;
  const {
    duration = 250
  } = props;
  const isNumberDuration = typeof duration === "number";
  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
  const [initiated, setInitiated] = React10.useState(false);
  const [status, setStatus] = React10.useState("unmounted");
  const isMounted = useDelayUnmount(open, closeDuration);
  index2(() => {
    if (initiated && !isMounted) {
      setStatus("unmounted");
    }
  }, [initiated, isMounted]);
  index2(() => {
    if (!floating)
      return;
    if (open) {
      setStatus("initial");
      const frame3 = requestAnimationFrame(() => {
        setStatus("open");
      });
      return () => {
        cancelAnimationFrame(frame3);
      };
    }
    setInitiated(true);
    setStatus("close");
  }, [open, floating]);
  return {
    isMounted,
    status
  };
}
function useTransitionStyles(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    initial: unstable_initial = {
      opacity: 0
    },
    open: unstable_open,
    close: unstable_close,
    common: unstable_common,
    duration = 250
  } = props;
  const placement = context.placement;
  const side = placement.split("-")[0];
  const fnArgs = React10.useMemo(() => ({
    side,
    placement
  }), [side, placement]);
  const isNumberDuration = typeof duration === "number";
  const openDuration = (isNumberDuration ? duration : duration.open) || 0;
  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
  const [styles3, setStyles] = React10.useState(() => ({
    ...execWithArgsOrReturn(unstable_common, fnArgs),
    ...execWithArgsOrReturn(unstable_initial, fnArgs)
  }));
  const {
    isMounted,
    status
  } = useTransitionStatus(context, {
    duration
  });
  const initialRef = useLatestRef(unstable_initial);
  const openRef = useLatestRef(unstable_open);
  const closeRef = useLatestRef(unstable_close);
  const commonRef = useLatestRef(unstable_common);
  index2(() => {
    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);
    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);
    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);
    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {
      acc[key] = "";
      return acc;
    }, {});
    if (status === "initial") {
      setStyles((styles4) => ({
        transitionProperty: styles4.transitionProperty,
        ...commonStyles,
        ...initialStyles
      }));
    }
    if (status === "open") {
      setStyles({
        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(","),
        transitionDuration: openDuration + "ms",
        ...commonStyles,
        ...openStyles
      });
    }
    if (status === "close") {
      const styles4 = closeStyles || initialStyles;
      setStyles({
        transitionProperty: Object.keys(styles4).map(camelCaseToKebabCase).join(","),
        transitionDuration: closeDuration + "ms",
        ...commonStyles,
        ...styles4
      });
    }
  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);
  return {
    isMounted,
    styles: styles3
  };
}
function useTypeahead(context, props) {
  var _ref;
  const {
    open,
    dataRef
  } = context;
  const {
    listRef,
    activeIndex,
    onMatch: unstable_onMatch,
    onTypingChange: unstable_onTypingChange,
    enabled = true,
    findMatch = null,
    resetMs = 750,
    ignoreKeys = [],
    selectedIndex = null
  } = props;
  const timeoutIdRef = React10.useRef();
  const stringRef = React10.useRef("");
  const prevIndexRef = React10.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);
  const matchIndexRef = React10.useRef(null);
  const onMatch = useEffectEvent(unstable_onMatch);
  const onTypingChange = useEffectEvent(unstable_onTypingChange);
  const findMatchRef = useLatestRef(findMatch);
  const ignoreKeysRef = useLatestRef(ignoreKeys);
  index2(() => {
    if (open) {
      clearTimeout(timeoutIdRef.current);
      matchIndexRef.current = null;
      stringRef.current = "";
    }
  }, [open]);
  index2(() => {
    if (open && stringRef.current === "") {
      var _ref2;
      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;
    }
  }, [open, selectedIndex, activeIndex]);
  return React10.useMemo(() => {
    if (!enabled) {
      return {};
    }
    function setTypingChange(value) {
      if (value) {
        if (!dataRef.current.typing) {
          dataRef.current.typing = value;
          onTypingChange(value);
        }
      } else {
        if (dataRef.current.typing) {
          dataRef.current.typing = value;
          onTypingChange(value);
        }
      }
    }
    function getMatchingIndex(list2, orderedList, string) {
      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text) => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);
      return str ? list2.indexOf(str) : -1;
    }
    function onKeyDown(event) {
      const listContent = listRef.current;
      if (stringRef.current.length > 0 && stringRef.current[0] !== " ") {
        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {
          setTypingChange(false);
        } else if (event.key === " ") {
          stopEvent(event);
        }
      }
      if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.
      event.key.length !== 1 || // Modifier key.
      event.ctrlKey || event.metaKey || event.altKey) {
        return;
      }
      if (open && event.key !== " ") {
        stopEvent(event);
        setTypingChange(true);
      }
      const allowRapidSuccessionOfFirstLetter = listContent.every((text) => {
        var _text$, _text$2;
        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;
      });
      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {
        stringRef.current = "";
        prevIndexRef.current = matchIndexRef.current;
      }
      stringRef.current += event.key;
      clearTimeout(timeoutIdRef.current);
      timeoutIdRef.current = setTimeout(() => {
        stringRef.current = "";
        prevIndexRef.current = matchIndexRef.current;
        setTypingChange(false);
      }, resetMs);
      const prevIndex = prevIndexRef.current;
      const index3 = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);
      if (index3 !== -1) {
        onMatch(index3);
        matchIndexRef.current = index3;
      } else if (event.key !== " ") {
        stringRef.current = "";
        setTypingChange(false);
      }
    }
    return {
      reference: {
        onKeyDown
      },
      floating: {
        onKeyDown,
        onKeyUp(event) {
          if (event.key === " ") {
            setTypingChange(false);
          }
        }
      }
    };
  }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);
}
function getArgsWithCustomFloatingHeight(state2, height) {
  return {
    ...state2,
    rects: {
      ...state2.rects,
      floating: {
        ...state2.rects.floating,
        height
      }
    }
  };
}
function useInnerOffset(context, props) {
  const {
    open,
    elements
  } = context;
  const {
    enabled = true,
    overflowRef,
    scrollRef,
    onChange: unstable_onChange
  } = props;
  const onChange = useEffectEvent(unstable_onChange);
  const controlledScrollingRef = React10.useRef(false);
  const prevScrollTopRef = React10.useRef(null);
  const initialOverflowRef = React10.useRef(null);
  React10.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onWheel(e) {
      if (e.ctrlKey || !el || overflowRef.current == null) {
        return;
      }
      const dY = e.deltaY;
      const isAtTop = overflowRef.current.top >= -0.5;
      const isAtBottom = overflowRef.current.bottom >= -0.5;
      const remainingScroll = el.scrollHeight - el.clientHeight;
      const sign = dY < 0 ? -1 : 1;
      const method = dY < 0 ? "max" : "min";
      if (el.scrollHeight <= el.clientHeight) {
        return;
      }
      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
        e.preventDefault();
        (0, import_react_dom5.flushSync)(() => {
          onChange((d) => d + Math[method](dY, remainingScroll * sign));
        });
      } else if (/firefox/i.test(getUserAgent())) {
        el.scrollTop += dY;
      }
    }
    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
    if (open && el) {
      el.addEventListener("wheel", onWheel);
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
        if (overflowRef.current != null) {
          initialOverflowRef.current = {
            ...overflowRef.current
          };
        }
      });
      return () => {
        prevScrollTopRef.current = null;
        initialOverflowRef.current = null;
        el.removeEventListener("wheel", onWheel);
      };
    }
  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);
  return React10.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      floating: {
        onKeyDown() {
          controlledScrollingRef.current = true;
        },
        onWheel() {
          controlledScrollingRef.current = false;
        },
        onPointerMove() {
          controlledScrollingRef.current = false;
        },
        onScroll() {
          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
          if (!overflowRef.current || !el || !controlledScrollingRef.current) {
            return;
          }
          if (prevScrollTopRef.current !== null) {
            const scrollDiff = el.scrollTop - prevScrollTopRef.current;
            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {
              (0, import_react_dom5.flushSync)(() => onChange((d) => d + scrollDiff));
            }
          }
          requestAnimationFrame(() => {
            prevScrollTopRef.current = el.scrollTop;
          });
        }
      }
    };
  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);
}
function isPointInPolygon(point, polygon) {
  const [x, y] = point;
  let isInside2 = false;
  const length2 = polygon.length;
  for (let i = 0, j = length2 - 1; i < length2; j = i++) {
    const [xi, yi] = polygon[i] || [0, 0];
    const [xj, yj] = polygon[j] || [0, 0];
    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) {
      isInside2 = !isInside2;
    }
  }
  return isInside2;
}
function isInside(point, rect) {
  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;
}
function safePolygon(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    buffer = 0.5,
    blockPointerEvents = false,
    requireIntent = true
  } = options;
  let timeoutId2;
  let hasLanded = false;
  let lastX = null;
  let lastY = null;
  let lastCursorTime = performance.now();
  function getCursorSpeed(x, y) {
    const currentTime = performance.now();
    const elapsedTime = currentTime - lastCursorTime;
    if (lastX === null || lastY === null || elapsedTime === 0) {
      lastX = x;
      lastY = y;
      lastCursorTime = currentTime;
      return null;
    }
    const deltaX = x - lastX;
    const deltaY = y - lastY;
    const distance3 = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const speed = distance3 / elapsedTime;
    lastX = x;
    lastY = y;
    lastCursorTime = currentTime;
    return speed;
  }
  const fn2 = (_ref) => {
    let {
      x,
      y,
      placement,
      elements,
      onClose,
      nodeId,
      tree
    } = _ref;
    return function onMouseMove(event) {
      function close() {
        clearTimeout(timeoutId2);
        onClose();
      }
      clearTimeout(timeoutId2);
      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {
        return;
      }
      const {
        clientX,
        clientY
      } = event;
      const clientPoint = [clientX, clientY];
      const target = getTarget(event);
      const isLeave = event.type === "mouseleave";
      const isOverFloatingEl = contains4(elements.floating, target);
      const isOverReferenceEl = contains4(elements.domReference, target);
      const refRect = elements.domReference.getBoundingClientRect();
      const rect = elements.floating.getBoundingClientRect();
      const side = placement.split("-")[0];
      const cursorLeaveFromRight = x > rect.right - rect.width / 2;
      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;
      const isOverReferenceRect = isInside(clientPoint, refRect);
      const isFloatingWider = rect.width > refRect.width;
      const isFloatingTaller = rect.height > refRect.height;
      const left2 = (isFloatingWider ? refRect : rect).left;
      const right2 = (isFloatingWider ? refRect : rect).right;
      const top2 = (isFloatingTaller ? refRect : rect).top;
      const bottom2 = (isFloatingTaller ? refRect : rect).bottom;
      if (isOverFloatingEl) {
        hasLanded = true;
        if (!isLeave) {
          return;
        }
      }
      if (isOverReferenceEl) {
        hasLanded = false;
      }
      if (isOverReferenceEl && !isLeave) {
        hasLanded = true;
        return;
      }
      if (isLeave && isElement(event.relatedTarget) && contains4(elements.floating, event.relatedTarget)) {
        return;
      }
      if (tree && getChildren(tree.nodesRef.current, nodeId).some((_ref2) => {
        let {
          context
        } = _ref2;
        return context == null ? void 0 : context.open;
      })) {
        return;
      }
      if (side === "top" && y >= refRect.bottom - 1 || side === "bottom" && y <= refRect.top + 1 || side === "left" && x >= refRect.right - 1 || side === "right" && x <= refRect.left + 1) {
        return close();
      }
      let rectPoly = [];
      switch (side) {
        case "top":
          rectPoly = [[left2, refRect.top + 1], [left2, rect.bottom - 1], [right2, rect.bottom - 1], [right2, refRect.top + 1]];
          break;
        case "bottom":
          rectPoly = [[left2, rect.top + 1], [left2, refRect.bottom - 1], [right2, refRect.bottom - 1], [right2, rect.top + 1]];
          break;
        case "left":
          rectPoly = [[rect.right - 1, bottom2], [rect.right - 1, top2], [refRect.left + 1, top2], [refRect.left + 1, bottom2]];
          break;
        case "right":
          rectPoly = [[refRect.right - 1, bottom2], [refRect.right - 1, top2], [rect.left + 1, top2], [rect.left + 1, bottom2]];
          break;
      }
      function getPolygon(_ref3) {
        let [x2, y2] = _ref3;
        switch (side) {
          case "top": {
            const cursorPointOne = [isFloatingWider ? x2 + buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 + buffer + 1];
            const cursorPointTwo = [isFloatingWider ? x2 - buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 + buffer + 1];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "bottom": {
            const cursorPointOne = [isFloatingWider ? x2 + buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 - buffer];
            const cursorPointTwo = [isFloatingWider ? x2 - buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 - buffer];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "left": {
            const cursorPointOne = [x2 + buffer + 1, isFloatingTaller ? y2 + buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const cursorPointTwo = [x2 + buffer + 1, isFloatingTaller ? y2 - buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];
            return [...commonPoints, cursorPointOne, cursorPointTwo];
          }
          case "right": {
            const cursorPointOne = [x2 - buffer, isFloatingTaller ? y2 + buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const cursorPointTwo = [x2 - buffer, isFloatingTaller ? y2 - buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
        }
      }
      if (isPointInPolygon([clientX, clientY], rectPoly)) {
        return;
      }
      if (hasLanded && !isOverReferenceRect) {
        return close();
      }
      if (!isLeave && requireIntent) {
        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);
        const cursorSpeedThreshold = 0.1;
        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {
          return close();
        }
      }
      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {
        close();
      } else if (!hasLanded && requireIntent) {
        timeoutId2 = window.setTimeout(close, 40);
      }
    };
  };
  fn2.__options = {
    blockPointerEvents
  };
  return fn2;
}
var React10, import_react89, import_react_dom5, useInsertionEffect3, useSafeInsertionEffect, ARROW_UP, ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, rafId, index2, FloatingListContext, CompositeContext, horizontalKeys, verticalKeys, allKeys, Composite, CompositeItem, serverHandoffComplete, count, genId, useReactId, useId6, FloatingArrow, FloatingNodeContext, FloatingTreeContext, useFloatingParentNodeId, useFloatingTree, safePolygonIdentifier, FloatingDelayGroupContext, useDelayGroupContext, FloatingDelayGroup, useDelayGroup, counterMap, uncontrolledElementsSet, markerMap, lockCount, supportsInert, unwrapHost, correctElements, getTabbableOptions, HIDDEN_STYLES, timeoutId, FocusGuard, PortalContext, attr, usePortalContext2, LIST_LIMIT, previouslyFocusedElements, VisuallyHiddenDismiss, activeLocks, FloatingOverlay, bubbleHandlerKeys, captureHandlerKeys, normalizeProp, devMessageSet, ACTIVE_KEY, SELECTED_KEY, isPreventScrollSupported, componentRoleToAriaRoleMap, camelCaseToKebabCase, inner;
var init_floating_ui_react_esm = __esm({
  "node_modules/@floating-ui/react/dist/floating-ui.react.esm.js"() {
    React10 = __toESM(require_react());
    import_react89 = __toESM(require_react());
    init_floating_ui_react_utils();
    init_floating_ui_utils();
    init_floating_ui_react_dom();
    init_floating_ui_react_dom();
    init_floating_ui_utils_dom();
    init_index_esm();
    import_react_dom5 = __toESM(require_react_dom());
    useInsertionEffect3 = React10[/* @__PURE__ */ "useInsertionEffect".toString()];
    useSafeInsertionEffect = useInsertionEffect3 || ((fn2) => fn2());
    ARROW_UP = "ArrowUp";
    ARROW_DOWN = "ArrowDown";
    ARROW_LEFT = "ArrowLeft";
    ARROW_RIGHT = "ArrowRight";
    rafId = 0;
    index2 = typeof document !== "undefined" ? import_react89.useLayoutEffect : import_react89.useEffect;
    FloatingListContext = /* @__PURE__ */ React10.createContext({
      register: () => {
      },
      unregister: () => {
      },
      map: /* @__PURE__ */ new Map(),
      elementsRef: {
        current: []
      }
    });
    CompositeContext = /* @__PURE__ */ React10.createContext({
      activeIndex: 0,
      onNavigate: () => {
      }
    });
    horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
    verticalKeys = [ARROW_UP, ARROW_DOWN];
    allKeys = [...horizontalKeys, ...verticalKeys];
    Composite = /* @__PURE__ */ React10.forwardRef(function Composite2(_ref, forwardedRef) {
      let {
        render,
        orientation = "both",
        loop = true,
        cols = 1,
        disabledIndices = [],
        activeIndex: externalActiveIndex,
        onNavigate: externalSetActiveIndex,
        itemSizes,
        dense = false,
        ...props
      } = _ref;
      const [internalActiveIndex, internalSetActiveIndex] = React10.useState(0);
      const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
      const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
      const elementsRef = React10.useRef([]);
      const renderElementProps = render && typeof render !== "function" ? render.props : {};
      const contextValue = React10.useMemo(() => ({
        activeIndex,
        onNavigate
      }), [activeIndex, onNavigate]);
      const isGrid = cols > 1;
      function handleKeyDown(event) {
        if (!allKeys.includes(event.key))
          return;
        let nextIndex = activeIndex;
        if (isGrid) {
          const sizes24 = itemSizes || Array.from({
            length: elementsRef.current.length
          }, () => ({
            width: 1,
            height: 1
          }));
          const cellMap = buildCellMap(sizes24, cols, dense);
          const minGridIndex = cellMap.findIndex((index3) => index3 != null && !disabledIndices.includes(index3));
          const maxGridIndex = cellMap.reduce((foundIndex, index3, cellIndex) => index3 != null && !(disabledIndices != null && disabledIndices.includes(index3)) ? cellIndex : foundIndex, -1);
          nextIndex = cellMap[getGridNavigatedIndex({
            current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
          }, {
            event,
            orientation,
            loop,
            cols,
            // treat undefined (empty grid spaces) as disabled indices so we
            // don't end up in them
            disabledIndices: getCellIndices([...disabledIndices, void 0], cellMap),
            minIndex: minGridIndex,
            maxIndex: maxGridIndex,
            prevIndex: getCellIndexOfCorner(
              activeIndex,
              sizes24,
              cellMap,
              cols,
              // use a corner matching the edge closest to the direction we're
              // moving in so we don't end up in the same item. Prefer
              // top/left over bottom/right.
              event.key === ARROW_DOWN ? "bl" : event.key === ARROW_RIGHT ? "tr" : "tl"
            )
          })];
        }
        const minIndex = getMinIndex(elementsRef, disabledIndices);
        const maxIndex = getMaxIndex(elementsRef, disabledIndices);
        const toEndKeys = {
          horizontal: [ARROW_RIGHT],
          vertical: [ARROW_DOWN],
          both: [ARROW_RIGHT, ARROW_DOWN]
        }[orientation];
        const toStartKeys = {
          horizontal: [ARROW_LEFT],
          vertical: [ARROW_UP],
          both: [ARROW_LEFT, ARROW_UP]
        }[orientation];
        const preventedKeys = isGrid ? allKeys : {
          horizontal: horizontalKeys,
          vertical: verticalKeys,
          both: allKeys
        }[orientation];
        if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
          if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
            nextIndex = minIndex;
          } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
            nextIndex = maxIndex;
          } else {
            nextIndex = findNonDisabledIndex(elementsRef, {
              startingIndex: nextIndex,
              decrement: toStartKeys.includes(event.key),
              disabledIndices
            });
          }
        }
        if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {
          event.stopPropagation();
          if (preventedKeys.includes(event.key)) {
            event.preventDefault();
          }
          onNavigate(nextIndex);
          queueMicrotask(() => {
            enqueueFocus(elementsRef.current[nextIndex]);
          });
        }
      }
      const computedProps = {
        ...props,
        ...renderElementProps,
        ref: forwardedRef,
        "aria-orientation": orientation === "both" ? void 0 : orientation,
        onKeyDown(e) {
          props.onKeyDown == null || props.onKeyDown(e);
          renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);
          handleKeyDown(e);
        }
      };
      return /* @__PURE__ */ React10.createElement(CompositeContext.Provider, {
        value: contextValue
      }, /* @__PURE__ */ React10.createElement(FloatingList, {
        elementsRef
      }, renderJsx(render, computedProps)));
    });
    CompositeItem = /* @__PURE__ */ React10.forwardRef(function CompositeItem2(_ref2, forwardedRef) {
      let {
        render,
        ...props
      } = _ref2;
      const renderElementProps = render && typeof render !== "function" ? render.props : {};
      const {
        activeIndex,
        onNavigate
      } = React10.useContext(CompositeContext);
      const {
        ref,
        index: index3
      } = useListItem();
      const mergedRef = useMergeRefs2([ref, forwardedRef, renderElementProps.ref]);
      const isActive = activeIndex === index3;
      const computedProps = {
        ...props,
        ...renderElementProps,
        ref: mergedRef,
        tabIndex: isActive ? 0 : -1,
        "data-active": isActive ? "" : void 0,
        onFocus(e) {
          props.onFocus == null || props.onFocus(e);
          renderElementProps.onFocus == null || renderElementProps.onFocus(e);
          onNavigate(index3);
        }
      };
      return renderJsx(render, computedProps);
    });
    serverHandoffComplete = false;
    count = 0;
    genId = () => "floating-ui-" + count++;
    useReactId = React10[/* @__PURE__ */ "useId".toString()];
    useId6 = useReactId || useFloatingId;
    FloatingArrow = /* @__PURE__ */ React10.forwardRef(function FloatingArrow2(_ref, ref) {
      let {
        context: {
          placement,
          elements: {
            floating
          },
          middlewareData: {
            arrow: arrow3
          }
        },
        width = 14,
        height = 7,
        tipRadius = 0,
        strokeWidth = 0,
        staticOffset,
        stroke,
        d,
        style: {
          transform: transform2,
          ...restStyle
        } = {},
        ...rest
      } = _ref;
      if (true) {
        if (!ref) {
          console.warn("Floating UI: The `ref` prop is required for the `FloatingArrow`", "component.");
        }
      }
      const clipPathId = useId6();
      if (!floating) {
        return null;
      }
      strokeWidth *= 2;
      const halfStrokeWidth = strokeWidth / 2;
      const svgX = width / 2 * (tipRadius / -8 + 1);
      const svgY = height / 2 * tipRadius / 4;
      const [side, alignment] = placement.split("-");
      const isRTL = platform.isRTL(floating);
      const isCustomShape = !!d;
      const isVerticalSide = side === "top" || side === "bottom";
      const yOffsetProp = staticOffset && alignment === "end" ? "bottom" : "top";
      let xOffsetProp = staticOffset && alignment === "end" ? "right" : "left";
      if (staticOffset && isRTL) {
        xOffsetProp = alignment === "end" ? "left" : "right";
      }
      const arrowX = (arrow3 == null ? void 0 : arrow3.x) != null ? staticOffset || arrow3.x : "";
      const arrowY = (arrow3 == null ? void 0 : arrow3.y) != null ? staticOffset || arrow3.y : "";
      const dValue = d || // biome-ignore lint/style/useTemplate: readability
      "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
      const rotation = {
        top: isCustomShape ? "rotate(180deg)" : "",
        left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
        bottom: isCustomShape ? "" : "rotate(180deg)",
        right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
      }[side];
      return /* @__PURE__ */ React10.createElement("svg", _extends2({}, rest, {
        "aria-hidden": true,
        ref,
        width: isCustomShape ? width : width + strokeWidth,
        height: width,
        viewBox: "0 0 " + width + " " + (height > width ? height : width),
        style: {
          position: "absolute",
          pointerEvents: "none",
          [xOffsetProp]: arrowX,
          [yOffsetProp]: arrowY,
          [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + strokeWidth / 2 + "px)",
          transform: "" + rotation + (transform2 != null ? transform2 : ""),
          ...restStyle
        }
      }), strokeWidth > 0 && /* @__PURE__ */ React10.createElement("path", {
        clipPath: "url(#" + clipPathId + ")",
        fill: "none",
        stroke,
        strokeWidth: strokeWidth + (d ? 0 : 1),
        d: dValue
      }), /* @__PURE__ */ React10.createElement("path", {
        stroke: strokeWidth && !d ? rest.fill : "none",
        d: dValue
      }), /* @__PURE__ */ React10.createElement("clipPath", {
        id: clipPathId
      }, /* @__PURE__ */ React10.createElement("rect", {
        x: -halfStrokeWidth,
        y: halfStrokeWidth * (isCustomShape ? -1 : 1),
        width: width + strokeWidth,
        height: width
      })));
    });
    FloatingNodeContext = /* @__PURE__ */ React10.createContext(null);
    FloatingTreeContext = /* @__PURE__ */ React10.createContext(null);
    useFloatingParentNodeId = () => {
      var _React$useContext;
      return ((_React$useContext = React10.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
    };
    useFloatingTree = () => React10.useContext(FloatingTreeContext);
    safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
    FloatingDelayGroupContext = /* @__PURE__ */ React10.createContext({
      delay: 0,
      initialDelay: 0,
      timeoutMs: 0,
      currentId: null,
      setCurrentId: () => {
      },
      setState: () => {
      },
      isInstantPhase: false
    });
    useDelayGroupContext = () => React10.useContext(FloatingDelayGroupContext);
    FloatingDelayGroup = (_ref) => {
      let {
        children,
        delay,
        timeoutMs = 0
      } = _ref;
      const [state2, setState] = React10.useReducer((prev2, next2) => ({
        ...prev2,
        ...next2
      }), {
        delay,
        timeoutMs,
        initialDelay: delay,
        currentId: null,
        isInstantPhase: false
      });
      const initialCurrentIdRef = React10.useRef(null);
      const setCurrentId = React10.useCallback((currentId) => {
        setState({
          currentId
        });
      }, []);
      index2(() => {
        if (state2.currentId) {
          if (initialCurrentIdRef.current === null) {
            initialCurrentIdRef.current = state2.currentId;
          } else {
            setState({
              isInstantPhase: true
            });
          }
        } else {
          setState({
            isInstantPhase: false
          });
          initialCurrentIdRef.current = null;
        }
      }, [state2.currentId]);
      return /* @__PURE__ */ React10.createElement(FloatingDelayGroupContext.Provider, {
        value: React10.useMemo(() => ({
          ...state2,
          setState,
          setCurrentId
        }), [state2, setCurrentId])
      }, children);
    };
    useDelayGroup = (_ref2, _ref3) => {
      let {
        open,
        onOpenChange
      } = _ref2;
      let {
        id: id2
      } = _ref3;
      const {
        currentId,
        setCurrentId,
        initialDelay,
        setState,
        timeoutMs
      } = useDelayGroupContext();
      index2(() => {
        if (currentId) {
          setState({
            delay: {
              open: 1,
              close: getDelay(initialDelay, "close")
            }
          });
          if (currentId !== id2) {
            onOpenChange(false);
          }
        }
      }, [id2, onOpenChange, setState, currentId, initialDelay]);
      index2(() => {
        function unset() {
          onOpenChange(false);
          setState({
            delay: initialDelay,
            currentId: null
          });
        }
        if (!open && currentId === id2) {
          if (timeoutMs) {
            const timeout = window.setTimeout(unset, timeoutMs);
            return () => {
              clearTimeout(timeout);
            };
          }
          unset();
        }
      }, [open, setState, currentId, id2, onOpenChange, initialDelay, timeoutMs]);
      index2(() => {
        if (open) {
          setCurrentId(id2);
        }
      }, [open, setCurrentId, id2]);
    };
    counterMap = /* @__PURE__ */ new WeakMap();
    uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
    markerMap = {};
    lockCount = 0;
    supportsInert = () => typeof HTMLElement !== "undefined" && "inert" in HTMLElement.prototype;
    unwrapHost = (node2) => node2 && (node2.host || unwrapHost(node2.parentNode));
    correctElements = (parent, targets) => targets.map((target) => {
      if (parent.contains(target)) {
        return target;
      }
      const correctedTarget = unwrapHost(target);
      if (parent.contains(correctedTarget)) {
        return correctedTarget;
      }
      return null;
    }).filter((x) => x != null);
    getTabbableOptions = () => ({
      getShadowRoot: true,
      displayCheck: (
        // JSDOM does not support the `tabbable` library. To solve this we can
        // check if `ResizeObserver` is a real function (not polyfilled), which
        // determines if the current environment is JSDOM-like.
        typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
      )
    });
    HIDDEN_STYLES = {
      border: 0,
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: 0,
      position: "fixed",
      whiteSpace: "nowrap",
      width: "1px",
      top: 0,
      left: 0
    };
    FocusGuard = /* @__PURE__ */ React10.forwardRef(function FocusGuard2(props, ref) {
      const [role, setRole] = React10.useState();
      index2(() => {
        if (isSafari2()) {
          setRole("button");
        }
        document.addEventListener("keydown", setActiveElementOnTab);
        return () => {
          document.removeEventListener("keydown", setActiveElementOnTab);
        };
      }, []);
      const restProps = {
        ref,
        tabIndex: 0,
        // Role is only for VoiceOver
        role,
        "aria-hidden": role ? void 0 : true,
        [createAttribute("focus-guard")]: "",
        style: HIDDEN_STYLES
      };
      return /* @__PURE__ */ React10.createElement("span", _extends2({}, props, restProps));
    });
    PortalContext = /* @__PURE__ */ React10.createContext(null);
    attr = /* @__PURE__ */ createAttribute("portal");
    usePortalContext2 = () => React10.useContext(PortalContext);
    LIST_LIMIT = 20;
    previouslyFocusedElements = [];
    VisuallyHiddenDismiss = /* @__PURE__ */ React10.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
      return /* @__PURE__ */ React10.createElement("button", _extends2({}, props, {
        type: "button",
        ref,
        tabIndex: -1,
        style: HIDDEN_STYLES
      }));
    });
    activeLocks = /* @__PURE__ */ new Set();
    FloatingOverlay = /* @__PURE__ */ React10.forwardRef(function FloatingOverlay2(_ref, ref) {
      let {
        lockScroll = false,
        ...rest
      } = _ref;
      const lockId = useId6();
      index2(() => {
        if (!lockScroll)
          return;
        activeLocks.add(lockId);
        const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform2());
        const bodyStyle = document.body.style;
        const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
        const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
        const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
        const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.pageXOffset;
        const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.pageYOffset;
        bodyStyle.overflow = "hidden";
        if (scrollbarWidth) {
          bodyStyle[paddingProp] = scrollbarWidth + "px";
        }
        if (isIOS) {
          var _window$visualViewpor, _window$visualViewpor2;
          const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
          const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
          Object.assign(bodyStyle, {
            position: "fixed",
            top: -(scrollY - Math.floor(offsetTop)) + "px",
            left: -(scrollX - Math.floor(offsetLeft)) + "px",
            right: "0"
          });
        }
        return () => {
          activeLocks.delete(lockId);
          if (activeLocks.size === 0) {
            Object.assign(bodyStyle, {
              overflow: "",
              [paddingProp]: ""
            });
            if (isIOS) {
              Object.assign(bodyStyle, {
                position: "",
                top: "",
                left: "",
                right: ""
              });
              window.scrollTo(scrollX, scrollY);
            }
          }
        };
      }, [lockId, lockScroll]);
      return /* @__PURE__ */ React10.createElement("div", _extends2({
        ref
      }, rest, {
        style: {
          position: "fixed",
          overflow: "auto",
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          ...rest.style
        }
      }));
    });
    bubbleHandlerKeys = {
      pointerdown: "onPointerDown",
      mousedown: "onMouseDown",
      click: "onClick"
    };
    captureHandlerKeys = {
      pointerdown: "onPointerDownCapture",
      mousedown: "onMouseDownCapture",
      click: "onClickCapture"
    };
    normalizeProp = (normalizable) => {
      var _normalizable$escapeK, _normalizable$outside;
      return {
        escapeKey: typeof normalizable === "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,
        outsidePress: typeof normalizable === "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true
      };
    };
    if (true) {
      devMessageSet = /* @__PURE__ */ new Set();
    }
    ACTIVE_KEY = "active";
    SELECTED_KEY = "selected";
    isPreventScrollSupported = false;
    componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", false]]);
    camelCaseToKebabCase = (str) => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? "-" : "") + $.toLowerCase());
    inner = (props) => ({
      name: "inner",
      options: props,
      async fn(state2) {
        const {
          listRef,
          overflowRef,
          onFallbackChange,
          offset: innerOffset = 0,
          index: index3 = 0,
          minItemsVisible = 4,
          referenceOverflowThreshold = 0,
          scrollRef,
          ...detectOverflowOptions
        } = props;
        const {
          rects,
          elements: {
            floating
          }
        } = state2;
        const item = listRef.current[index3];
        if (true) {
          if (!state2.placement.startsWith("bottom")) {
            console.warn(['Floating UI: `placement` side must be "bottom" when using the', "`inner` middleware."].join(" "));
          }
        }
        if (!item) {
          return {};
        }
        const nextArgs = {
          ...state2,
          ...await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state2)
        };
        const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;
        const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);
        const refOverflow = await detectOverflow(nextArgs, {
          ...detectOverflowOptions,
          elementContext: "reference"
        });
        const diffY = Math.max(0, overflow.top);
        const nextY = nextArgs.y + diffY;
        const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));
        el.style.maxHeight = maxHeight + "px";
        el.scrollTop = diffY;
        if (onFallbackChange) {
          if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {
            (0, import_react_dom5.flushSync)(() => onFallbackChange(true));
          } else {
            (0, import_react_dom5.flushSync)(() => onFallbackChange(false));
          }
        }
        if (overflowRef) {
          overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({
            ...nextArgs,
            y: nextY
          }, el.offsetHeight), detectOverflowOptions);
        }
        return {
          y: nextY
        };
      }
    });
  }
});

// node_modules/date-fns/set.js
var require_set = __commonJS({
  "node_modules/date-fns/set.js"(exports) {
    "use strict";
    exports.set = set;
    var _index = require_constructFrom();
    var _index2 = require_setMonth();
    var _index3 = require_toDate();
    function set(date, values) {
      let _date = (0, _index3.toDate)(date);
      if (isNaN(+_date)) {
        return (0, _index.constructFrom)(date, NaN);
      }
      if (values.year != null) {
        _date.setFullYear(values.year);
      }
      if (values.month != null) {
        _date = (0, _index2.setMonth)(_date, values.month);
      }
      if (values.date != null) {
        _date.setDate(values.date);
      }
      if (values.hours != null) {
        _date.setHours(values.hours);
      }
      if (values.minutes != null) {
        _date.setMinutes(values.minutes);
      }
      if (values.seconds != null) {
        _date.setSeconds(values.seconds);
      }
      if (values.milliseconds != null) {
        _date.setMilliseconds(values.milliseconds);
      }
      return _date;
    }
  }
});

// node_modules/react-datepicker/dist/react-datepicker.min.js
var require_react_datepicker_min = __commonJS({
  "node_modules/react-datepicker/dist/react-datepicker.min.js"(exports, module) {
    !function(e, t2) {
      "object" == typeof exports && "undefined" != typeof module ? t2(exports, require_react(), require_prop_types(), require_classnames(), require_isDate(), require_isValid(), require_format(), require_addMinutes(), require_addHours(), require_addDays(), require_addWeeks(), require_addMonths(), require_addQuarters(), require_addYears(), require_subDays(), require_subWeeks(), require_subMonths(), require_subQuarters(), require_subYears(), require_getSeconds(), require_getMinutes(), require_getHours(), require_getDay(), require_getDate(), require_getISOWeek(), require_getMonth(), require_getQuarter(), require_getYear(), require_getTime(), require_setSeconds(), require_setMinutes(), require_setHours(), require_setMonth(), require_setQuarter(), require_setYear(), require_min(), require_max(), require_differenceInCalendarDays(), require_differenceInCalendarMonths(), require_differenceInCalendarYears(), require_startOfDay(), require_startOfWeek(), require_startOfMonth(), require_startOfQuarter(), require_startOfYear(), require_endOfDay(), require_endOfWeek(), require_endOfMonth(), require_endOfYear(), require_isEqual(), require_isSameDay(), require_isSameMonth(), require_isSameYear(), require_isSameQuarter(), require_isAfter(), require_isBefore(), require_isWithinInterval(), require_toDate(), require_parse(), require_parseISO(), (init_react_onclickoutside_es(), __toCommonJS(react_onclickoutside_es_exports)), require_react_dom(), (init_floating_ui_react_esm(), __toCommonJS(floating_ui_react_esm_exports)), require_set()) : "function" == typeof define && define.amd ? define(["exports", "react", "prop-types", "classnames", "date-fns/isDate", "date-fns/isValid", "date-fns/format", "date-fns/addMinutes", "date-fns/addHours", "date-fns/addDays", "date-fns/addWeeks", "date-fns/addMonths", "date-fns/addQuarters", "date-fns/addYears", "date-fns/subDays", "date-fns/subWeeks", "date-fns/subMonths", "date-fns/subQuarters", "date-fns/subYears", "date-fns/getSeconds", "date-fns/getMinutes", "date-fns/getHours", "date-fns/getDay", "date-fns/getDate", "date-fns/getISOWeek", "date-fns/getMonth", "date-fns/getQuarter", "date-fns/getYear", "date-fns/getTime", "date-fns/setSeconds", "date-fns/setMinutes", "date-fns/setHours", "date-fns/setMonth", "date-fns/setQuarter", "date-fns/setYear", "date-fns/min", "date-fns/max", "date-fns/differenceInCalendarDays", "date-fns/differenceInCalendarMonths", "date-fns/differenceInCalendarYears", "date-fns/startOfDay", "date-fns/startOfWeek", "date-fns/startOfMonth", "date-fns/startOfQuarter", "date-fns/startOfYear", "date-fns/endOfDay", "date-fns/endOfWeek", "date-fns/endOfMonth", "date-fns/endOfYear", "date-fns/isEqual", "date-fns/isSameDay", "date-fns/isSameMonth", "date-fns/isSameYear", "date-fns/isSameQuarter", "date-fns/isAfter", "date-fns/isBefore", "date-fns/isWithinInterval", "date-fns/toDate", "date-fns/parse", "date-fns/parseISO", "react-onclickoutside", "react-dom", "@floating-ui/react", "date-fns/set"], t2) : t2((e = "undefined" != typeof globalThis ? globalThis : e || self).DatePicker = {}, e.React, e.PropTypes, e.classNames, e.isDate, e.isValid$1, e.format, e.addMinutes, e.addHours, e.addDays, e.addWeeks, e.addMonths, e.addQuarters, e.addYears, e.subDays, e.subWeeks, e.subMonths, e.subQuarters, e.subYears, e.getSeconds, e.getMinutes, e.getHours, e.getDay, e.getDate, e.getISOWeek, e.getMonth, e.getQuarter, e.getYear, e.getTime, e.setSeconds, e.setMinutes, e.setHours, e.setMonth, e.setQuarter, e.setYear, e.min, e.max, e.differenceInCalendarDays, e.differenceInCalendarMonths, e.differenceInCalendarYears, e.startOfDay, e.startOfWeek, e.startOfMonth, e.startOfQuarter, e.startOfYear, e.endOfDay, e.endOfWeek, e.endOfMonth, e.endOfYear, e.isEqual$1, e.isSameDay$1, e.isSameMonth$1, e.isSameYear$1, e.isSameQuarter$1, e.isAfter, e.isBefore, e.isWithinInterval, e.toDate, e.parse, e.parseISO, e.onClickOutside, e.ReactDOM, e.react, e.set);
    }(exports, function(e, t2, r2, n, a2, o, s, i, p, c2, l, d, u, h, f, m, y, g, D, v, k, w, b2, S, M, C, _, Y, E, P, N, O, x, I, T, R, L, F, A, W, Q, q, K, B, H, j, V, U, $, z, G, J, X, Z, ee, te, re, ne, ae, oe, se, ie, pe, ce) {
      "use strict";
      function le(e2) {
        return e2 && "object" == typeof e2 && "default" in e2 ? e2 : { default: e2 };
      }
      var de = le(t2), ue = le(n), he = le(se), fe = le(ie);
      function me(e2, t3, r3) {
        return t3 = Ye(t3), function(e3, t4) {
          if (t4 && ("object" == typeof t4 || "function" == typeof t4))
            return t4;
          if (void 0 !== t4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return Pe(e3);
        }(e2, ye() ? Reflect.construct(t3, r3 || [], Ye(e2).constructor) : t3.apply(e2, r3));
      }
      function ye() {
        try {
          var e2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (e3) {
        }
        return (ye = function() {
          return !!e2;
        })();
      }
      function ge(e2, t3) {
        var r3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t3 && (n2 = n2.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function De(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var r3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? ge(Object(r3), true).forEach(function(t4) {
            Me(e2, t4, r3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r3)) : ge(Object(r3)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(r3, t4));
          });
        }
        return e2;
      }
      function ve(e2) {
        var t3 = function(e3, t4) {
          if ("object" != typeof e3 || !e3)
            return e3;
          var r3 = e3[Symbol.toPrimitive];
          if (void 0 !== r3) {
            var n2 = r3.call(e3, t4 || "default");
            if ("object" != typeof n2)
              return n2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === t4 ? String : Number)(e3);
        }(e2, "string");
        return "symbol" == typeof t3 ? t3 : String(t3);
      }
      function ke(e2) {
        return ke = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, ke(e2);
      }
      function we(e2, t3) {
        if (!(e2 instanceof t3))
          throw new TypeError("Cannot call a class as a function");
      }
      function be(e2, t3) {
        for (var r3 = 0; r3 < t3.length; r3++) {
          var n2 = t3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, ve(n2.key), n2);
        }
      }
      function Se(e2, t3, r3) {
        return t3 && be(e2.prototype, t3), r3 && be(e2, r3), Object.defineProperty(e2, "prototype", { writable: false }), e2;
      }
      function Me(e2, t3, r3) {
        return (t3 = ve(t3)) in e2 ? Object.defineProperty(e2, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e2[t3] = r3, e2;
      }
      function Ce() {
        return Ce = Object.assign ? Object.assign.bind() : function(e2) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = arguments[t3];
            for (var n2 in r3)
              Object.prototype.hasOwnProperty.call(r3, n2) && (e2[n2] = r3[n2]);
          }
          return e2;
        }, Ce.apply(this, arguments);
      }
      function _e3(e2, t3) {
        if ("function" != typeof t3 && null !== t3)
          throw new TypeError("Super expression must either be null or a function");
        e2.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e2, writable: true, configurable: true } }), Object.defineProperty(e2, "prototype", { writable: false }), t3 && Ee(e2, t3);
      }
      function Ye(e2) {
        return Ye = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e3) {
          return e3.__proto__ || Object.getPrototypeOf(e3);
        }, Ye(e2);
      }
      function Ee(e2, t3) {
        return Ee = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e3, t4) {
          return e3.__proto__ = t4, e3;
        }, Ee(e2, t3);
      }
      function Pe(e2) {
        if (void 0 === e2)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e2;
      }
      function Ne(e2) {
        return function(e3) {
          if (Array.isArray(e3))
            return Oe(e3);
        }(e2) || function(e3) {
          if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"])
            return Array.from(e3);
        }(e2) || function(e3, t3) {
          if (!e3)
            return;
          if ("string" == typeof e3)
            return Oe(e3, t3);
          var r3 = Object.prototype.toString.call(e3).slice(8, -1);
          "Object" === r3 && e3.constructor && (r3 = e3.constructor.name);
          if ("Map" === r3 || "Set" === r3)
            return Array.from(e3);
          if ("Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3))
            return Oe(e3, t3);
        }(e2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function Oe(e2, t3) {
        (null == t3 || t3 > e2.length) && (t3 = e2.length);
        for (var r3 = 0, n2 = new Array(t3); r3 < t3; r3++)
          n2[r3] = e2[r3];
        return n2;
      }
      var xe = 12, Ie = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
      function Te(e2) {
        var t3 = e2 ? "string" == typeof e2 || e2 instanceof String ? oe.parseISO(e2) : ne.toDate(e2) : /* @__PURE__ */ new Date();
        return Re(t3) ? t3 : null;
      }
      function Re(e2, t3) {
        return t3 = t3 || /* @__PURE__ */ new Date("1/1/1000"), o.isValid(e2) && !te.isBefore(e2, t3);
      }
      function Le(e2, t3, r3) {
        if ("en" === r3)
          return s.format(e2, t3, { useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true });
        var n2 = Je(r3);
        return r3 && !n2 && console.warn('A locale object was not found for the provided string ["'.concat(r3, '"].')), !n2 && Ge() && Je(Ge()) && (n2 = Je(Ge())), s.format(e2, t3, { locale: n2 || null, useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true });
      }
      function Fe(e2, t3) {
        var r3 = t3.dateFormat, n2 = t3.locale;
        return e2 && Le(e2, Array.isArray(r3) ? r3[0] : r3, n2) || "";
      }
      function Ae(e2, t3) {
        var r3 = t3.hour, n2 = void 0 === r3 ? 0 : r3, a3 = t3.minute, o2 = void 0 === a3 ? 0 : a3, s2 = t3.second, i2 = void 0 === s2 ? 0 : s2;
        return O.setHours(N.setMinutes(P.setSeconds(e2, i2), o2), n2);
      }
      function We(e2, t3, r3) {
        var n2 = Je(t3 || Ge());
        return q.startOfWeek(e2, { locale: n2, weekStartsOn: r3 });
      }
      function Qe(e2) {
        return K.startOfMonth(e2);
      }
      function qe(e2) {
        return H.startOfYear(e2);
      }
      function Ke(e2) {
        return B.startOfQuarter(e2);
      }
      function Be() {
        return Q.startOfDay(Te());
      }
      function He(e2, t3) {
        return e2 && t3 ? X.isSameYear(e2, t3) : !e2 && !t3;
      }
      function je(e2, t3) {
        return e2 && t3 ? J.isSameMonth(e2, t3) : !e2 && !t3;
      }
      function Ve(e2, t3) {
        return e2 && t3 ? Z.isSameQuarter(e2, t3) : !e2 && !t3;
      }
      function Ue(e2, t3) {
        return e2 && t3 ? G.isSameDay(e2, t3) : !e2 && !t3;
      }
      function $e(e2, t3) {
        return e2 && t3 ? z.isEqual(e2, t3) : !e2 && !t3;
      }
      function ze(e2, t3, r3) {
        var n2, a3 = Q.startOfDay(t3), o2 = j.endOfDay(r3);
        try {
          n2 = re.isWithinInterval(e2, { start: a3, end: o2 });
        } catch (e3) {
          n2 = false;
        }
        return n2;
      }
      function Ge() {
        return ("undefined" != typeof window ? window : globalThis).__localeId__;
      }
      function Je(e2) {
        if ("string" == typeof e2) {
          var t3 = "undefined" != typeof window ? window : globalThis;
          return t3.__localeData__ ? t3.__localeData__[e2] : null;
        }
        return e2;
      }
      function Xe(e2, t3) {
        return Le(x.setMonth(Te(), e2), "LLLL", t3);
      }
      function Ze(e2, t3) {
        return Le(x.setMonth(Te(), e2), "LLL", t3);
      }
      function et(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.minDate, n2 = t3.maxDate, a3 = t3.excludeDates, o2 = t3.excludeDateIntervals, s2 = t3.includeDates, i2 = t3.includeDateIntervals, p2 = t3.filterDate;
        return pt2(e2, { minDate: r3, maxDate: n2 }) || a3 && a3.some(function(t4) {
          return Ue(e2, t4.date ? t4.date : t4);
        }) || o2 && o2.some(function(t4) {
          var r4 = t4.start, n3 = t4.end;
          return re.isWithinInterval(e2, { start: r4, end: n3 });
        }) || s2 && !s2.some(function(t4) {
          return Ue(e2, t4);
        }) || i2 && !i2.some(function(t4) {
          var r4 = t4.start, n3 = t4.end;
          return re.isWithinInterval(e2, { start: r4, end: n3 });
        }) || p2 && !p2(Te(e2)) || false;
      }
      function tt(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.excludeDates, n2 = t3.excludeDateIntervals;
        return n2 && n2.length > 0 ? n2.some(function(t4) {
          var r4 = t4.start, n3 = t4.end;
          return re.isWithinInterval(e2, { start: r4, end: n3 });
        }) : r3 && r3.some(function(t4) {
          return Ue(e2, t4.date ? t4.date : t4);
        }) || false;
      }
      function rt(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.minDate, n2 = t3.maxDate, a3 = t3.excludeDates, o2 = t3.includeDates, s2 = t3.filterDate;
        return pt2(e2, { minDate: K.startOfMonth(r3), maxDate: U.endOfMonth(n2) }) || a3 && a3.some(function(t4) {
          return je(e2, t4);
        }) || o2 && !o2.some(function(t4) {
          return je(e2, t4);
        }) || s2 && !s2(Te(e2)) || false;
      }
      function nt(e2, t3, r3, n2) {
        var a3 = Y.getYear(e2), o2 = C.getMonth(e2), s2 = Y.getYear(t3), i2 = C.getMonth(t3), p2 = Y.getYear(n2);
        return a3 === s2 && a3 === p2 ? o2 <= r3 && r3 <= i2 : a3 < s2 ? p2 === a3 && o2 <= r3 || p2 === s2 && i2 >= r3 || p2 < s2 && p2 > a3 : void 0;
      }
      function at(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.minDate, n2 = t3.maxDate, a3 = t3.excludeDates, o2 = t3.includeDates, s2 = t3.filterDate;
        return pt2(e2, { minDate: r3, maxDate: n2 }) || a3 && a3.some(function(t4) {
          return Ve(e2, t4);
        }) || o2 && !o2.some(function(t4) {
          return Ve(e2, t4);
        }) || s2 && !s2(Te(e2)) || false;
      }
      function ot(e2, t3, r3) {
        if (!o.isValid(t3) || !o.isValid(r3))
          return false;
        var n2 = Y.getYear(t3), a3 = Y.getYear(r3);
        return n2 <= e2 && a3 >= e2;
      }
      function st(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.minDate, n2 = t3.maxDate, a3 = t3.excludeDates, o2 = t3.includeDates, s2 = t3.filterDate, i2 = new Date(e2, 0, 1);
        return pt2(i2, { minDate: H.startOfYear(r3), maxDate: $.endOfYear(n2) }) || a3 && a3.some(function(e3) {
          return He(i2, e3);
        }) || o2 && !o2.some(function(e3) {
          return He(i2, e3);
        }) || s2 && !s2(Te(i2)) || false;
      }
      function it(e2, t3, r3, n2) {
        var a3 = Y.getYear(e2), o2 = _.getQuarter(e2), s2 = Y.getYear(t3), i2 = _.getQuarter(t3), p2 = Y.getYear(n2);
        return a3 === s2 && a3 === p2 ? o2 <= r3 && r3 <= i2 : a3 < s2 ? p2 === a3 && o2 <= r3 || p2 === s2 && i2 >= r3 || p2 < s2 && p2 > a3 : void 0;
      }
      function pt2(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.minDate, n2 = t3.maxDate;
        return r3 && F.differenceInCalendarDays(e2, r3) < 0 || n2 && F.differenceInCalendarDays(e2, n2) > 0;
      }
      function ct(e2, t3) {
        return t3.some(function(t4) {
          return w.getHours(t4) === w.getHours(e2) && k.getMinutes(t4) === k.getMinutes(e2);
        });
      }
      function lt(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.excludeTimes, n2 = t3.includeTimes, a3 = t3.filterTime;
        return r3 && ct(e2, r3) || n2 && !ct(e2, n2) || a3 && !a3(e2) || false;
      }
      function dt(e2, t3) {
        var r3 = t3.minTime, n2 = t3.maxTime;
        if (!r3 || !n2)
          throw new Error("Both minTime and maxTime props required");
        var a3, o2 = Te(), s2 = O.setHours(N.setMinutes(o2, k.getMinutes(e2)), w.getHours(e2)), i2 = O.setHours(N.setMinutes(o2, k.getMinutes(r3)), w.getHours(r3)), p2 = O.setHours(N.setMinutes(o2, k.getMinutes(n2)), w.getHours(n2));
        try {
          a3 = !re.isWithinInterval(s2, { start: i2, end: p2 });
        } catch (e3) {
          a3 = false;
        }
        return a3;
      }
      function ut(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.minDate, n2 = t3.includeDates, a3 = y.subMonths(e2, 1);
        return r3 && A.differenceInCalendarMonths(r3, a3) > 0 || n2 && n2.every(function(e3) {
          return A.differenceInCalendarMonths(e3, a3) > 0;
        }) || false;
      }
      function ht(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.maxDate, n2 = t3.includeDates, a3 = d.addMonths(e2, 1);
        return r3 && A.differenceInCalendarMonths(a3, r3) > 0 || n2 && n2.every(function(e3) {
          return A.differenceInCalendarMonths(a3, e3) > 0;
        }) || false;
      }
      function ft(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.minDate, n2 = t3.includeDates, a3 = D.subYears(e2, 1);
        return r3 && W.differenceInCalendarYears(r3, a3) > 0 || n2 && n2.every(function(e3) {
          return W.differenceInCalendarYears(e3, a3) > 0;
        }) || false;
      }
      function mt(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.maxDate, n2 = t3.includeDates, a3 = h.addYears(e2, 1);
        return r3 && W.differenceInCalendarYears(a3, r3) > 0 || n2 && n2.every(function(e3) {
          return W.differenceInCalendarYears(a3, e3) > 0;
        }) || false;
      }
      function yt(e2) {
        var t3 = e2.minDate, r3 = e2.includeDates;
        if (r3 && t3) {
          var n2 = r3.filter(function(e3) {
            return F.differenceInCalendarDays(e3, t3) >= 0;
          });
          return R.min(n2);
        }
        return r3 ? R.min(r3) : t3;
      }
      function gt(e2) {
        var t3 = e2.maxDate, r3 = e2.includeDates;
        if (r3 && t3) {
          var n2 = r3.filter(function(e3) {
            return F.differenceInCalendarDays(e3, t3) <= 0;
          });
          return L.max(n2);
        }
        return r3 ? L.max(r3) : t3;
      }
      function Dt() {
        for (var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "react-datepicker__day--highlighted", r3 = /* @__PURE__ */ new Map(), n2 = 0, o2 = e2.length; n2 < o2; n2++) {
          var s2 = e2[n2];
          if (a2.isDate(s2)) {
            var i2 = Le(s2, "MM.dd.yyyy"), p2 = r3.get(i2) || [];
            p2.includes(t3) || (p2.push(t3), r3.set(i2, p2));
          } else if ("object" === ke(s2)) {
            var c3 = Object.keys(s2), l2 = c3[0], d2 = s2[c3[0]];
            if ("string" == typeof l2 && d2.constructor === Array)
              for (var u2 = 0, h2 = d2.length; u2 < h2; u2++) {
                var f2 = Le(d2[u2], "MM.dd.yyyy"), m2 = r3.get(f2) || [];
                m2.includes(l2) || (m2.push(l2), r3.set(f2, m2));
              }
          }
        }
        return r3;
      }
      function vt() {
        var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "react-datepicker__day--holidays", r3 = /* @__PURE__ */ new Map();
        return e2.forEach(function(e3) {
          var n2 = e3.date, o2 = e3.holidayName;
          if (a2.isDate(n2)) {
            var s2 = Le(n2, "MM.dd.yyyy"), i2 = r3.get(s2) || {};
            if (!("className" in i2) || i2.className !== t3 || (p2 = i2.holidayNames, c3 = [o2], p2.length !== c3.length || !p2.every(function(e4, t4) {
              return e4 === c3[t4];
            }))) {
              var p2, c3;
              i2.className = t3;
              var l2 = i2.holidayNames;
              i2.holidayNames = l2 ? [].concat(Ne(l2), [o2]) : [o2], r3.set(s2, i2);
            }
          }
        }), r3;
      }
      function kt(e2, t3, r3, n2, a3) {
        for (var o2 = a3.length, s2 = [], c3 = 0; c3 < o2; c3++) {
          var l2 = i.addMinutes(p.addHours(e2, w.getHours(a3[c3])), k.getMinutes(a3[c3])), d2 = i.addMinutes(e2, (r3 + 1) * n2);
          ee.isAfter(l2, t3) && te.isBefore(l2, d2) && s2.push(a3[c3]);
        }
        return s2;
      }
      function wt(e2) {
        return e2 < 10 ? "0".concat(e2) : "".concat(e2);
      }
      function bt(e2) {
        var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : xe, r3 = Math.ceil(Y.getYear(e2) / t3) * t3;
        return { startPeriod: r3 - (t3 - 1), endPeriod: r3 };
      }
      function St(e2) {
        var t3 = e2.getSeconds(), r3 = e2.getMilliseconds();
        return ne.toDate(e2.getTime() - 1e3 * t3 - r3);
      }
      function Mt(e2) {
        if (!a2.isDate(e2))
          throw new Error("Invalid date");
        var t3 = new Date(e2);
        return t3.setHours(0, 0, 0, 0), t3;
      }
      function Ct(e2, t3) {
        if (!a2.isDate(e2) || !a2.isDate(t3))
          throw new Error("Invalid date received");
        var r3 = Mt(e2), n2 = Mt(t3);
        return te.isBefore(r3, n2);
      }
      function _t(e2, t3, r3, n2) {
        for (var a3 = [], o2 = 0; o2 < 2 * t3 + 1; o2++) {
          var s2 = e2 + t3 - o2, i2 = true;
          r3 && (i2 = Y.getYear(r3) <= s2), n2 && i2 && (i2 = Y.getYear(n2) >= s2), i2 && a3.push(s2);
        }
        return a3;
      }
      var Yt = function(e2) {
        function r3(e3) {
          var n2;
          we(this, r3), Me(Pe(n2 = me(this, r3, [e3])), "renderOptions", function() {
            var e4 = n2.props.year, t3 = n2.state.yearsList.map(function(t4) {
              return de.default.createElement("div", { className: e4 === t4 ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option", key: t4, onClick: n2.onChange.bind(Pe(n2), t4), "aria-selected": e4 === t4 ? "true" : void 0 }, e4 === t4 ? de.default.createElement("span", { className: "react-datepicker__year-option--selected" }, "\u2713") : "", t4);
            }), r4 = n2.props.minDate ? Y.getYear(n2.props.minDate) : null, a4 = n2.props.maxDate ? Y.getYear(n2.props.maxDate) : null;
            return a4 && n2.state.yearsList.find(function(e5) {
              return e5 === a4;
            }) || t3.unshift(de.default.createElement("div", { className: "react-datepicker__year-option", key: "upcoming", onClick: n2.incrementYears }, de.default.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming" }))), r4 && n2.state.yearsList.find(function(e5) {
              return e5 === r4;
            }) || t3.push(de.default.createElement("div", { className: "react-datepicker__year-option", key: "previous", onClick: n2.decrementYears }, de.default.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous" }))), t3;
          }), Me(Pe(n2), "onChange", function(e4) {
            n2.props.onChange(e4);
          }), Me(Pe(n2), "handleClickOutside", function() {
            n2.props.onCancel();
          }), Me(Pe(n2), "shiftYears", function(e4) {
            var t3 = n2.state.yearsList.map(function(t4) {
              return t4 + e4;
            });
            n2.setState({ yearsList: t3 });
          }), Me(Pe(n2), "incrementYears", function() {
            return n2.shiftYears(1);
          }), Me(Pe(n2), "decrementYears", function() {
            return n2.shiftYears(-1);
          });
          var a3 = e3.yearDropdownItemNumber, o2 = e3.scrollableYearDropdown, s2 = a3 || (o2 ? 10 : 5);
          return n2.state = { yearsList: _t(n2.props.year, s2, n2.props.minDate, n2.props.maxDate) }, n2.dropdownRef = t2.createRef(), n2;
        }
        return _e3(r3, e2), Se(r3, [{ key: "componentDidMount", value: function() {
          var e3 = this.dropdownRef.current;
          if (e3) {
            var t3 = e3.children ? Array.from(e3.children) : null, r4 = t3 ? t3.find(function(e4) {
              return e4.ariaSelected;
            }) : null;
            e3.scrollTop = r4 ? r4.offsetTop + (r4.clientHeight - e3.clientHeight) / 2 : (e3.scrollHeight - e3.clientHeight) / 2;
          }
        } }, { key: "render", value: function() {
          var e3 = ue.default({ "react-datepicker__year-dropdown": true, "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown });
          return de.default.createElement("div", { className: e3, ref: this.dropdownRef }, this.renderOptions());
        } }]), r3;
      }(de.default.Component), Et = he.default(Yt), Pt = function(e2) {
        function t3() {
          var e3;
          we(this, t3);
          for (var r3 = arguments.length, n2 = new Array(r3), a3 = 0; a3 < r3; a3++)
            n2[a3] = arguments[a3];
          return Me(Pe(e3 = me(this, t3, [].concat(n2))), "state", { dropdownVisible: false }), Me(Pe(e3), "renderSelectOptions", function() {
            for (var t4 = e3.props.minDate ? Y.getYear(e3.props.minDate) : 1900, r4 = e3.props.maxDate ? Y.getYear(e3.props.maxDate) : 2100, n3 = [], a4 = t4; a4 <= r4; a4++)
              n3.push(de.default.createElement("option", { key: a4, value: a4 }, a4));
            return n3;
          }), Me(Pe(e3), "onSelectChange", function(t4) {
            e3.onChange(t4.target.value);
          }), Me(Pe(e3), "renderSelectMode", function() {
            return de.default.createElement("select", { value: e3.props.year, className: "react-datepicker__year-select", onChange: e3.onSelectChange }, e3.renderSelectOptions());
          }), Me(Pe(e3), "renderReadView", function(t4) {
            return de.default.createElement("div", { key: "read", style: { visibility: t4 ? "visible" : "hidden" }, className: "react-datepicker__year-read-view", onClick: function(t5) {
              return e3.toggleDropdown(t5);
            } }, de.default.createElement("span", { className: "react-datepicker__year-read-view--down-arrow" }), de.default.createElement("span", { className: "react-datepicker__year-read-view--selected-year" }, e3.props.year));
          }), Me(Pe(e3), "renderDropdown", function() {
            return de.default.createElement(Et, { key: "dropdown", year: e3.props.year, onChange: e3.onChange, onCancel: e3.toggleDropdown, minDate: e3.props.minDate, maxDate: e3.props.maxDate, scrollableYearDropdown: e3.props.scrollableYearDropdown, yearDropdownItemNumber: e3.props.yearDropdownItemNumber });
          }), Me(Pe(e3), "renderScrollMode", function() {
            var t4 = e3.state.dropdownVisible, r4 = [e3.renderReadView(!t4)];
            return t4 && r4.unshift(e3.renderDropdown()), r4;
          }), Me(Pe(e3), "onChange", function(t4) {
            e3.toggleDropdown(), t4 !== e3.props.year && e3.props.onChange(t4);
          }), Me(Pe(e3), "toggleDropdown", function(t4) {
            e3.setState({ dropdownVisible: !e3.state.dropdownVisible }, function() {
              e3.props.adjustDateOnChange && e3.handleYearChange(e3.props.date, t4);
            });
          }), Me(Pe(e3), "handleYearChange", function(t4, r4) {
            e3.onSelect(t4, r4), e3.setOpen();
          }), Me(Pe(e3), "onSelect", function(t4, r4) {
            e3.props.onSelect && e3.props.onSelect(t4, r4);
          }), Me(Pe(e3), "setOpen", function() {
            e3.props.setOpen && e3.props.setOpen(true);
          }), e3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "render", value: function() {
          var e3;
          switch (this.props.dropdownMode) {
            case "scroll":
              e3 = this.renderScrollMode();
              break;
            case "select":
              e3 = this.renderSelectMode();
          }
          return de.default.createElement("div", { className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(this.props.dropdownMode) }, e3);
        } }]), t3;
      }(de.default.Component), Nt = function(e2) {
        function t3() {
          var e3;
          we(this, t3);
          for (var r3 = arguments.length, n2 = new Array(r3), a3 = 0; a3 < r3; a3++)
            n2[a3] = arguments[a3];
          return Me(Pe(e3 = me(this, t3, [].concat(n2))), "isSelectedMonth", function(t4) {
            return e3.props.month === t4;
          }), Me(Pe(e3), "renderOptions", function() {
            return e3.props.monthNames.map(function(t4, r4) {
              return de.default.createElement("div", { className: e3.isSelectedMonth(r4) ? "react-datepicker__month-option react-datepicker__month-option--selected_month" : "react-datepicker__month-option", key: t4, onClick: e3.onChange.bind(Pe(e3), r4), "aria-selected": e3.isSelectedMonth(r4) ? "true" : void 0 }, e3.isSelectedMonth(r4) ? de.default.createElement("span", { className: "react-datepicker__month-option--selected" }, "\u2713") : "", t4);
            });
          }), Me(Pe(e3), "onChange", function(t4) {
            return e3.props.onChange(t4);
          }), Me(Pe(e3), "handleClickOutside", function() {
            return e3.props.onCancel();
          }), e3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "render", value: function() {
          return de.default.createElement("div", { className: "react-datepicker__month-dropdown" }, this.renderOptions());
        } }]), t3;
      }(de.default.Component), Ot = he.default(Nt), xt = function(e2) {
        function t3() {
          var e3;
          we(this, t3);
          for (var r3 = arguments.length, n2 = new Array(r3), a3 = 0; a3 < r3; a3++)
            n2[a3] = arguments[a3];
          return Me(Pe(e3 = me(this, t3, [].concat(n2))), "state", { dropdownVisible: false }), Me(Pe(e3), "renderSelectOptions", function(e4) {
            return e4.map(function(e5, t4) {
              return de.default.createElement("option", { key: t4, value: t4 }, e5);
            });
          }), Me(Pe(e3), "renderSelectMode", function(t4) {
            return de.default.createElement("select", { value: e3.props.month, className: "react-datepicker__month-select", onChange: function(t5) {
              return e3.onChange(t5.target.value);
            } }, e3.renderSelectOptions(t4));
          }), Me(Pe(e3), "renderReadView", function(t4, r4) {
            return de.default.createElement("div", { key: "read", style: { visibility: t4 ? "visible" : "hidden" }, className: "react-datepicker__month-read-view", onClick: e3.toggleDropdown }, de.default.createElement("span", { className: "react-datepicker__month-read-view--down-arrow" }), de.default.createElement("span", { className: "react-datepicker__month-read-view--selected-month" }, r4[e3.props.month]));
          }), Me(Pe(e3), "renderDropdown", function(t4) {
            return de.default.createElement(Ot, { key: "dropdown", month: e3.props.month, monthNames: t4, onChange: e3.onChange, onCancel: e3.toggleDropdown });
          }), Me(Pe(e3), "renderScrollMode", function(t4) {
            var r4 = e3.state.dropdownVisible, n3 = [e3.renderReadView(!r4, t4)];
            return r4 && n3.unshift(e3.renderDropdown(t4)), n3;
          }), Me(Pe(e3), "onChange", function(t4) {
            e3.toggleDropdown(), t4 !== e3.props.month && e3.props.onChange(t4);
          }), Me(Pe(e3), "toggleDropdown", function() {
            return e3.setState({ dropdownVisible: !e3.state.dropdownVisible });
          }), e3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "render", value: function() {
          var e3, t4 = this, r3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function(e4) {
            return Ze(e4, t4.props.locale);
          } : function(e4) {
            return Xe(e4, t4.props.locale);
          });
          switch (this.props.dropdownMode) {
            case "scroll":
              e3 = this.renderScrollMode(r3);
              break;
            case "select":
              e3 = this.renderSelectMode(r3);
          }
          return de.default.createElement("div", { className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(this.props.dropdownMode) }, e3);
        } }]), t3;
      }(de.default.Component);
      function It(e2, t3) {
        for (var r3 = [], n2 = Qe(e2), a3 = Qe(t3); !ee.isAfter(n2, a3); )
          r3.push(Te(n2)), n2 = d.addMonths(n2, 1);
        return r3;
      }
      var Tt = function(e2) {
        function t3(e3) {
          var r3;
          return we(this, t3), Me(Pe(r3 = me(this, t3, [e3])), "renderOptions", function() {
            return r3.state.monthYearsList.map(function(e4) {
              var t4 = E.getTime(e4), n2 = He(r3.props.date, e4) && je(r3.props.date, e4);
              return de.default.createElement("div", { className: n2 ? "react-datepicker__month-year-option--selected_month-year" : "react-datepicker__month-year-option", key: t4, onClick: r3.onChange.bind(Pe(r3), t4), "aria-selected": n2 ? "true" : void 0 }, n2 ? de.default.createElement("span", { className: "react-datepicker__month-year-option--selected" }, "\u2713") : "", Le(e4, r3.props.dateFormat, r3.props.locale));
            });
          }), Me(Pe(r3), "onChange", function(e4) {
            return r3.props.onChange(e4);
          }), Me(Pe(r3), "handleClickOutside", function() {
            r3.props.onCancel();
          }), r3.state = { monthYearsList: It(r3.props.minDate, r3.props.maxDate) }, r3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "render", value: function() {
          var e3 = ue.default({ "react-datepicker__month-year-dropdown": true, "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown });
          return de.default.createElement("div", { className: e3 }, this.renderOptions());
        } }]), t3;
      }(de.default.Component), Rt = he.default(Tt), Lt = function(e2) {
        function t3() {
          var e3;
          we(this, t3);
          for (var r3 = arguments.length, n2 = new Array(r3), a3 = 0; a3 < r3; a3++)
            n2[a3] = arguments[a3];
          return Me(Pe(e3 = me(this, t3, [].concat(n2))), "state", { dropdownVisible: false }), Me(Pe(e3), "renderSelectOptions", function() {
            for (var t4 = Qe(e3.props.minDate), r4 = Qe(e3.props.maxDate), n3 = []; !ee.isAfter(t4, r4); ) {
              var a4 = E.getTime(t4);
              n3.push(de.default.createElement("option", { key: a4, value: a4 }, Le(t4, e3.props.dateFormat, e3.props.locale))), t4 = d.addMonths(t4, 1);
            }
            return n3;
          }), Me(Pe(e3), "onSelectChange", function(t4) {
            e3.onChange(t4.target.value);
          }), Me(Pe(e3), "renderSelectMode", function() {
            return de.default.createElement("select", { value: E.getTime(Qe(e3.props.date)), className: "react-datepicker__month-year-select", onChange: e3.onSelectChange }, e3.renderSelectOptions());
          }), Me(Pe(e3), "renderReadView", function(t4) {
            var r4 = Le(e3.props.date, e3.props.dateFormat, e3.props.locale);
            return de.default.createElement("div", { key: "read", style: { visibility: t4 ? "visible" : "hidden" }, className: "react-datepicker__month-year-read-view", onClick: function(t5) {
              return e3.toggleDropdown(t5);
            } }, de.default.createElement("span", { className: "react-datepicker__month-year-read-view--down-arrow" }), de.default.createElement("span", { className: "react-datepicker__month-year-read-view--selected-month-year" }, r4));
          }), Me(Pe(e3), "renderDropdown", function() {
            return de.default.createElement(Rt, { key: "dropdown", date: e3.props.date, dateFormat: e3.props.dateFormat, onChange: e3.onChange, onCancel: e3.toggleDropdown, minDate: e3.props.minDate, maxDate: e3.props.maxDate, scrollableMonthYearDropdown: e3.props.scrollableMonthYearDropdown, locale: e3.props.locale });
          }), Me(Pe(e3), "renderScrollMode", function() {
            var t4 = e3.state.dropdownVisible, r4 = [e3.renderReadView(!t4)];
            return t4 && r4.unshift(e3.renderDropdown()), r4;
          }), Me(Pe(e3), "onChange", function(t4) {
            e3.toggleDropdown();
            var r4 = Te(parseInt(t4));
            He(e3.props.date, r4) && je(e3.props.date, r4) || e3.props.onChange(r4);
          }), Me(Pe(e3), "toggleDropdown", function() {
            return e3.setState({ dropdownVisible: !e3.state.dropdownVisible });
          }), e3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "render", value: function() {
          var e3;
          switch (this.props.dropdownMode) {
            case "scroll":
              e3 = this.renderScrollMode();
              break;
            case "select":
              e3 = this.renderSelectMode();
          }
          return de.default.createElement("div", { className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(this.props.dropdownMode) }, e3);
        } }]), t3;
      }(de.default.Component), Ft = function(e2) {
        function t3() {
          var e3;
          we(this, t3);
          for (var r3 = arguments.length, n2 = new Array(r3), a3 = 0; a3 < r3; a3++)
            n2[a3] = arguments[a3];
          return Me(Pe(e3 = me(this, t3, [].concat(n2))), "dayEl", de.default.createRef()), Me(Pe(e3), "handleClick", function(t4) {
            !e3.isDisabled() && e3.props.onClick && e3.props.onClick(t4);
          }), Me(Pe(e3), "handleMouseEnter", function(t4) {
            !e3.isDisabled() && e3.props.onMouseEnter && e3.props.onMouseEnter(t4);
          }), Me(Pe(e3), "handleOnKeyDown", function(t4) {
            " " === t4.key && (t4.preventDefault(), t4.key = "Enter"), e3.props.handleOnKeyDown(t4);
          }), Me(Pe(e3), "isSameDay", function(t4) {
            return Ue(e3.props.day, t4);
          }), Me(Pe(e3), "isKeyboardSelected", function() {
            return !e3.props.disabledKeyboardNavigation && !(e3.isSameDay(e3.props.selected) || e3.isSameWeek(e3.props.selected)) && (e3.isSameDay(e3.props.preSelection) || e3.isSameWeek(e3.props.preSelection));
          }), Me(Pe(e3), "isDisabled", function() {
            return et(e3.props.day, e3.props);
          }), Me(Pe(e3), "isExcluded", function() {
            return tt(e3.props.day, e3.props);
          }), Me(Pe(e3), "isStartOfWeek", function() {
            return Ue(e3.props.day, We(e3.props.day, e3.props.locale, e3.props.calendarStartDay));
          }), Me(Pe(e3), "isSameWeek", function(t4) {
            return e3.props.showWeekPicker && Ue(t4, We(e3.props.day, e3.props.locale, e3.props.calendarStartDay));
          }), Me(Pe(e3), "getHighLightedClass", function() {
            var t4 = e3.props, r4 = t4.day, n3 = t4.highlightDates;
            if (!n3)
              return false;
            var a4 = Le(r4, "MM.dd.yyyy");
            return n3.get(a4);
          }), Me(Pe(e3), "getHolidaysClass", function() {
            var t4 = e3.props, r4 = t4.day, n3 = t4.holidays;
            if (!n3)
              return false;
            var a4 = Le(r4, "MM.dd.yyyy");
            return n3.has(a4) ? [n3.get(a4).className] : void 0;
          }), Me(Pe(e3), "isInRange", function() {
            var t4 = e3.props, r4 = t4.day, n3 = t4.startDate, a4 = t4.endDate;
            return !(!n3 || !a4) && ze(r4, n3, a4);
          }), Me(Pe(e3), "isInSelectingRange", function() {
            var t4, r4 = e3.props, n3 = r4.day, a4 = r4.selectsStart, o2 = r4.selectsEnd, s2 = r4.selectsRange, i2 = r4.selectsDisabledDaysInRange, p2 = r4.startDate, c3 = r4.endDate, l2 = null !== (t4 = e3.props.selectingDate) && void 0 !== t4 ? t4 : e3.props.preSelection;
            return !(!(a4 || o2 || s2) || !l2 || !i2 && e3.isDisabled()) && (a4 && c3 && (te.isBefore(l2, c3) || $e(l2, c3)) ? ze(n3, l2, c3) : (o2 && p2 && (ee.isAfter(l2, p2) || $e(l2, p2)) || !(!s2 || !p2 || c3 || !ee.isAfter(l2, p2) && !$e(l2, p2))) && ze(n3, p2, l2));
          }), Me(Pe(e3), "isSelectingRangeStart", function() {
            var t4;
            if (!e3.isInSelectingRange())
              return false;
            var r4 = e3.props, n3 = r4.day, a4 = r4.startDate, o2 = r4.selectsStart, s2 = null !== (t4 = e3.props.selectingDate) && void 0 !== t4 ? t4 : e3.props.preSelection;
            return Ue(n3, o2 ? s2 : a4);
          }), Me(Pe(e3), "isSelectingRangeEnd", function() {
            var t4;
            if (!e3.isInSelectingRange())
              return false;
            var r4 = e3.props, n3 = r4.day, a4 = r4.endDate, o2 = r4.selectsEnd, s2 = r4.selectsRange, i2 = null !== (t4 = e3.props.selectingDate) && void 0 !== t4 ? t4 : e3.props.preSelection;
            return Ue(n3, o2 || s2 ? i2 : a4);
          }), Me(Pe(e3), "isRangeStart", function() {
            var t4 = e3.props, r4 = t4.day, n3 = t4.startDate, a4 = t4.endDate;
            return !(!n3 || !a4) && Ue(n3, r4);
          }), Me(Pe(e3), "isRangeEnd", function() {
            var t4 = e3.props, r4 = t4.day, n3 = t4.startDate, a4 = t4.endDate;
            return !(!n3 || !a4) && Ue(a4, r4);
          }), Me(Pe(e3), "isWeekend", function() {
            var t4 = b2.getDay(e3.props.day);
            return 0 === t4 || 6 === t4;
          }), Me(Pe(e3), "isAfterMonth", function() {
            return void 0 !== e3.props.month && (e3.props.month + 1) % 12 === C.getMonth(e3.props.day);
          }), Me(Pe(e3), "isBeforeMonth", function() {
            return void 0 !== e3.props.month && (C.getMonth(e3.props.day) + 1) % 12 === e3.props.month;
          }), Me(Pe(e3), "isCurrentDay", function() {
            return e3.isSameDay(Te());
          }), Me(Pe(e3), "isSelected", function() {
            return e3.isSameDay(e3.props.selected) || e3.isSameWeek(e3.props.selected);
          }), Me(Pe(e3), "getClassNames", function(t4) {
            var r4, n3 = e3.props.dayClassName ? e3.props.dayClassName(t4) : void 0;
            return ue.default("react-datepicker__day", n3, "react-datepicker__day--" + Le(e3.props.day, "ddd", r4), { "react-datepicker__day--disabled": e3.isDisabled(), "react-datepicker__day--excluded": e3.isExcluded(), "react-datepicker__day--selected": e3.isSelected(), "react-datepicker__day--keyboard-selected": e3.isKeyboardSelected(), "react-datepicker__day--range-start": e3.isRangeStart(), "react-datepicker__day--range-end": e3.isRangeEnd(), "react-datepicker__day--in-range": e3.isInRange(), "react-datepicker__day--in-selecting-range": e3.isInSelectingRange(), "react-datepicker__day--selecting-range-start": e3.isSelectingRangeStart(), "react-datepicker__day--selecting-range-end": e3.isSelectingRangeEnd(), "react-datepicker__day--today": e3.isCurrentDay(), "react-datepicker__day--weekend": e3.isWeekend(), "react-datepicker__day--outside-month": e3.isAfterMonth() || e3.isBeforeMonth() }, e3.getHighLightedClass("react-datepicker__day--highlighted"), e3.getHolidaysClass());
          }), Me(Pe(e3), "getAriaLabel", function() {
            var t4 = e3.props, r4 = t4.day, n3 = t4.ariaLabelPrefixWhenEnabled, a4 = void 0 === n3 ? "Choose" : n3, o2 = t4.ariaLabelPrefixWhenDisabled, s2 = void 0 === o2 ? "Not available" : o2, i2 = e3.isDisabled() || e3.isExcluded() ? s2 : a4;
            return "".concat(i2, " ").concat(Le(r4, "PPPP", e3.props.locale));
          }), Me(Pe(e3), "getTitle", function() {
            var t4 = e3.props, r4 = t4.day, n3 = t4.holidays, a4 = void 0 === n3 ? /* @__PURE__ */ new Map() : n3, o2 = t4.excludeDates, s2 = Le(r4, "MM.dd.yyyy"), i2 = [];
            return a4.has(s2) && i2.push.apply(i2, Ne(a4.get(s2).holidayNames)), e3.isExcluded() && i2.push(null == o2 ? void 0 : o2.filter(function(e4) {
              return Ue(e4.date ? e4.date : e4, r4);
            }).map(function(e4) {
              return e4.message;
            })), i2.join(", ");
          }), Me(Pe(e3), "getTabIndex", function(t4, r4) {
            var n3 = t4 || e3.props.selected, a4 = r4 || e3.props.preSelection;
            return (!e3.props.showWeekPicker || !e3.props.showWeekNumber && e3.isStartOfWeek()) && (e3.isKeyboardSelected() || e3.isSameDay(n3) && Ue(a4, n3)) ? 0 : -1;
          }), Me(Pe(e3), "handleFocusDay", function() {
            var t4, r4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n3 = false;
            0 === e3.getTabIndex() && !r4.isInputFocused && e3.isSameDay(e3.props.preSelection) && (document.activeElement && document.activeElement !== document.body || (n3 = true), e3.props.inline && !e3.props.shouldFocusDayInline && (n3 = false), e3.props.containerRef && e3.props.containerRef.current && e3.props.containerRef.current.contains(document.activeElement) && document.activeElement.classList.contains("react-datepicker__day") && (n3 = true), e3.props.monthShowsDuplicateDaysEnd && e3.isAfterMonth() && (n3 = false), e3.props.monthShowsDuplicateDaysStart && e3.isBeforeMonth() && (n3 = false)), n3 && (null === (t4 = e3.dayEl.current) || void 0 === t4 || t4.focus({ preventScroll: true }));
          }), Me(Pe(e3), "renderDayContents", function() {
            return e3.props.monthShowsDuplicateDaysEnd && e3.isAfterMonth() || e3.props.monthShowsDuplicateDaysStart && e3.isBeforeMonth() ? null : e3.props.renderDayContents ? e3.props.renderDayContents(S.getDate(e3.props.day), e3.props.day) : S.getDate(e3.props.day);
          }), Me(Pe(e3), "render", function() {
            return de.default.createElement("div", { ref: e3.dayEl, className: e3.getClassNames(e3.props.day), onKeyDown: e3.handleOnKeyDown, onClick: e3.handleClick, onMouseEnter: e3.handleMouseEnter, tabIndex: e3.getTabIndex(), "aria-label": e3.getAriaLabel(), role: "option", title: e3.getTitle(), "aria-disabled": e3.isDisabled(), "aria-current": e3.isCurrentDay() ? "date" : void 0, "aria-selected": e3.isSelected() || e3.isInRange() }, e3.renderDayContents(), "" !== e3.getTitle() && de.default.createElement("span", { className: "overlay" }, e3.getTitle()));
          }), e3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "componentDidMount", value: function() {
          this.handleFocusDay();
        } }, { key: "componentDidUpdate", value: function(e3) {
          this.handleFocusDay(e3);
        } }]), t3;
      }(de.default.Component), At = function(e2) {
        function t3() {
          var e3;
          we(this, t3);
          for (var r3 = arguments.length, n2 = new Array(r3), a3 = 0; a3 < r3; a3++)
            n2[a3] = arguments[a3];
          return Me(Pe(e3 = me(this, t3, [].concat(n2))), "weekNumberEl", de.default.createRef()), Me(Pe(e3), "handleClick", function(t4) {
            e3.props.onClick && e3.props.onClick(t4);
          }), Me(Pe(e3), "handleOnKeyDown", function(t4) {
            " " === t4.key && (t4.preventDefault(), t4.key = "Enter"), e3.props.handleOnKeyDown(t4);
          }), Me(Pe(e3), "isKeyboardSelected", function() {
            return !e3.props.disabledKeyboardNavigation && !Ue(e3.props.date, e3.props.selected) && Ue(e3.props.date, e3.props.preSelection);
          }), Me(Pe(e3), "getTabIndex", function() {
            return e3.props.showWeekPicker && e3.props.showWeekNumber && (e3.isKeyboardSelected() || Ue(e3.props.date, e3.props.selected) && Ue(e3.props.preSelection, e3.props.selected)) ? 0 : -1;
          }), Me(Pe(e3), "handleFocusWeekNumber", function() {
            var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r4 = false;
            0 === e3.getTabIndex() && !t4.isInputFocused && Ue(e3.props.date, e3.props.preSelection) && (document.activeElement && document.activeElement !== document.body || (r4 = true), e3.props.inline && !e3.props.shouldFocusDayInline && (r4 = false), e3.props.containerRef && e3.props.containerRef.current && e3.props.containerRef.current.contains(document.activeElement) && document.activeElement && document.activeElement.classList.contains("react-datepicker__week-number") && (r4 = true)), r4 && e3.weekNumberEl.current && e3.weekNumberEl.current.focus({ preventScroll: true });
          }), e3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "componentDidMount", value: function() {
          this.handleFocusWeekNumber();
        } }, { key: "componentDidUpdate", value: function(e3) {
          this.handleFocusWeekNumber(e3);
        } }, { key: "render", value: function() {
          var e3 = this.props, t4 = e3.weekNumber, r3 = e3.ariaLabelPrefix, n2 = void 0 === r3 ? "week " : r3, a3 = { "react-datepicker__week-number": true, "react-datepicker__week-number--clickable": !!e3.onClick, "react-datepicker__week-number--selected": Ue(this.props.date, this.props.selected), "react-datepicker__week-number--keyboard-selected": this.isKeyboardSelected() };
          return de.default.createElement("div", { ref: this.weekNumberEl, className: ue.default(a3), "aria-label": "".concat(n2, " ").concat(this.props.weekNumber), onClick: this.handleClick, onKeyDown: this.handleOnKeyDown, tabIndex: this.getTabIndex() }, t4);
        } }], [{ key: "defaultProps", get: function() {
          return { ariaLabelPrefix: "week " };
        } }]), t3;
      }(de.default.Component), Wt = function(e2) {
        function t3() {
          var e3;
          we(this, t3);
          for (var r3 = arguments.length, n2 = new Array(r3), a3 = 0; a3 < r3; a3++)
            n2[a3] = arguments[a3];
          return Me(Pe(e3 = me(this, t3, [].concat(n2))), "handleDayClick", function(t4, r4) {
            e3.props.onDayClick && e3.props.onDayClick(t4, r4);
          }), Me(Pe(e3), "handleDayMouseEnter", function(t4) {
            e3.props.onDayMouseEnter && e3.props.onDayMouseEnter(t4);
          }), Me(Pe(e3), "handleWeekClick", function(t4, r4, n3) {
            if ("function" == typeof e3.props.onWeekSelect && e3.props.onWeekSelect(t4, r4, n3), e3.props.showWeekPicker) {
              var a4 = We(t4, e3.props.locale, e3.props.calendarStartDay);
              e3.handleDayClick(a4, n3);
            }
            e3.props.shouldCloseOnSelect && e3.props.setOpen(false);
          }), Me(Pe(e3), "formatWeekNumber", function(t4) {
            return e3.props.formatWeekNumber ? e3.props.formatWeekNumber(t4) : function(e4, t5) {
              var r4 = t5 && Je(t5) || Ge() && Je(Ge());
              return M.getISOWeek(e4, r4 ? { locale: r4 } : null);
            }(t4);
          }), Me(Pe(e3), "renderDays", function() {
            var t4 = We(e3.props.day, e3.props.locale, e3.props.calendarStartDay), r4 = [], n3 = e3.formatWeekNumber(t4);
            if (e3.props.showWeekNumber) {
              var a4 = e3.props.onWeekSelect || e3.props.showWeekPicker ? e3.handleWeekClick.bind(Pe(e3), t4, n3) : void 0;
              r4.push(de.default.createElement(At, { key: "W", weekNumber: n3, date: t4, onClick: a4, selected: e3.props.selected, preSelection: e3.props.preSelection, ariaLabelPrefix: e3.props.ariaLabelPrefix, showWeekPicker: e3.props.showWeekPicker, showWeekNumber: e3.props.showWeekNumber, disabledKeyboardNavigation: e3.props.disabledKeyboardNavigation, handleOnKeyDown: e3.props.handleOnKeyDown, isInputFocused: e3.props.isInputFocused, containerRef: e3.props.containerRef }));
            }
            return r4.concat([0, 1, 2, 3, 4, 5, 6].map(function(r5) {
              var n4 = c2.addDays(t4, r5);
              return de.default.createElement(Ft, { ariaLabelPrefixWhenEnabled: e3.props.chooseDayAriaLabelPrefix, ariaLabelPrefixWhenDisabled: e3.props.disabledDayAriaLabelPrefix, key: n4.valueOf(), day: n4, month: e3.props.month, onClick: e3.handleDayClick.bind(Pe(e3), n4), onMouseEnter: e3.handleDayMouseEnter.bind(Pe(e3), n4), minDate: e3.props.minDate, maxDate: e3.props.maxDate, excludeDates: e3.props.excludeDates, excludeDateIntervals: e3.props.excludeDateIntervals, includeDates: e3.props.includeDates, includeDateIntervals: e3.props.includeDateIntervals, highlightDates: e3.props.highlightDates, holidays: e3.props.holidays, selectingDate: e3.props.selectingDate, filterDate: e3.props.filterDate, preSelection: e3.props.preSelection, selected: e3.props.selected, selectsStart: e3.props.selectsStart, selectsEnd: e3.props.selectsEnd, selectsRange: e3.props.selectsRange, showWeekPicker: e3.props.showWeekPicker, showWeekNumber: e3.props.showWeekNumber, selectsDisabledDaysInRange: e3.props.selectsDisabledDaysInRange, startDate: e3.props.startDate, endDate: e3.props.endDate, dayClassName: e3.props.dayClassName, renderDayContents: e3.props.renderDayContents, disabledKeyboardNavigation: e3.props.disabledKeyboardNavigation, handleOnKeyDown: e3.props.handleOnKeyDown, isInputFocused: e3.props.isInputFocused, containerRef: e3.props.containerRef, inline: e3.props.inline, shouldFocusDayInline: e3.props.shouldFocusDayInline, monthShowsDuplicateDaysEnd: e3.props.monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: e3.props.monthShowsDuplicateDaysStart, locale: e3.props.locale });
            }));
          }), Me(Pe(e3), "startOfWeek", function() {
            return We(e3.props.day, e3.props.locale, e3.props.calendarStartDay);
          }), Me(Pe(e3), "isKeyboardSelected", function() {
            return !e3.props.disabledKeyboardNavigation && !Ue(e3.startOfWeek(), e3.props.selected) && Ue(e3.startOfWeek(), e3.props.preSelection);
          }), e3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "render", value: function() {
          var e3 = { "react-datepicker__week": true, "react-datepicker__week--selected": Ue(this.startOfWeek(), this.props.selected), "react-datepicker__week--keyboard-selected": this.isKeyboardSelected() };
          return de.default.createElement("div", { className: ue.default(e3) }, this.renderDays());
        } }], [{ key: "defaultProps", get: function() {
          return { shouldCloseOnSelect: true };
        } }]), t3;
      }(de.default.Component), Qt = "two_columns", qt = "three_columns", Kt = "four_columns", Bt = Me(Me(Me({}, Qt, { grid: [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]], verticalNavigationOffset: 2 }), qt, { grid: [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]], verticalNavigationOffset: 3 }), Kt, { grid: [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], verticalNavigationOffset: 4 });
      function Ht(e2, t3) {
        return e2 ? Kt : t3 ? Qt : qt;
      }
      var jt = function(e2) {
        function t3() {
          var e3;
          we(this, t3);
          for (var r3 = arguments.length, n2 = new Array(r3), a3 = 0; a3 < r3; a3++)
            n2[a3] = arguments[a3];
          return Me(Pe(e3 = me(this, t3, [].concat(n2))), "MONTH_REFS", Ne(Array(12)).map(function() {
            return de.default.createRef();
          })), Me(Pe(e3), "QUARTER_REFS", Ne(Array(4)).map(function() {
            return de.default.createRef();
          })), Me(Pe(e3), "isDisabled", function(t4) {
            return et(t4, e3.props);
          }), Me(Pe(e3), "isExcluded", function(t4) {
            return tt(t4, e3.props);
          }), Me(Pe(e3), "handleDayClick", function(t4, r4) {
            e3.props.onDayClick && e3.props.onDayClick(t4, r4, e3.props.orderInDisplay);
          }), Me(Pe(e3), "handleDayMouseEnter", function(t4) {
            e3.props.onDayMouseEnter && e3.props.onDayMouseEnter(t4);
          }), Me(Pe(e3), "handleMouseLeave", function() {
            e3.props.onMouseLeave && e3.props.onMouseLeave();
          }), Me(Pe(e3), "isRangeStartMonth", function(t4) {
            var r4 = e3.props, n3 = r4.day, a4 = r4.startDate, o2 = r4.endDate;
            return !(!a4 || !o2) && je(x.setMonth(n3, t4), a4);
          }), Me(Pe(e3), "isRangeStartQuarter", function(t4) {
            var r4 = e3.props, n3 = r4.day, a4 = r4.startDate, o2 = r4.endDate;
            return !(!a4 || !o2) && Ve(I.setQuarter(n3, t4), a4);
          }), Me(Pe(e3), "isRangeEndMonth", function(t4) {
            var r4 = e3.props, n3 = r4.day, a4 = r4.startDate, o2 = r4.endDate;
            return !(!a4 || !o2) && je(x.setMonth(n3, t4), o2);
          }), Me(Pe(e3), "isRangeEndQuarter", function(t4) {
            var r4 = e3.props, n3 = r4.day, a4 = r4.startDate, o2 = r4.endDate;
            return !(!a4 || !o2) && Ve(I.setQuarter(n3, t4), o2);
          }), Me(Pe(e3), "isInSelectingRangeMonth", function(t4) {
            var r4, n3 = e3.props, a4 = n3.day, o2 = n3.selectsStart, s2 = n3.selectsEnd, i2 = n3.selectsRange, p2 = n3.startDate, c3 = n3.endDate, l2 = null !== (r4 = e3.props.selectingDate) && void 0 !== r4 ? r4 : e3.props.preSelection;
            return !(!(o2 || s2 || i2) || !l2) && (o2 && c3 ? nt(l2, c3, t4, a4) : (s2 && p2 || !(!i2 || !p2 || c3)) && nt(p2, l2, t4, a4));
          }), Me(Pe(e3), "isSelectingMonthRangeStart", function(t4) {
            var r4;
            if (!e3.isInSelectingRangeMonth(t4))
              return false;
            var n3 = e3.props, a4 = n3.day, o2 = n3.startDate, s2 = n3.selectsStart, i2 = x.setMonth(a4, t4), p2 = null !== (r4 = e3.props.selectingDate) && void 0 !== r4 ? r4 : e3.props.preSelection;
            return je(i2, s2 ? p2 : o2);
          }), Me(Pe(e3), "isSelectingMonthRangeEnd", function(t4) {
            var r4;
            if (!e3.isInSelectingRangeMonth(t4))
              return false;
            var n3 = e3.props, a4 = n3.day, o2 = n3.endDate, s2 = n3.selectsEnd, i2 = n3.selectsRange, p2 = x.setMonth(a4, t4), c3 = null !== (r4 = e3.props.selectingDate) && void 0 !== r4 ? r4 : e3.props.preSelection;
            return je(p2, s2 || i2 ? c3 : o2);
          }), Me(Pe(e3), "isInSelectingRangeQuarter", function(t4) {
            var r4, n3 = e3.props, a4 = n3.day, o2 = n3.selectsStart, s2 = n3.selectsEnd, i2 = n3.selectsRange, p2 = n3.startDate, c3 = n3.endDate, l2 = null !== (r4 = e3.props.selectingDate) && void 0 !== r4 ? r4 : e3.props.preSelection;
            return !(!(o2 || s2 || i2) || !l2) && (o2 && c3 ? it(l2, c3, t4, a4) : (s2 && p2 || !(!i2 || !p2 || c3)) && it(p2, l2, t4, a4));
          }), Me(Pe(e3), "isWeekInMonth", function(t4) {
            var r4 = e3.props.day, n3 = c2.addDays(t4, 6);
            return je(t4, r4) || je(n3, r4);
          }), Me(Pe(e3), "isCurrentMonth", function(e4, t4) {
            return Y.getYear(e4) === Y.getYear(Te()) && t4 === C.getMonth(Te());
          }), Me(Pe(e3), "isCurrentQuarter", function(e4, t4) {
            return Y.getYear(e4) === Y.getYear(Te()) && t4 === _.getQuarter(Te());
          }), Me(Pe(e3), "isSelectedMonth", function(e4, t4, r4) {
            return C.getMonth(r4) === t4 && Y.getYear(e4) === Y.getYear(r4);
          }), Me(Pe(e3), "isSelectedQuarter", function(e4, t4, r4) {
            return _.getQuarter(e4) === t4 && Y.getYear(e4) === Y.getYear(r4);
          }), Me(Pe(e3), "renderWeeks", function() {
            for (var t4 = [], r4 = e3.props.fixedHeight, n3 = 0, a4 = false, o2 = We(Qe(e3.props.day), e3.props.locale, e3.props.calendarStartDay); t4.push(de.default.createElement(Wt, { ariaLabelPrefix: e3.props.weekAriaLabelPrefix, chooseDayAriaLabelPrefix: e3.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: e3.props.disabledDayAriaLabelPrefix, key: n3, day: o2, month: C.getMonth(e3.props.day), onDayClick: e3.handleDayClick, onDayMouseEnter: e3.handleDayMouseEnter, onWeekSelect: e3.props.onWeekSelect, formatWeekNumber: e3.props.formatWeekNumber, locale: e3.props.locale, minDate: e3.props.minDate, maxDate: e3.props.maxDate, excludeDates: e3.props.excludeDates, excludeDateIntervals: e3.props.excludeDateIntervals, includeDates: e3.props.includeDates, includeDateIntervals: e3.props.includeDateIntervals, inline: e3.props.inline, shouldFocusDayInline: e3.props.shouldFocusDayInline, highlightDates: e3.props.highlightDates, holidays: e3.props.holidays, selectingDate: e3.props.selectingDate, filterDate: e3.props.filterDate, preSelection: e3.props.preSelection, selected: e3.props.selected, selectsStart: e3.props.selectsStart, selectsEnd: e3.props.selectsEnd, selectsRange: e3.props.selectsRange, selectsDisabledDaysInRange: e3.props.selectsDisabledDaysInRange, showWeekNumber: e3.props.showWeekNumbers, showWeekPicker: e3.props.showWeekPicker, startDate: e3.props.startDate, endDate: e3.props.endDate, dayClassName: e3.props.dayClassName, setOpen: e3.props.setOpen, shouldCloseOnSelect: e3.props.shouldCloseOnSelect, disabledKeyboardNavigation: e3.props.disabledKeyboardNavigation, renderDayContents: e3.props.renderDayContents, handleOnKeyDown: e3.props.handleOnKeyDown, isInputFocused: e3.props.isInputFocused, containerRef: e3.props.containerRef, calendarStartDay: e3.props.calendarStartDay, monthShowsDuplicateDaysEnd: e3.props.monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: e3.props.monthShowsDuplicateDaysStart })), !a4; ) {
              n3++, o2 = l.addWeeks(o2, 1);
              var s2 = r4 && n3 >= 6, i2 = !r4 && !e3.isWeekInMonth(o2);
              if (s2 || i2) {
                if (!e3.props.peekNextMonth)
                  break;
                a4 = true;
              }
            }
            return t4;
          }), Me(Pe(e3), "onMonthClick", function(t4, r4) {
            e3.handleDayClick(Qe(x.setMonth(e3.props.day, r4)), t4);
          }), Me(Pe(e3), "onMonthMouseEnter", function(t4) {
            e3.handleDayMouseEnter(Qe(x.setMonth(e3.props.day, t4)));
          }), Me(Pe(e3), "handleMonthNavigation", function(t4, r4) {
            e3.isDisabled(r4) || e3.isExcluded(r4) || (e3.props.setPreSelection(r4), e3.MONTH_REFS[t4].current && e3.MONTH_REFS[t4].current.focus());
          }), Me(Pe(e3), "onMonthKeyDown", function(t4, r4) {
            var n3 = e3.props, a4 = n3.selected, o2 = n3.preSelection, s2 = n3.disabledKeyboardNavigation, i2 = n3.showTwoColumnMonthYearPicker, p2 = n3.showFourColumnMonthYearPicker, c3 = n3.setPreSelection, l2 = t4.key;
            if ("Tab" !== l2 && t4.preventDefault(), !s2) {
              var u2 = Ht(p2, i2), h2 = Bt[u2].verticalNavigationOffset, f2 = Bt[u2].grid;
              switch (l2) {
                case "Enter":
                  e3.onMonthClick(t4, r4), c3(a4);
                  break;
                case "ArrowRight":
                  e3.handleMonthNavigation(11 === r4 ? 0 : r4 + 1, d.addMonths(o2, 1));
                  break;
                case "ArrowLeft":
                  e3.handleMonthNavigation(0 === r4 ? 11 : r4 - 1, y.subMonths(o2, 1));
                  break;
                case "ArrowUp":
                  e3.handleMonthNavigation(f2[0].includes(r4) ? r4 + 12 - h2 : r4 - h2, y.subMonths(o2, h2));
                  break;
                case "ArrowDown":
                  e3.handleMonthNavigation(f2[f2.length - 1].includes(r4) ? r4 - 12 + h2 : r4 + h2, d.addMonths(o2, h2));
              }
            }
          }), Me(Pe(e3), "onQuarterClick", function(t4, r4) {
            e3.handleDayClick(Ke(I.setQuarter(e3.props.day, r4)), t4);
          }), Me(Pe(e3), "onQuarterMouseEnter", function(t4) {
            e3.handleDayMouseEnter(Ke(I.setQuarter(e3.props.day, t4)));
          }), Me(Pe(e3), "handleQuarterNavigation", function(t4, r4) {
            e3.isDisabled(r4) || e3.isExcluded(r4) || (e3.props.setPreSelection(r4), e3.QUARTER_REFS[t4 - 1].current && e3.QUARTER_REFS[t4 - 1].current.focus());
          }), Me(Pe(e3), "onQuarterKeyDown", function(t4, r4) {
            var n3 = t4.key;
            if (!e3.props.disabledKeyboardNavigation)
              switch (n3) {
                case "Enter":
                  e3.onQuarterClick(t4, r4), e3.props.setPreSelection(e3.props.selected);
                  break;
                case "ArrowRight":
                  e3.handleQuarterNavigation(4 === r4 ? 1 : r4 + 1, u.addQuarters(e3.props.preSelection, 1));
                  break;
                case "ArrowLeft":
                  e3.handleQuarterNavigation(1 === r4 ? 4 : r4 - 1, g.subQuarters(e3.props.preSelection, 1));
              }
          }), Me(Pe(e3), "getMonthClassNames", function(t4) {
            var r4 = e3.props, n3 = r4.day, a4 = r4.startDate, o2 = r4.endDate, s2 = r4.selected, i2 = r4.minDate, p2 = r4.maxDate, c3 = r4.preSelection, l2 = r4.monthClassName, d2 = r4.excludeDates, u2 = r4.includeDates, h2 = l2 ? l2(x.setMonth(n3, t4)) : void 0, f2 = x.setMonth(n3, t4);
            return ue.default("react-datepicker__month-text", "react-datepicker__month-".concat(t4), h2, { "react-datepicker__month-text--disabled": (i2 || p2 || d2 || u2) && rt(f2, e3.props), "react-datepicker__month-text--selected": e3.isSelectedMonth(n3, t4, s2), "react-datepicker__month-text--keyboard-selected": !e3.props.disabledKeyboardNavigation && C.getMonth(c3) === t4, "react-datepicker__month-text--in-selecting-range": e3.isInSelectingRangeMonth(t4), "react-datepicker__month-text--in-range": nt(a4, o2, t4, n3), "react-datepicker__month-text--range-start": e3.isRangeStartMonth(t4), "react-datepicker__month-text--range-end": e3.isRangeEndMonth(t4), "react-datepicker__month-text--selecting-range-start": e3.isSelectingMonthRangeStart(t4), "react-datepicker__month-text--selecting-range-end": e3.isSelectingMonthRangeEnd(t4), "react-datepicker__month-text--today": e3.isCurrentMonth(n3, t4) });
          }), Me(Pe(e3), "getTabIndex", function(t4) {
            var r4 = C.getMonth(e3.props.preSelection);
            return e3.props.disabledKeyboardNavigation || t4 !== r4 ? "-1" : "0";
          }), Me(Pe(e3), "getQuarterTabIndex", function(t4) {
            var r4 = _.getQuarter(e3.props.preSelection);
            return e3.props.disabledKeyboardNavigation || t4 !== r4 ? "-1" : "0";
          }), Me(Pe(e3), "getAriaLabel", function(t4) {
            var r4 = e3.props, n3 = r4.chooseDayAriaLabelPrefix, a4 = void 0 === n3 ? "Choose" : n3, o2 = r4.disabledDayAriaLabelPrefix, s2 = void 0 === o2 ? "Not available" : o2, i2 = r4.day, p2 = x.setMonth(i2, t4), c3 = e3.isDisabled(p2) || e3.isExcluded(p2) ? s2 : a4;
            return "".concat(c3, " ").concat(Le(p2, "MMMM yyyy"));
          }), Me(Pe(e3), "getQuarterClassNames", function(t4) {
            var r4 = e3.props, n3 = r4.day, a4 = r4.startDate, o2 = r4.endDate, s2 = r4.selected, i2 = r4.minDate, p2 = r4.maxDate, c3 = r4.preSelection, l2 = r4.disabledKeyboardNavigation;
            return ue.default("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(t4), { "react-datepicker__quarter-text--disabled": (i2 || p2) && at(I.setQuarter(n3, t4), e3.props), "react-datepicker__quarter-text--selected": e3.isSelectedQuarter(n3, t4, s2), "react-datepicker__quarter-text--keyboard-selected": !l2 && _.getQuarter(c3) === t4, "react-datepicker__quarter-text--in-selecting-range": e3.isInSelectingRangeQuarter(t4), "react-datepicker__quarter-text--in-range": it(a4, o2, t4, n3), "react-datepicker__quarter-text--range-start": e3.isRangeStartQuarter(t4), "react-datepicker__quarter-text--range-end": e3.isRangeEndQuarter(t4) });
          }), Me(Pe(e3), "getMonthContent", function(t4) {
            var r4 = e3.props, n3 = r4.showFullMonthYearPicker, a4 = r4.renderMonthContent, o2 = r4.locale, s2 = r4.day, i2 = Ze(t4, o2), p2 = Xe(t4, o2);
            return a4 ? a4(t4, i2, p2, s2) : n3 ? p2 : i2;
          }), Me(Pe(e3), "getQuarterContent", function(t4) {
            var r4 = e3.props, n3 = r4.renderQuarterContent, a4 = function(e4, t5) {
              return Le(I.setQuarter(Te(), e4), "QQQ", t5);
            }(t4, r4.locale);
            return n3 ? n3(t4, a4) : a4;
          }), Me(Pe(e3), "renderMonths", function() {
            var t4 = e3.props, r4 = t4.showTwoColumnMonthYearPicker, n3 = t4.showFourColumnMonthYearPicker, a4 = t4.day, o2 = t4.selected;
            return Bt[Ht(n3, r4)].grid.map(function(t5, r5) {
              return de.default.createElement("div", { className: "react-datepicker__month-wrapper", key: r5 }, t5.map(function(t6, r6) {
                return de.default.createElement("div", { ref: e3.MONTH_REFS[t6], key: r6, onClick: function(r7) {
                  e3.onMonthClick(r7, t6);
                }, onKeyDown: function(r7) {
                  e3.onMonthKeyDown(r7, t6);
                }, onMouseEnter: function() {
                  return e3.onMonthMouseEnter(t6);
                }, tabIndex: e3.getTabIndex(t6), className: e3.getMonthClassNames(t6), role: "option", "aria-label": e3.getAriaLabel(t6), "aria-current": e3.isCurrentMonth(a4, t6) ? "date" : void 0, "aria-selected": e3.isSelectedMonth(a4, t6, o2) }, e3.getMonthContent(t6));
              }));
            });
          }), Me(Pe(e3), "renderQuarters", function() {
            var t4 = e3.props, r4 = t4.day, n3 = t4.selected;
            return de.default.createElement("div", { className: "react-datepicker__quarter-wrapper" }, [1, 2, 3, 4].map(function(t5, a4) {
              return de.default.createElement("div", { key: a4, ref: e3.QUARTER_REFS[a4], role: "option", onClick: function(r5) {
                e3.onQuarterClick(r5, t5);
              }, onKeyDown: function(r5) {
                e3.onQuarterKeyDown(r5, t5);
              }, onMouseEnter: function() {
                return e3.onQuarterMouseEnter(t5);
              }, className: e3.getQuarterClassNames(t5), "aria-selected": e3.isSelectedQuarter(r4, t5, n3), tabIndex: e3.getQuarterTabIndex(t5), "aria-current": e3.isCurrentQuarter(r4, t5) ? "date" : void 0 }, e3.getQuarterContent(t5));
            }));
          }), Me(Pe(e3), "getClassNames", function() {
            var t4 = e3.props, r4 = t4.selectingDate, n3 = t4.selectsStart, a4 = t4.selectsEnd, o2 = t4.showMonthYearPicker, s2 = t4.showQuarterYearPicker, i2 = t4.showWeekPicker;
            return ue.default("react-datepicker__month", { "react-datepicker__month--selecting-range": r4 && (n3 || a4) }, { "react-datepicker__monthPicker": o2 }, { "react-datepicker__quarterPicker": s2 }, { "react-datepicker__weekPicker": i2 });
          }), e3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "render", value: function() {
          var e3 = this.props, t4 = e3.showMonthYearPicker, r3 = e3.showQuarterYearPicker, n2 = e3.day, a3 = e3.ariaLabelPrefix, o2 = void 0 === a3 ? "month " : a3;
          return de.default.createElement("div", { className: this.getClassNames(), onMouseLeave: this.handleMouseLeave, "aria-label": "".concat(o2, " ").concat(Le(n2, "yyyy-MM")), role: "listbox" }, t4 ? this.renderMonths() : r3 ? this.renderQuarters() : this.renderWeeks());
        } }]), t3;
      }(de.default.Component), Vt = function(e2) {
        function t3() {
          var e3;
          we(this, t3);
          for (var r3 = arguments.length, n2 = new Array(r3), a3 = 0; a3 < r3; a3++)
            n2[a3] = arguments[a3];
          return Me(Pe(e3 = me(this, t3, [].concat(n2))), "state", { height: null }), Me(Pe(e3), "scrollToTheSelectedTime", function() {
            requestAnimationFrame(function() {
              e3.list && (e3.list.scrollTop = e3.centerLi && t3.calcCenterPosition(e3.props.monthRef ? e3.props.monthRef.clientHeight - e3.header.clientHeight : e3.list.clientHeight, e3.centerLi));
            });
          }), Me(Pe(e3), "handleClick", function(t4) {
            (e3.props.minTime || e3.props.maxTime) && dt(t4, e3.props) || (e3.props.excludeTimes || e3.props.includeTimes || e3.props.filterTime) && lt(t4, e3.props) || e3.props.onChange(t4);
          }), Me(Pe(e3), "isSelectedTime", function(t4) {
            return e3.props.selected && (r4 = e3.props.selected, n3 = t4, St(r4).getTime() === St(n3).getTime());
            var r4, n3;
          }), Me(Pe(e3), "isDisabledTime", function(t4) {
            return (e3.props.minTime || e3.props.maxTime) && dt(t4, e3.props) || (e3.props.excludeTimes || e3.props.includeTimes || e3.props.filterTime) && lt(t4, e3.props);
          }), Me(Pe(e3), "liClasses", function(t4) {
            var r4 = ["react-datepicker__time-list-item", e3.props.timeClassName ? e3.props.timeClassName(t4) : void 0];
            return e3.isSelectedTime(t4) && r4.push("react-datepicker__time-list-item--selected"), e3.isDisabledTime(t4) && r4.push("react-datepicker__time-list-item--disabled"), e3.props.injectTimes && (60 * w.getHours(t4) + k.getMinutes(t4)) % e3.props.intervals != 0 && r4.push("react-datepicker__time-list-item--injected"), r4.join(" ");
          }), Me(Pe(e3), "handleOnKeyDown", function(t4, r4) {
            " " === t4.key && (t4.preventDefault(), t4.key = "Enter"), "ArrowUp" !== t4.key && "ArrowLeft" !== t4.key || !t4.target.previousSibling || (t4.preventDefault(), t4.target.previousSibling.focus()), "ArrowDown" !== t4.key && "ArrowRight" !== t4.key || !t4.target.nextSibling || (t4.preventDefault(), t4.target.nextSibling.focus()), "Enter" === t4.key && e3.handleClick(r4), e3.props.handleOnKeyDown(t4);
          }), Me(Pe(e3), "renderTimes", function() {
            for (var t4, r4 = [], n3 = e3.props.format ? e3.props.format : "p", a4 = e3.props.intervals, o2 = e3.props.selected || e3.props.openToDate || Te(), s2 = (t4 = o2, Q.startOfDay(t4)), p2 = e3.props.injectTimes && e3.props.injectTimes.sort(function(e4, t5) {
              return e4 - t5;
            }), c3 = 60 * function(e4) {
              var t5 = new Date(e4.getFullYear(), e4.getMonth(), e4.getDate()), r5 = new Date(e4.getFullYear(), e4.getMonth(), e4.getDate(), 24);
              return Math.round((+r5 - +t5) / 36e5);
            }(o2), l2 = c3 / a4, d2 = 0; d2 < l2; d2++) {
              var u2 = i.addMinutes(s2, d2 * a4);
              if (r4.push(u2), p2) {
                var h2 = kt(s2, u2, d2, a4, p2);
                r4 = r4.concat(h2);
              }
            }
            var f2 = r4.reduce(function(e4, t5) {
              return t5.getTime() <= o2.getTime() ? t5 : e4;
            }, r4[0]);
            return r4.map(function(t5, r5) {
              return de.default.createElement("li", { key: r5, onClick: e3.handleClick.bind(Pe(e3), t5), className: e3.liClasses(t5), ref: function(r6) {
                t5 === f2 && (e3.centerLi = r6);
              }, onKeyDown: function(r6) {
                e3.handleOnKeyDown(r6, t5);
              }, tabIndex: t5 === f2 ? 0 : -1, role: "option", "aria-selected": e3.isSelectedTime(t5) ? "true" : void 0, "aria-disabled": e3.isDisabledTime(t5) ? "true" : void 0 }, Le(t5, n3, e3.props.locale));
            });
          }), e3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "componentDidMount", value: function() {
          this.scrollToTheSelectedTime(), this.props.monthRef && this.header && this.setState({ height: this.props.monthRef.clientHeight - this.header.clientHeight });
        } }, { key: "render", value: function() {
          var e3 = this, t4 = this.state.height;
          return de.default.createElement("div", { className: "react-datepicker__time-container ".concat(this.props.todayButton ? "react-datepicker__time-container--with-today-button" : "") }, de.default.createElement("div", { className: "react-datepicker__header react-datepicker__header--time ".concat(this.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : ""), ref: function(t5) {
            e3.header = t5;
          } }, de.default.createElement("div", { className: "react-datepicker-time__header" }, this.props.timeCaption)), de.default.createElement("div", { className: "react-datepicker__time" }, de.default.createElement("div", { className: "react-datepicker__time-box" }, de.default.createElement("ul", { className: "react-datepicker__time-list", ref: function(t5) {
            e3.list = t5;
          }, style: t4 ? { height: t4 } : {}, role: "listbox", "aria-label": this.props.timeCaption }, this.renderTimes()))));
        } }], [{ key: "defaultProps", get: function() {
          return { intervals: 30, onTimeChange: function() {
          }, todayButton: null, timeCaption: "Time" };
        } }]), t3;
      }(de.default.Component);
      Me(Vt, "calcCenterPosition", function(e2, t3) {
        return t3.offsetTop - (e2 / 2 - t3.clientHeight / 2);
      });
      var Ut = function(e2) {
        function t3(e3) {
          var r3;
          return we(this, t3), Me(Pe(r3 = me(this, t3, [e3])), "YEAR_REFS", Ne(Array(r3.props.yearItemNumber)).map(function() {
            return de.default.createRef();
          })), Me(Pe(r3), "isDisabled", function(e4) {
            return et(e4, r3.props);
          }), Me(Pe(r3), "isExcluded", function(e4) {
            return tt(e4, r3.props);
          }), Me(Pe(r3), "selectingDate", function() {
            var e4;
            return null !== (e4 = r3.props.selectingDate) && void 0 !== e4 ? e4 : r3.props.preSelection;
          }), Me(Pe(r3), "updateFocusOnPaginate", function(e4) {
            var t4 = function() {
              this.YEAR_REFS[e4].current.focus();
            }.bind(Pe(r3));
            window.requestAnimationFrame(t4);
          }), Me(Pe(r3), "handleYearClick", function(e4, t4) {
            r3.props.onDayClick && r3.props.onDayClick(e4, t4);
          }), Me(Pe(r3), "handleYearNavigation", function(e4, t4) {
            var n2 = r3.props, a3 = n2.date, o2 = n2.yearItemNumber, s2 = bt(a3, o2).startPeriod;
            r3.isDisabled(t4) || r3.isExcluded(t4) || (r3.props.setPreSelection(t4), e4 - s2 == -1 ? r3.updateFocusOnPaginate(o2 - 1) : e4 - s2 === o2 ? r3.updateFocusOnPaginate(0) : r3.YEAR_REFS[e4 - s2].current.focus());
          }), Me(Pe(r3), "isSameDay", function(e4, t4) {
            return Ue(e4, t4);
          }), Me(Pe(r3), "isCurrentYear", function(e4) {
            return e4 === Y.getYear(Te());
          }), Me(Pe(r3), "isRangeStart", function(e4) {
            return r3.props.startDate && r3.props.endDate && He(T.setYear(Te(), e4), r3.props.startDate);
          }), Me(Pe(r3), "isRangeEnd", function(e4) {
            return r3.props.startDate && r3.props.endDate && He(T.setYear(Te(), e4), r3.props.endDate);
          }), Me(Pe(r3), "isInRange", function(e4) {
            return ot(e4, r3.props.startDate, r3.props.endDate);
          }), Me(Pe(r3), "isInSelectingRange", function(e4) {
            var t4 = r3.props, n2 = t4.selectsStart, a3 = t4.selectsEnd, o2 = t4.selectsRange, s2 = t4.startDate, i2 = t4.endDate;
            return !(!(n2 || a3 || o2) || !r3.selectingDate()) && (n2 && i2 ? ot(e4, r3.selectingDate(), i2) : (a3 && s2 || !(!o2 || !s2 || i2)) && ot(e4, s2, r3.selectingDate()));
          }), Me(Pe(r3), "isSelectingRangeStart", function(e4) {
            if (!r3.isInSelectingRange(e4))
              return false;
            var t4 = r3.props, n2 = t4.startDate, a3 = t4.selectsStart, o2 = T.setYear(Te(), e4);
            return He(o2, a3 ? r3.selectingDate() : n2);
          }), Me(Pe(r3), "isSelectingRangeEnd", function(e4) {
            if (!r3.isInSelectingRange(e4))
              return false;
            var t4 = r3.props, n2 = t4.endDate, a3 = t4.selectsEnd, o2 = t4.selectsRange, s2 = T.setYear(Te(), e4);
            return He(s2, a3 || o2 ? r3.selectingDate() : n2);
          }), Me(Pe(r3), "isKeyboardSelected", function(e4) {
            var t4 = qe(T.setYear(r3.props.date, e4));
            return !r3.props.disabledKeyboardNavigation && !r3.props.inline && !Ue(t4, qe(r3.props.selected)) && Ue(t4, qe(r3.props.preSelection));
          }), Me(Pe(r3), "onYearClick", function(e4, t4) {
            var n2 = r3.props.date;
            r3.handleYearClick(qe(T.setYear(n2, t4)), e4);
          }), Me(Pe(r3), "onYearKeyDown", function(e4, t4) {
            var n2 = e4.key;
            if (!r3.props.disabledKeyboardNavigation)
              switch (n2) {
                case "Enter":
                  r3.onYearClick(e4, t4), r3.props.setPreSelection(r3.props.selected);
                  break;
                case "ArrowRight":
                  r3.handleYearNavigation(t4 + 1, h.addYears(r3.props.preSelection, 1));
                  break;
                case "ArrowLeft":
                  r3.handleYearNavigation(t4 - 1, D.subYears(r3.props.preSelection, 1));
              }
          }), Me(Pe(r3), "getYearClassNames", function(e4) {
            var t4 = r3.props, n2 = t4.minDate, a3 = t4.maxDate, o2 = t4.selected, s2 = t4.excludeDates, i2 = t4.includeDates, p2 = t4.filterDate;
            return ue.default("react-datepicker__year-text", { "react-datepicker__year-text--selected": e4 === Y.getYear(o2), "react-datepicker__year-text--disabled": (n2 || a3 || s2 || i2 || p2) && st(e4, r3.props), "react-datepicker__year-text--keyboard-selected": r3.isKeyboardSelected(e4), "react-datepicker__year-text--range-start": r3.isRangeStart(e4), "react-datepicker__year-text--range-end": r3.isRangeEnd(e4), "react-datepicker__year-text--in-range": r3.isInRange(e4), "react-datepicker__year-text--in-selecting-range": r3.isInSelectingRange(e4), "react-datepicker__year-text--selecting-range-start": r3.isSelectingRangeStart(e4), "react-datepicker__year-text--selecting-range-end": r3.isSelectingRangeEnd(e4), "react-datepicker__year-text--today": r3.isCurrentYear(e4) });
          }), Me(Pe(r3), "getYearTabIndex", function(e4) {
            return r3.props.disabledKeyboardNavigation ? "-1" : e4 === Y.getYear(r3.props.preSelection) ? "0" : "-1";
          }), Me(Pe(r3), "getYearContainerClassNames", function() {
            var e4 = r3.props, t4 = e4.selectingDate, n2 = e4.selectsStart, a3 = e4.selectsEnd, o2 = e4.selectsRange;
            return ue.default("react-datepicker__year", { "react-datepicker__year--selecting-range": t4 && (n2 || a3 || o2) });
          }), Me(Pe(r3), "getYearContent", function(e4) {
            return r3.props.renderYearContent ? r3.props.renderYearContent(e4) : e4;
          }), r3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "render", value: function() {
          for (var e3 = this, t4 = [], r3 = this.props, n2 = r3.date, a3 = r3.yearItemNumber, o2 = r3.onYearMouseEnter, s2 = r3.onYearMouseLeave, i2 = bt(n2, a3), p2 = i2.startPeriod, c3 = i2.endPeriod, l2 = function(r4) {
            t4.push(de.default.createElement("div", { ref: e3.YEAR_REFS[r4 - p2], onClick: function(t5) {
              e3.onYearClick(t5, r4);
            }, onKeyDown: function(t5) {
              e3.onYearKeyDown(t5, r4);
            }, tabIndex: e3.getYearTabIndex(r4), className: e3.getYearClassNames(r4), onMouseEnter: function(e4) {
              return o2(e4, r4);
            }, onMouseLeave: function(e4) {
              return s2(e4, r4);
            }, key: r4, "aria-current": e3.isCurrentYear(r4) ? "date" : void 0 }, e3.getYearContent(r4)));
          }, d2 = p2; d2 <= c3; d2++)
            l2(d2);
          return de.default.createElement("div", { className: this.getYearContainerClassNames() }, de.default.createElement("div", { className: "react-datepicker__year-wrapper", onMouseLeave: this.props.clearSelectingDate }, t4));
        } }]), t3;
      }(de.default.Component), $t = function(e2) {
        function t3(e3) {
          var r3;
          return we(this, t3), Me(Pe(r3 = me(this, t3, [e3])), "onTimeChange", function(e4) {
            r3.setState({ time: e4 });
            var t4 = r3.props.date, n2 = t4 instanceof Date && !isNaN(t4) ? t4 : /* @__PURE__ */ new Date();
            n2.setHours(e4.split(":")[0]), n2.setMinutes(e4.split(":")[1]), r3.props.onChange(n2);
          }), Me(Pe(r3), "renderTimeInput", function() {
            var e4 = r3.state.time, t4 = r3.props, n2 = t4.date, a3 = t4.timeString, o2 = t4.customTimeInput;
            return o2 ? de.default.cloneElement(o2, { date: n2, value: e4, onChange: r3.onTimeChange }) : de.default.createElement("input", { type: "time", className: "react-datepicker-time__input", placeholder: "Time", name: "time-input", required: true, value: e4, onChange: function(e5) {
              r3.onTimeChange(e5.target.value || a3);
            } });
          }), r3.state = { time: r3.props.timeString }, r3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "render", value: function() {
          return de.default.createElement("div", { className: "react-datepicker__input-time-container" }, de.default.createElement("div", { className: "react-datepicker-time__caption" }, this.props.timeInputLabel), de.default.createElement("div", { className: "react-datepicker-time__input-container" }, de.default.createElement("div", { className: "react-datepicker-time__input" }, this.renderTimeInput())));
        } }], [{ key: "getDerivedStateFromProps", value: function(e3, t4) {
          return e3.timeString !== t4.time ? { time: e3.timeString } : null;
        } }]), t3;
      }(de.default.Component);
      function zt(e2) {
        var t3 = e2.className, r3 = e2.children;
        return de.default.createElement("div", { className: t3 }, r3);
      }
      var Gt = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"], Jt = function(e2) {
        function t3(e3) {
          var r3;
          return we(this, t3), Me(Pe(r3 = me(this, t3, [e3])), "handleClickOutside", function(e4) {
            r3.props.onClickOutside(e4);
          }), Me(Pe(r3), "setClickOutsideRef", function() {
            return r3.containerRef.current;
          }), Me(Pe(r3), "handleDropdownFocus", function(e4) {
            (function() {
              var e5 = ((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).className || "").split(/\s+/);
              return Gt.some(function(t4) {
                return e5.indexOf(t4) >= 0;
              });
            })(e4.target) && r3.props.onDropdownFocus();
          }), Me(Pe(r3), "getDateInView", function() {
            var e4 = r3.props, t4 = e4.preSelection, n2 = e4.selected, a3 = e4.openToDate, o2 = yt(r3.props), s2 = gt(r3.props), i2 = Te(), p2 = a3 || n2 || t4;
            return p2 || (o2 && te.isBefore(i2, o2) ? o2 : s2 && ee.isAfter(i2, s2) ? s2 : i2);
          }), Me(Pe(r3), "increaseMonth", function() {
            r3.setState(function(e4) {
              var t4 = e4.date;
              return { date: d.addMonths(t4, 1) };
            }, function() {
              return r3.handleMonthChange(r3.state.date);
            });
          }), Me(Pe(r3), "decreaseMonth", function() {
            r3.setState(function(e4) {
              var t4 = e4.date;
              return { date: y.subMonths(t4, 1) };
            }, function() {
              return r3.handleMonthChange(r3.state.date);
            });
          }), Me(Pe(r3), "handleDayClick", function(e4, t4, n2) {
            r3.props.onSelect(e4, t4, n2), r3.props.setPreSelection && r3.props.setPreSelection(e4);
          }), Me(Pe(r3), "handleDayMouseEnter", function(e4) {
            r3.setState({ selectingDate: e4 }), r3.props.onDayMouseEnter && r3.props.onDayMouseEnter(e4);
          }), Me(Pe(r3), "handleMonthMouseLeave", function() {
            r3.setState({ selectingDate: null }), r3.props.onMonthMouseLeave && r3.props.onMonthMouseLeave();
          }), Me(Pe(r3), "handleYearMouseEnter", function(e4, t4) {
            r3.setState({ selectingDate: T.setYear(Te(), t4) }), r3.props.onYearMouseEnter && r3.props.onYearMouseEnter(e4, t4);
          }), Me(Pe(r3), "handleYearMouseLeave", function(e4, t4) {
            r3.props.onYearMouseLeave && r3.props.onYearMouseLeave(e4, t4);
          }), Me(Pe(r3), "handleYearChange", function(e4) {
            r3.props.onYearChange && (r3.props.onYearChange(e4), r3.setState({ isRenderAriaLiveMessage: true })), r3.props.adjustDateOnChange && (r3.props.onSelect && r3.props.onSelect(e4), r3.props.setOpen && r3.props.setOpen(true)), r3.props.setPreSelection && r3.props.setPreSelection(e4);
          }), Me(Pe(r3), "handleMonthChange", function(e4) {
            r3.handleCustomMonthChange(e4), r3.props.adjustDateOnChange && (r3.props.onSelect && r3.props.onSelect(e4), r3.props.setOpen && r3.props.setOpen(true)), r3.props.setPreSelection && r3.props.setPreSelection(e4);
          }), Me(Pe(r3), "handleCustomMonthChange", function(e4) {
            r3.props.onMonthChange && (r3.props.onMonthChange(e4), r3.setState({ isRenderAriaLiveMessage: true }));
          }), Me(Pe(r3), "handleMonthYearChange", function(e4) {
            r3.handleYearChange(e4), r3.handleMonthChange(e4);
          }), Me(Pe(r3), "changeYear", function(e4) {
            r3.setState(function(t4) {
              var r4 = t4.date;
              return { date: T.setYear(r4, e4) };
            }, function() {
              return r3.handleYearChange(r3.state.date);
            });
          }), Me(Pe(r3), "changeMonth", function(e4) {
            r3.setState(function(t4) {
              var r4 = t4.date;
              return { date: x.setMonth(r4, e4) };
            }, function() {
              return r3.handleMonthChange(r3.state.date);
            });
          }), Me(Pe(r3), "changeMonthYear", function(e4) {
            r3.setState(function(t4) {
              var r4 = t4.date;
              return { date: T.setYear(x.setMonth(r4, C.getMonth(e4)), Y.getYear(e4)) };
            }, function() {
              return r3.handleMonthYearChange(r3.state.date);
            });
          }), Me(Pe(r3), "header", function() {
            var e4 = We(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : r3.state.date, r3.props.locale, r3.props.calendarStartDay), t4 = [];
            return r3.props.showWeekNumbers && t4.push(de.default.createElement("div", { key: "W", className: "react-datepicker__day-name" }, r3.props.weekLabel || "#")), t4.concat([0, 1, 2, 3, 4, 5, 6].map(function(t5) {
              var n2 = c2.addDays(e4, t5), a3 = r3.formatWeekday(n2, r3.props.locale), o2 = r3.props.weekDayClassName ? r3.props.weekDayClassName(n2) : void 0;
              return de.default.createElement("div", { key: t5, className: ue.default("react-datepicker__day-name", o2) }, a3);
            }));
          }), Me(Pe(r3), "formatWeekday", function(e4, t4) {
            return r3.props.formatWeekDay ? function(e5, t5, r4) {
              return t5(Le(e5, "EEEE", r4));
            }(e4, r3.props.formatWeekDay, t4) : r3.props.useWeekdaysShort ? function(e5, t5) {
              return Le(e5, "EEE", t5);
            }(e4, t4) : function(e5, t5) {
              return Le(e5, "EEEEEE", t5);
            }(e4, t4);
          }), Me(Pe(r3), "decreaseYear", function() {
            r3.setState(function(e4) {
              var t4 = e4.date;
              return { date: D.subYears(t4, r3.props.showYearPicker ? r3.props.yearItemNumber : 1) };
            }, function() {
              return r3.handleYearChange(r3.state.date);
            });
          }), Me(Pe(r3), "clearSelectingDate", function() {
            r3.setState({ selectingDate: null });
          }), Me(Pe(r3), "renderPreviousButton", function() {
            if (!r3.props.renderCustomHeader) {
              var e4;
              switch (true) {
                case r3.props.showMonthYearPicker:
                  e4 = ft(r3.state.date, r3.props);
                  break;
                case r3.props.showYearPicker:
                  e4 = function(e5) {
                    var t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r4 = t5.minDate, n3 = t5.yearItemNumber, a4 = void 0 === n3 ? xe : n3, o3 = bt(qe(D.subYears(e5, a4)), a4).endPeriod, s3 = r4 && Y.getYear(r4);
                    return s3 && s3 > o3 || false;
                  }(r3.state.date, r3.props);
                  break;
                default:
                  e4 = ut(r3.state.date, r3.props);
              }
              if ((r3.props.forceShowMonthNavigation || r3.props.showDisabledMonthNavigation || !e4) && !r3.props.showTimeSelectOnly) {
                var t4 = ["react-datepicker__navigation", "react-datepicker__navigation--previous"], n2 = r3.decreaseMonth;
                (r3.props.showMonthYearPicker || r3.props.showQuarterYearPicker || r3.props.showYearPicker) && (n2 = r3.decreaseYear), e4 && r3.props.showDisabledMonthNavigation && (t4.push("react-datepicker__navigation--previous--disabled"), n2 = null);
                var a3 = r3.props.showMonthYearPicker || r3.props.showQuarterYearPicker || r3.props.showYearPicker, o2 = r3.props, s2 = o2.previousMonthButtonLabel, i2 = o2.previousYearButtonLabel, p2 = r3.props, c3 = p2.previousMonthAriaLabel, l2 = void 0 === c3 ? "string" == typeof s2 ? s2 : "Previous Month" : c3, d2 = p2.previousYearAriaLabel, u2 = void 0 === d2 ? "string" == typeof i2 ? i2 : "Previous Year" : d2;
                return de.default.createElement("button", { type: "button", className: t4.join(" "), onClick: n2, onKeyDown: r3.props.handleOnKeyDown, "aria-label": a3 ? u2 : l2 }, de.default.createElement("span", { className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--previous"].join(" ") }, a3 ? r3.props.previousYearButtonLabel : r3.props.previousMonthButtonLabel));
              }
            }
          }), Me(Pe(r3), "increaseYear", function() {
            r3.setState(function(e4) {
              var t4 = e4.date;
              return { date: h.addYears(t4, r3.props.showYearPicker ? r3.props.yearItemNumber : 1) };
            }, function() {
              return r3.handleYearChange(r3.state.date);
            });
          }), Me(Pe(r3), "renderNextButton", function() {
            if (!r3.props.renderCustomHeader) {
              var e4;
              switch (true) {
                case r3.props.showMonthYearPicker:
                  e4 = mt(r3.state.date, r3.props);
                  break;
                case r3.props.showYearPicker:
                  e4 = function(e5) {
                    var t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r4 = t5.maxDate, n3 = t5.yearItemNumber, a4 = void 0 === n3 ? xe : n3, o3 = bt(h.addYears(e5, a4), a4).startPeriod, s3 = r4 && Y.getYear(r4);
                    return s3 && s3 < o3 || false;
                  }(r3.state.date, r3.props);
                  break;
                default:
                  e4 = ht(r3.state.date, r3.props);
              }
              if ((r3.props.forceShowMonthNavigation || r3.props.showDisabledMonthNavigation || !e4) && !r3.props.showTimeSelectOnly) {
                var t4 = ["react-datepicker__navigation", "react-datepicker__navigation--next"];
                r3.props.showTimeSelect && t4.push("react-datepicker__navigation--next--with-time"), r3.props.todayButton && t4.push("react-datepicker__navigation--next--with-today-button");
                var n2 = r3.increaseMonth;
                (r3.props.showMonthYearPicker || r3.props.showQuarterYearPicker || r3.props.showYearPicker) && (n2 = r3.increaseYear), e4 && r3.props.showDisabledMonthNavigation && (t4.push("react-datepicker__navigation--next--disabled"), n2 = null);
                var a3 = r3.props.showMonthYearPicker || r3.props.showQuarterYearPicker || r3.props.showYearPicker, o2 = r3.props, s2 = o2.nextMonthButtonLabel, i2 = o2.nextYearButtonLabel, p2 = r3.props, c3 = p2.nextMonthAriaLabel, l2 = void 0 === c3 ? "string" == typeof s2 ? s2 : "Next Month" : c3, d2 = p2.nextYearAriaLabel, u2 = void 0 === d2 ? "string" == typeof i2 ? i2 : "Next Year" : d2;
                return de.default.createElement("button", { type: "button", className: t4.join(" "), onClick: n2, onKeyDown: r3.props.handleOnKeyDown, "aria-label": a3 ? u2 : l2 }, de.default.createElement("span", { className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--next"].join(" ") }, a3 ? r3.props.nextYearButtonLabel : r3.props.nextMonthButtonLabel));
              }
            }
          }), Me(Pe(r3), "renderCurrentMonth", function() {
            var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : r3.state.date, t4 = ["react-datepicker__current-month"];
            return r3.props.showYearDropdown && t4.push("react-datepicker__current-month--hasYearDropdown"), r3.props.showMonthDropdown && t4.push("react-datepicker__current-month--hasMonthDropdown"), r3.props.showMonthYearDropdown && t4.push("react-datepicker__current-month--hasMonthYearDropdown"), de.default.createElement("div", { className: t4.join(" ") }, Le(e4, r3.props.dateFormat, r3.props.locale));
          }), Me(Pe(r3), "renderYearDropdown", function() {
            var e4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (r3.props.showYearDropdown && !e4)
              return de.default.createElement(Pt, { adjustDateOnChange: r3.props.adjustDateOnChange, date: r3.state.date, onSelect: r3.props.onSelect, setOpen: r3.props.setOpen, dropdownMode: r3.props.dropdownMode, onChange: r3.changeYear, minDate: r3.props.minDate, maxDate: r3.props.maxDate, year: Y.getYear(r3.state.date), scrollableYearDropdown: r3.props.scrollableYearDropdown, yearDropdownItemNumber: r3.props.yearDropdownItemNumber });
          }), Me(Pe(r3), "renderMonthDropdown", function() {
            var e4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (r3.props.showMonthDropdown && !e4)
              return de.default.createElement(xt, { dropdownMode: r3.props.dropdownMode, locale: r3.props.locale, onChange: r3.changeMonth, month: C.getMonth(r3.state.date), useShortMonthInDropdown: r3.props.useShortMonthInDropdown });
          }), Me(Pe(r3), "renderMonthYearDropdown", function() {
            var e4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (r3.props.showMonthYearDropdown && !e4)
              return de.default.createElement(Lt, { dropdownMode: r3.props.dropdownMode, locale: r3.props.locale, dateFormat: r3.props.dateFormat, onChange: r3.changeMonthYear, minDate: r3.props.minDate, maxDate: r3.props.maxDate, date: r3.state.date, scrollableMonthYearDropdown: r3.props.scrollableMonthYearDropdown });
          }), Me(Pe(r3), "handleTodayButtonClick", function(e4) {
            r3.props.onSelect(Be(), e4), r3.props.setPreSelection && r3.props.setPreSelection(Be());
          }), Me(Pe(r3), "renderTodayButton", function() {
            if (r3.props.todayButton && !r3.props.showTimeSelectOnly)
              return de.default.createElement("div", { className: "react-datepicker__today-button", onClick: function(e4) {
                return r3.handleTodayButtonClick(e4);
              } }, r3.props.todayButton);
          }), Me(Pe(r3), "renderDefaultHeader", function(e4) {
            var t4 = e4.monthDate, n2 = e4.i;
            return de.default.createElement("div", { className: "react-datepicker__header ".concat(r3.props.showTimeSelect ? "react-datepicker__header--has-time-select" : "") }, r3.renderCurrentMonth(t4), de.default.createElement("div", { className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(r3.props.dropdownMode), onFocus: r3.handleDropdownFocus }, r3.renderMonthDropdown(0 !== n2), r3.renderMonthYearDropdown(0 !== n2), r3.renderYearDropdown(0 !== n2)), de.default.createElement("div", { className: "react-datepicker__day-names" }, r3.header(t4)));
          }), Me(Pe(r3), "renderCustomHeader", function() {
            var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t4 = e4.monthDate, n2 = e4.i;
            if (r3.props.showTimeSelect && !r3.state.monthContainer || r3.props.showTimeSelectOnly)
              return null;
            var a3 = ut(r3.state.date, r3.props), o2 = ht(r3.state.date, r3.props), s2 = ft(r3.state.date, r3.props), i2 = mt(r3.state.date, r3.props), p2 = !r3.props.showMonthYearPicker && !r3.props.showQuarterYearPicker && !r3.props.showYearPicker;
            return de.default.createElement("div", { className: "react-datepicker__header react-datepicker__header--custom", onFocus: r3.props.onDropdownFocus }, r3.props.renderCustomHeader(De(De({}, r3.state), {}, { customHeaderCount: n2, monthDate: t4, changeMonth: r3.changeMonth, changeYear: r3.changeYear, decreaseMonth: r3.decreaseMonth, increaseMonth: r3.increaseMonth, decreaseYear: r3.decreaseYear, increaseYear: r3.increaseYear, prevMonthButtonDisabled: a3, nextMonthButtonDisabled: o2, prevYearButtonDisabled: s2, nextYearButtonDisabled: i2 })), p2 && de.default.createElement("div", { className: "react-datepicker__day-names" }, r3.header(t4)));
          }), Me(Pe(r3), "renderYearHeader", function() {
            var e4 = r3.state.date, t4 = r3.props, n2 = t4.showYearPicker, a3 = bt(e4, t4.yearItemNumber), o2 = a3.startPeriod, s2 = a3.endPeriod;
            return de.default.createElement("div", { className: "react-datepicker__header react-datepicker-year-header" }, n2 ? "".concat(o2, " - ").concat(s2) : Y.getYear(e4));
          }), Me(Pe(r3), "renderHeader", function(e4) {
            switch (true) {
              case void 0 !== r3.props.renderCustomHeader:
                return r3.renderCustomHeader(e4);
              case (r3.props.showMonthYearPicker || r3.props.showQuarterYearPicker || r3.props.showYearPicker):
                return r3.renderYearHeader(e4);
              default:
                return r3.renderDefaultHeader(e4);
            }
          }), Me(Pe(r3), "renderMonths", function() {
            var e4;
            if (!r3.props.showTimeSelectOnly && !r3.props.showYearPicker) {
              for (var t4 = [], n2 = r3.props.showPreviousMonths ? r3.props.monthsShown - 1 : 0, a3 = y.subMonths(r3.state.date, n2), o2 = null !== (e4 = r3.props.monthSelectedIn) && void 0 !== e4 ? e4 : n2, s2 = 0; s2 < r3.props.monthsShown; ++s2) {
                var i2 = s2 - o2 + n2, p2 = d.addMonths(a3, i2), c3 = "month-".concat(s2), l2 = s2 < r3.props.monthsShown - 1, u2 = s2 > 0;
                t4.push(de.default.createElement("div", { key: c3, ref: function(e5) {
                  r3.monthContainer = e5;
                }, className: "react-datepicker__month-container" }, r3.renderHeader({ monthDate: p2, i: s2 }), de.default.createElement(jt, { chooseDayAriaLabelPrefix: r3.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: r3.props.disabledDayAriaLabelPrefix, weekAriaLabelPrefix: r3.props.weekAriaLabelPrefix, ariaLabelPrefix: r3.props.monthAriaLabelPrefix, onChange: r3.changeMonthYear, day: p2, dayClassName: r3.props.dayClassName, calendarStartDay: r3.props.calendarStartDay, monthClassName: r3.props.monthClassName, onDayClick: r3.handleDayClick, handleOnKeyDown: r3.props.handleOnDayKeyDown, onDayMouseEnter: r3.handleDayMouseEnter, onMouseLeave: r3.handleMonthMouseLeave, onWeekSelect: r3.props.onWeekSelect, orderInDisplay: s2, formatWeekNumber: r3.props.formatWeekNumber, locale: r3.props.locale, minDate: r3.props.minDate, maxDate: r3.props.maxDate, excludeDates: r3.props.excludeDates, excludeDateIntervals: r3.props.excludeDateIntervals, highlightDates: r3.props.highlightDates, holidays: r3.props.holidays, selectingDate: r3.state.selectingDate, includeDates: r3.props.includeDates, includeDateIntervals: r3.props.includeDateIntervals, inline: r3.props.inline, shouldFocusDayInline: r3.props.shouldFocusDayInline, fixedHeight: r3.props.fixedHeight, filterDate: r3.props.filterDate, preSelection: r3.props.preSelection, setPreSelection: r3.props.setPreSelection, selected: r3.props.selected, selectsStart: r3.props.selectsStart, selectsEnd: r3.props.selectsEnd, selectsRange: r3.props.selectsRange, selectsDisabledDaysInRange: r3.props.selectsDisabledDaysInRange, showWeekNumbers: r3.props.showWeekNumbers, startDate: r3.props.startDate, endDate: r3.props.endDate, peekNextMonth: r3.props.peekNextMonth, setOpen: r3.props.setOpen, shouldCloseOnSelect: r3.props.shouldCloseOnSelect, renderDayContents: r3.props.renderDayContents, renderMonthContent: r3.props.renderMonthContent, renderQuarterContent: r3.props.renderQuarterContent, renderYearContent: r3.props.renderYearContent, disabledKeyboardNavigation: r3.props.disabledKeyboardNavigation, showMonthYearPicker: r3.props.showMonthYearPicker, showFullMonthYearPicker: r3.props.showFullMonthYearPicker, showTwoColumnMonthYearPicker: r3.props.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker: r3.props.showFourColumnMonthYearPicker, showYearPicker: r3.props.showYearPicker, showQuarterYearPicker: r3.props.showQuarterYearPicker, showWeekPicker: r3.props.showWeekPicker, isInputFocused: r3.props.isInputFocused, containerRef: r3.containerRef, monthShowsDuplicateDaysEnd: l2, monthShowsDuplicateDaysStart: u2 })));
              }
              return t4;
            }
          }), Me(Pe(r3), "renderYears", function() {
            if (!r3.props.showTimeSelectOnly)
              return r3.props.showYearPicker ? de.default.createElement("div", { className: "react-datepicker__year--container" }, r3.renderHeader(), de.default.createElement(Ut, Ce({ onDayClick: r3.handleDayClick, selectingDate: r3.state.selectingDate, clearSelectingDate: r3.clearSelectingDate, date: r3.state.date }, r3.props, { onYearMouseEnter: r3.handleYearMouseEnter, onYearMouseLeave: r3.handleYearMouseLeave }))) : void 0;
          }), Me(Pe(r3), "renderTimeSection", function() {
            if (r3.props.showTimeSelect && (r3.state.monthContainer || r3.props.showTimeSelectOnly))
              return de.default.createElement(Vt, { selected: r3.props.selected, openToDate: r3.props.openToDate, onChange: r3.props.onTimeChange, timeClassName: r3.props.timeClassName, format: r3.props.timeFormat, includeTimes: r3.props.includeTimes, intervals: r3.props.timeIntervals, minTime: r3.props.minTime, maxTime: r3.props.maxTime, excludeTimes: r3.props.excludeTimes, filterTime: r3.props.filterTime, timeCaption: r3.props.timeCaption, todayButton: r3.props.todayButton, showMonthDropdown: r3.props.showMonthDropdown, showMonthYearDropdown: r3.props.showMonthYearDropdown, showYearDropdown: r3.props.showYearDropdown, withPortal: r3.props.withPortal, monthRef: r3.state.monthContainer, injectTimes: r3.props.injectTimes, locale: r3.props.locale, handleOnKeyDown: r3.props.handleOnKeyDown, showTimeSelectOnly: r3.props.showTimeSelectOnly });
          }), Me(Pe(r3), "renderInputTimeSection", function() {
            var e4 = new Date(r3.props.selected), t4 = Re(e4) && Boolean(r3.props.selected) ? "".concat(wt(e4.getHours()), ":").concat(wt(e4.getMinutes())) : "";
            if (r3.props.showTimeInput)
              return de.default.createElement($t, { date: e4, timeString: t4, timeInputLabel: r3.props.timeInputLabel, onChange: r3.props.onTimeChange, customTimeInput: r3.props.customTimeInput });
          }), Me(Pe(r3), "renderAriaLiveRegion", function() {
            var e4, t4 = bt(r3.state.date, r3.props.yearItemNumber), n2 = t4.startPeriod, a3 = t4.endPeriod;
            return e4 = r3.props.showYearPicker ? "".concat(n2, " - ").concat(a3) : r3.props.showMonthYearPicker || r3.props.showQuarterYearPicker ? Y.getYear(r3.state.date) : "".concat(Xe(C.getMonth(r3.state.date), r3.props.locale), " ").concat(Y.getYear(r3.state.date)), de.default.createElement("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" }, r3.state.isRenderAriaLiveMessage && e4);
          }), Me(Pe(r3), "renderChildren", function() {
            if (r3.props.children)
              return de.default.createElement("div", { className: "react-datepicker__children-container" }, r3.props.children);
          }), r3.containerRef = de.default.createRef(), r3.state = { date: r3.getDateInView(), selectingDate: null, monthContainer: null, isRenderAriaLiveMessage: false }, r3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "componentDidMount", value: function() {
          var e3 = this;
          this.props.showTimeSelect && (this.assignMonthContainer = void e3.setState({ monthContainer: e3.monthContainer }));
        } }, { key: "componentDidUpdate", value: function(e3) {
          var t4 = this;
          if (!this.props.preSelection || Ue(this.props.preSelection, e3.preSelection) && this.props.monthSelectedIn === e3.monthSelectedIn)
            this.props.openToDate && !Ue(this.props.openToDate, e3.openToDate) && this.setState({ date: this.props.openToDate });
          else {
            var r3 = !je(this.state.date, this.props.preSelection);
            this.setState({ date: this.props.preSelection }, function() {
              return r3 && t4.handleCustomMonthChange(t4.state.date);
            });
          }
        } }, { key: "render", value: function() {
          var e3 = this.props.container || zt;
          return de.default.createElement("div", { style: { display: "contents" }, ref: this.containerRef }, de.default.createElement(e3, { className: ue.default("react-datepicker", this.props.className, { "react-datepicker--time-only": this.props.showTimeSelectOnly }) }, this.renderAriaLiveRegion(), this.renderPreviousButton(), this.renderNextButton(), this.renderMonths(), this.renderYears(), this.renderTodayButton(), this.renderTimeSection(), this.renderInputTimeSection(), this.renderChildren()));
        } }], [{ key: "defaultProps", get: function() {
          return { onDropdownFocus: function() {
          }, monthsShown: 1, forceShowMonthNavigation: false, timeCaption: "Time", previousYearButtonLabel: "Previous Year", nextYearButtonLabel: "Next Year", previousMonthButtonLabel: "Previous Month", nextMonthButtonLabel: "Next Month", customTimeInput: null, yearItemNumber: xe };
        } }]), t3;
      }(de.default.Component), Xt = function(e2) {
        var t3 = e2.icon, r3 = e2.className, n2 = void 0 === r3 ? "" : r3, a3 = e2.onClick, o2 = "react-datepicker__calendar-icon";
        return de.default.isValidElement(t3) ? de.default.cloneElement(t3, { className: "".concat(t3.props.className || "", " ").concat(o2, " ").concat(n2), onClick: function(e3) {
          "function" == typeof t3.props.onClick && t3.props.onClick(e3), "function" == typeof a3 && a3(e3);
        } }) : "string" == typeof t3 ? de.default.createElement("i", { className: "".concat(o2, " ").concat(t3, " ").concat(n2), "aria-hidden": "true", onClick: a3 }) : de.default.createElement("svg", { className: "".concat(o2, " ").concat(n2), xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 448 512", onClick: a3 }, de.default.createElement("path", { d: "M96 32V64H48C21.5 64 0 85.5 0 112v48H448V112c0-26.5-21.5-48-48-48H352V32c0-17.7-14.3-32-32-32s-32 14.3-32 32V64H160V32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192H0V464c0 26.5 21.5 48 48 48H400c26.5 0 48-21.5 48-48V192z" }));
      }, Zt = function(e2) {
        function t3(e3) {
          var r3;
          return we(this, t3), (r3 = me(this, t3, [e3])).el = document.createElement("div"), r3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "componentDidMount", value: function() {
          this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId), this.portalRoot || (this.portalRoot = document.createElement("div"), this.portalRoot.setAttribute("id", this.props.portalId), (this.props.portalHost || document.body).appendChild(this.portalRoot)), this.portalRoot.appendChild(this.el);
        } }, { key: "componentWillUnmount", value: function() {
          this.portalRoot.removeChild(this.el);
        } }, { key: "render", value: function() {
          return fe.default.createPortal(this.props.children, this.el);
        } }]), t3;
      }(de.default.Component), er = function(e2) {
        return !e2.disabled && -1 !== e2.tabIndex;
      }, tr = function(e2) {
        function t3(e3) {
          var r3;
          return we(this, t3), Me(Pe(r3 = me(this, t3, [e3])), "getTabChildren", function() {
            return Array.prototype.slice.call(r3.tabLoopRef.current.querySelectorAll("[tabindex], a, button, input, select, textarea"), 1, -1).filter(er);
          }), Me(Pe(r3), "handleFocusStart", function() {
            var e4 = r3.getTabChildren();
            e4 && e4.length > 1 && e4[e4.length - 1].focus();
          }), Me(Pe(r3), "handleFocusEnd", function() {
            var e4 = r3.getTabChildren();
            e4 && e4.length > 1 && e4[0].focus();
          }), r3.tabLoopRef = de.default.createRef(), r3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "render", value: function() {
          return this.props.enableTabLoop ? de.default.createElement("div", { className: "react-datepicker__tab-loop", ref: this.tabLoopRef }, de.default.createElement("div", { className: "react-datepicker__tab-loop__start", tabIndex: "0", onFocus: this.handleFocusStart }), this.props.children, de.default.createElement("div", { className: "react-datepicker__tab-loop__end", tabIndex: "0", onFocus: this.handleFocusEnd })) : this.props.children;
        } }], [{ key: "defaultProps", get: function() {
          return { enableTabLoop: true };
        } }]), t3;
      }(de.default.Component);
      var rr, nr = function(e2) {
        function t3() {
          return we(this, t3), me(this, t3, arguments);
        }
        return _e3(t3, e2), Se(t3, [{ key: "render", value: function() {
          var e3, t4 = this.props, r3 = t4.className, n2 = t4.wrapperClassName, a3 = t4.hidePopper, o2 = t4.popperComponent, s2 = t4.targetComponent, i2 = t4.enableTabLoop, p2 = t4.popperOnKeyDown, c3 = t4.portalId, l2 = t4.portalHost, d2 = t4.popperProps, u2 = t4.showArrow;
          if (!a3) {
            var h2 = ue.default("react-datepicker-popper", r3);
            e3 = de.default.createElement(tr, { enableTabLoop: i2 }, de.default.createElement("div", { ref: d2.refs.setFloating, style: d2.floatingStyles, className: h2, "data-placement": d2.placement, onKeyDown: p2 }, o2, u2 && de.default.createElement(pe.FloatingArrow, { ref: d2.arrowRef, context: d2.context, fill: "currentColor", strokeWidth: 1, height: 8, width: 16, style: { transform: "translateY(-1px)" }, className: "react-datepicker__triangle" })));
          }
          this.props.popperContainer && (e3 = de.default.createElement(this.props.popperContainer, {}, e3)), c3 && !a3 && (e3 = de.default.createElement(Zt, { portalId: c3, portalHost: l2 }, e3));
          var f2 = ue.default("react-datepicker-wrapper", n2);
          return de.default.createElement(de.default.Fragment, null, de.default.createElement("div", { ref: d2.refs.setReference, className: f2 }, s2), e3);
        } }], [{ key: "defaultProps", get: function() {
          return { hidePopper: true };
        } }]), t3;
      }(de.default.Component), ar = (rr = nr, function(e2) {
        var t3 = De(De({}, e2), {}, { popperModifiers: e2.popperModifiers || [], popperProps: e2.popperProps || {}, hidePopper: "boolean" != typeof e2.hidePopper || e2.hidePopper }), r3 = de.default.useRef(), n2 = pe.useFloating(De({ open: !t3.hidePopper, whileElementsMounted: pe.autoUpdate, placement: t3.popperPlacement, middleware: [pe.flip({ padding: 15 }), pe.offset(10), pe.arrow({ element: r3 })].concat(Ne(t3.popperModifiers)) }, t3.popperProps));
        return de.default.createElement(rr, Ce({}, t3, { popperProps: De(De({}, n2), {}, { arrowRef: r3 }) }));
      }), or = "react-datepicker-ignore-onclickoutside", sr = he.default(Jt);
      var ir = "Date input not valid.", pr = function(e2) {
        function t3(e3) {
          var r3;
          return we(this, t3), Me(Pe(r3 = me(this, t3, [e3])), "getPreSelection", function() {
            return r3.props.openToDate ? r3.props.openToDate : r3.props.selectsEnd && r3.props.startDate ? r3.props.startDate : r3.props.selectsStart && r3.props.endDate ? r3.props.endDate : Te();
          }), Me(Pe(r3), "modifyHolidays", function() {
            var e4;
            return null === (e4 = r3.props.holidays) || void 0 === e4 ? void 0 : e4.reduce(function(e5, t4) {
              var r4 = new Date(t4.date);
              return o.isValid(r4) ? [].concat(Ne(e5), [De(De({}, t4), {}, { date: r4 })]) : e5;
            }, []);
          }), Me(Pe(r3), "calcInitialState", function() {
            var e4, t4 = r3.getPreSelection(), n2 = yt(r3.props), a3 = gt(r3.props), o2 = n2 && te.isBefore(t4, Q.startOfDay(n2)) ? n2 : a3 && ee.isAfter(t4, j.endOfDay(a3)) ? a3 : t4;
            return { open: r3.props.startOpen || false, preventFocus: false, preSelection: null !== (e4 = r3.props.selectsRange ? r3.props.startDate : r3.props.selected) && void 0 !== e4 ? e4 : o2, highlightDates: Dt(r3.props.highlightDates), focused: false, shouldFocusDayInline: false, isRenderAriaLiveMessage: false };
          }), Me(Pe(r3), "clearPreventFocusTimeout", function() {
            r3.preventFocusTimeout && clearTimeout(r3.preventFocusTimeout);
          }), Me(Pe(r3), "setFocus", function() {
            r3.input && r3.input.focus && r3.input.focus({ preventScroll: true });
          }), Me(Pe(r3), "setBlur", function() {
            r3.input && r3.input.blur && r3.input.blur(), r3.cancelFocusInput();
          }), Me(Pe(r3), "setOpen", function(e4) {
            var t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            r3.setState({ open: e4, preSelection: e4 && r3.state.open ? r3.state.preSelection : r3.calcInitialState().preSelection, lastPreSelectChange: lr }, function() {
              e4 || r3.setState(function(e5) {
                return { focused: !!t4 && e5.focused };
              }, function() {
                !t4 && r3.setBlur(), r3.setState({ inputValue: null });
              });
            });
          }), Me(Pe(r3), "inputOk", function() {
            return a2.isDate(r3.state.preSelection);
          }), Me(Pe(r3), "isCalendarOpen", function() {
            return void 0 === r3.props.open ? r3.state.open && !r3.props.disabled && !r3.props.readOnly : r3.props.open;
          }), Me(Pe(r3), "handleFocus", function(e4) {
            r3.state.preventFocus || (r3.props.onFocus(e4), r3.props.preventOpenOnFocus || r3.props.readOnly || r3.setOpen(true)), r3.setState({ focused: true });
          }), Me(Pe(r3), "sendFocusBackToInput", function() {
            r3.preventFocusTimeout && r3.clearPreventFocusTimeout(), r3.setState({ preventFocus: true }, function() {
              r3.preventFocusTimeout = setTimeout(function() {
                r3.setFocus(), r3.setState({ preventFocus: false });
              });
            });
          }), Me(Pe(r3), "cancelFocusInput", function() {
            clearTimeout(r3.inputFocusTimeout), r3.inputFocusTimeout = null;
          }), Me(Pe(r3), "deferFocusInput", function() {
            r3.cancelFocusInput(), r3.inputFocusTimeout = setTimeout(function() {
              return r3.setFocus();
            }, 1);
          }), Me(Pe(r3), "handleDropdownFocus", function() {
            r3.cancelFocusInput();
          }), Me(Pe(r3), "handleBlur", function(e4) {
            (!r3.state.open || r3.props.withPortal || r3.props.showTimeInput) && r3.props.onBlur(e4), r3.setState({ focused: false });
          }), Me(Pe(r3), "handleCalendarClickOutside", function(e4) {
            r3.props.inline || r3.setOpen(false), r3.props.onClickOutside(e4), r3.props.withPortal && e4.preventDefault();
          }), Me(Pe(r3), "handleChange", function() {
            for (var e4 = arguments.length, t4 = new Array(e4), n2 = 0; n2 < e4; n2++)
              t4[n2] = arguments[n2];
            var a3 = t4[0];
            if (!r3.props.onChangeRaw || (r3.props.onChangeRaw.apply(Pe(r3), t4), "function" == typeof a3.isDefaultPrevented && !a3.isDefaultPrevented())) {
              r3.setState({ inputValue: a3.target.value, lastPreSelectChange: cr });
              var o2, i2, p2, c3, l2, d2, u2, h2, f2 = (o2 = a3.target.value, i2 = r3.props.dateFormat, p2 = r3.props.locale, c3 = r3.props.strictParsing, l2 = r3.props.minDate, d2 = null, u2 = Je(p2) || Je(Ge()), h2 = true, Array.isArray(i2) ? (i2.forEach(function(e5) {
                var t5 = ae.parse(o2, e5, /* @__PURE__ */ new Date(), { locale: u2, useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true });
                c3 && (h2 = Re(t5, l2) && o2 === Le(t5, e5, p2)), Re(t5, l2) && h2 && (d2 = t5);
              }), d2) : (d2 = ae.parse(o2, i2, /* @__PURE__ */ new Date(), { locale: u2, useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true }), c3 ? h2 = Re(d2) && o2 === Le(d2, i2, p2) : Re(d2) || (i2 = i2.match(Ie).map(function(e5) {
                var t5 = e5[0];
                if ("p" === t5 || "P" === t5) {
                  var r4 = s.longFormatters[t5];
                  return u2 ? r4(e5, u2.formatLong) : t5;
                }
                return e5;
              }).join(""), o2.length > 0 && (d2 = ae.parse(o2, i2.slice(0, o2.length), /* @__PURE__ */ new Date(), { useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true })), Re(d2) || (d2 = new Date(o2))), Re(d2) && h2 ? d2 : null));
              r3.props.showTimeSelectOnly && r3.props.selected && f2 && !Ue(f2, r3.props.selected) && (f2 = ce.set(r3.props.selected, { hours: w.getHours(f2), minutes: k.getMinutes(f2), seconds: v.getSeconds(f2) })), !f2 && a3.target.value || (r3.props.showWeekPicker && (f2 = We(f2, r3.props.locale, r3.props.calendarStartDay)), r3.setSelected(f2, a3, true));
            }
          }), Me(Pe(r3), "handleSelect", function(e4, t4, n2) {
            if (r3.props.shouldCloseOnSelect && !r3.props.showTimeSelect && r3.sendFocusBackToInput(), r3.props.onChangeRaw && r3.props.onChangeRaw(t4), r3.props.showWeekPicker && (e4 = We(e4, r3.props.locale, r3.props.calendarStartDay)), r3.setSelected(e4, t4, false, n2), r3.props.showDateSelect && r3.setState({ isRenderAriaLiveMessage: true }), !r3.props.shouldCloseOnSelect || r3.props.showTimeSelect)
              r3.setPreSelection(e4);
            else if (!r3.props.inline) {
              r3.props.selectsRange || r3.setOpen(false);
              var a3 = r3.props, o2 = a3.startDate, s2 = a3.endDate;
              !o2 || s2 || Ct(e4, o2) || r3.setOpen(false);
            }
          }), Me(Pe(r3), "setSelected", function(e4, t4, n2, a3) {
            var o2 = e4;
            if (r3.props.showYearPicker) {
              if (null !== o2 && st(Y.getYear(o2), r3.props))
                return;
            } else if (r3.props.showMonthYearPicker) {
              if (null !== o2 && rt(o2, r3.props))
                return;
            } else if (null !== o2 && et(o2, r3.props))
              return;
            var s2 = r3.props, i2 = s2.onChange, p2 = s2.selectsRange, c3 = s2.startDate, l2 = s2.endDate;
            if (!$e(r3.props.selected, o2) || r3.props.allowSameDay || p2)
              if (null !== o2 && (!r3.props.selected || n2 && (r3.props.showTimeSelect || r3.props.showTimeSelectOnly || r3.props.showTimeInput) || (o2 = Ae(o2, { hour: w.getHours(r3.props.selected), minute: k.getMinutes(r3.props.selected), second: v.getSeconds(r3.props.selected) })), r3.props.inline || r3.setState({ preSelection: o2 }), r3.props.focusSelectedMonth || r3.setState({ monthSelectedIn: a3 })), p2) {
                var d2 = c3 && !l2, u2 = c3 && l2;
                !c3 && !l2 ? i2([o2, null], t4) : d2 && (Ct(o2, c3) ? i2([o2, null], t4) : i2([c3, o2], t4)), u2 && i2([o2, null], t4);
              } else
                i2(o2, t4);
            n2 || (r3.props.onSelect(o2, t4), r3.setState({ inputValue: null }));
          }), Me(Pe(r3), "setPreSelection", function(e4) {
            var t4 = void 0 !== r3.props.minDate, n2 = void 0 !== r3.props.maxDate, a3 = true;
            if (e4) {
              r3.props.showWeekPicker && (e4 = We(e4, r3.props.locale, r3.props.calendarStartDay));
              var o2 = Q.startOfDay(e4);
              if (t4 && n2)
                a3 = ze(e4, r3.props.minDate, r3.props.maxDate);
              else if (t4) {
                var s2 = Q.startOfDay(r3.props.minDate);
                a3 = ee.isAfter(e4, s2) || $e(o2, s2);
              } else if (n2) {
                var i2 = j.endOfDay(r3.props.maxDate);
                a3 = te.isBefore(e4, i2) || $e(o2, i2);
              }
            }
            a3 && r3.setState({ preSelection: e4 });
          }), Me(Pe(r3), "toggleCalendar", function() {
            r3.setOpen(!r3.state.open);
          }), Me(Pe(r3), "handleTimeChange", function(e4) {
            var t4 = r3.props.selected ? r3.props.selected : r3.getPreSelection(), n2 = r3.props.selected ? e4 : Ae(t4, { hour: w.getHours(e4), minute: k.getMinutes(e4) });
            r3.setState({ preSelection: n2 }), r3.props.onChange(n2), r3.props.shouldCloseOnSelect && (r3.sendFocusBackToInput(), r3.setOpen(false)), r3.props.showTimeInput && r3.setOpen(true), (r3.props.showTimeSelectOnly || r3.props.showTimeSelect) && r3.setState({ isRenderAriaLiveMessage: true }), r3.setState({ inputValue: null });
          }), Me(Pe(r3), "onInputClick", function() {
            r3.props.disabled || r3.props.readOnly || r3.setOpen(true), r3.props.onInputClick();
          }), Me(Pe(r3), "onInputKeyDown", function(e4) {
            r3.props.onKeyDown(e4);
            var t4 = e4.key;
            if (r3.state.open || r3.props.inline || r3.props.preventOpenOnFocus) {
              if (r3.state.open) {
                if ("ArrowDown" === t4 || "ArrowUp" === t4) {
                  e4.preventDefault();
                  var n2 = r3.props.showWeekPicker && r3.props.showWeekNumbers ? '.react-datepicker__week-number[tabindex="0"]' : '.react-datepicker__day[tabindex="0"]', a3 = r3.calendar.componentNode && r3.calendar.componentNode.querySelector(n2);
                  return void (a3 && a3.focus({ preventScroll: true }));
                }
                var o2 = Te(r3.state.preSelection);
                "Enter" === t4 ? (e4.preventDefault(), r3.inputOk() && r3.state.lastPreSelectChange === lr ? (r3.handleSelect(o2, e4), !r3.props.shouldCloseOnSelect && r3.setPreSelection(o2)) : r3.setOpen(false)) : "Escape" === t4 ? (e4.preventDefault(), r3.sendFocusBackToInput(), r3.setOpen(false)) : "Tab" === t4 && r3.setOpen(false), r3.inputOk() || r3.props.onInputError({ code: 1, msg: ir });
              }
            } else
              "ArrowDown" !== t4 && "ArrowUp" !== t4 && "Enter" !== t4 || r3.onInputClick();
          }), Me(Pe(r3), "onPortalKeyDown", function(e4) {
            "Escape" === e4.key && (e4.preventDefault(), r3.setState({ preventFocus: true }, function() {
              r3.setOpen(false), setTimeout(function() {
                r3.setFocus(), r3.setState({ preventFocus: false });
              });
            }));
          }), Me(Pe(r3), "onDayKeyDown", function(e4) {
            r3.props.onKeyDown(e4);
            var t4, n2 = e4.key, a3 = e4.shiftKey, o2 = Te(r3.state.preSelection);
            if ("Enter" === n2)
              e4.preventDefault(), r3.handleSelect(o2, e4), !r3.props.shouldCloseOnSelect && r3.setPreSelection(o2);
            else if ("Escape" === n2)
              e4.preventDefault(), r3.setOpen(false), r3.inputOk() || r3.props.onInputError({ code: 1, msg: ir });
            else if (!r3.props.disabledKeyboardNavigation) {
              var s2;
              switch (n2) {
                case "ArrowLeft":
                  s2 = r3.props.showWeekPicker ? m.subWeeks(o2, 1) : f.subDays(o2, 1);
                  break;
                case "ArrowRight":
                  s2 = r3.props.showWeekPicker ? l.addWeeks(o2, 1) : c2.addDays(o2, 1);
                  break;
                case "ArrowUp":
                  s2 = m.subWeeks(o2, 1);
                  break;
                case "ArrowDown":
                  s2 = l.addWeeks(o2, 1);
                  break;
                case "PageUp":
                  s2 = a3 ? D.subYears(o2, 1) : y.subMonths(o2, 1);
                  break;
                case "PageDown":
                  s2 = a3 ? h.addYears(o2, 1) : d.addMonths(o2, 1);
                  break;
                case "Home":
                  s2 = We(o2, r3.props.locale, r3.props.calendarStartDay);
                  break;
                case "End":
                  t4 = o2, s2 = V.endOfWeek(t4);
                  break;
                default:
                  s2 = null;
              }
              if (!s2)
                return void (r3.props.onInputError && r3.props.onInputError({ code: 1, msg: ir }));
              if (e4.preventDefault(), r3.setState({ lastPreSelectChange: lr }), r3.props.adjustDateOnChange && r3.setSelected(s2), r3.setPreSelection(s2), r3.props.inline) {
                var i2 = C.getMonth(o2), p2 = C.getMonth(s2), u2 = Y.getYear(o2), g2 = Y.getYear(s2);
                i2 !== p2 || u2 !== g2 ? r3.setState({ shouldFocusDayInline: true }) : r3.setState({ shouldFocusDayInline: false });
              }
            }
          }), Me(Pe(r3), "onPopperKeyDown", function(e4) {
            "Escape" === e4.key && (e4.preventDefault(), r3.sendFocusBackToInput());
          }), Me(Pe(r3), "onClearClick", function(e4) {
            e4 && e4.preventDefault && e4.preventDefault(), r3.sendFocusBackToInput(), r3.props.selectsRange ? r3.props.onChange([null, null], e4) : r3.props.onChange(null, e4), r3.setState({ inputValue: null });
          }), Me(Pe(r3), "clear", function() {
            r3.onClearClick();
          }), Me(Pe(r3), "onScroll", function(e4) {
            "boolean" == typeof r3.props.closeOnScroll && r3.props.closeOnScroll ? e4.target !== document && e4.target !== document.documentElement && e4.target !== document.body || r3.setOpen(false) : "function" == typeof r3.props.closeOnScroll && r3.props.closeOnScroll(e4) && r3.setOpen(false);
          }), Me(Pe(r3), "renderCalendar", function() {
            return r3.props.inline || r3.isCalendarOpen() ? de.default.createElement(sr, { ref: function(e4) {
              r3.calendar = e4;
            }, locale: r3.props.locale, calendarStartDay: r3.props.calendarStartDay, chooseDayAriaLabelPrefix: r3.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: r3.props.disabledDayAriaLabelPrefix, weekAriaLabelPrefix: r3.props.weekAriaLabelPrefix, monthAriaLabelPrefix: r3.props.monthAriaLabelPrefix, adjustDateOnChange: r3.props.adjustDateOnChange, setOpen: r3.setOpen, shouldCloseOnSelect: r3.props.shouldCloseOnSelect, dateFormat: r3.props.dateFormatCalendar, useWeekdaysShort: r3.props.useWeekdaysShort, formatWeekDay: r3.props.formatWeekDay, dropdownMode: r3.props.dropdownMode, selected: r3.props.selected, preSelection: r3.state.preSelection, onSelect: r3.handleSelect, onWeekSelect: r3.props.onWeekSelect, openToDate: r3.props.openToDate, minDate: r3.props.minDate, maxDate: r3.props.maxDate, selectsStart: r3.props.selectsStart, selectsEnd: r3.props.selectsEnd, selectsRange: r3.props.selectsRange, startDate: r3.props.startDate, endDate: r3.props.endDate, excludeDates: r3.props.excludeDates, excludeDateIntervals: r3.props.excludeDateIntervals, filterDate: r3.props.filterDate, onClickOutside: r3.handleCalendarClickOutside, formatWeekNumber: r3.props.formatWeekNumber, highlightDates: r3.state.highlightDates, holidays: vt(r3.modifyHolidays()), includeDates: r3.props.includeDates, includeDateIntervals: r3.props.includeDateIntervals, includeTimes: r3.props.includeTimes, injectTimes: r3.props.injectTimes, inline: r3.props.inline, shouldFocusDayInline: r3.state.shouldFocusDayInline, peekNextMonth: r3.props.peekNextMonth, showMonthDropdown: r3.props.showMonthDropdown, showPreviousMonths: r3.props.showPreviousMonths, useShortMonthInDropdown: r3.props.useShortMonthInDropdown, showMonthYearDropdown: r3.props.showMonthYearDropdown, showWeekNumbers: r3.props.showWeekNumbers, showYearDropdown: r3.props.showYearDropdown, withPortal: r3.props.withPortal, forceShowMonthNavigation: r3.props.forceShowMonthNavigation, showDisabledMonthNavigation: r3.props.showDisabledMonthNavigation, scrollableYearDropdown: r3.props.scrollableYearDropdown, scrollableMonthYearDropdown: r3.props.scrollableMonthYearDropdown, todayButton: r3.props.todayButton, weekLabel: r3.props.weekLabel, outsideClickIgnoreClass: or, fixedHeight: r3.props.fixedHeight, monthsShown: r3.props.monthsShown, monthSelectedIn: r3.state.monthSelectedIn, onDropdownFocus: r3.handleDropdownFocus, onMonthChange: r3.props.onMonthChange, onYearChange: r3.props.onYearChange, dayClassName: r3.props.dayClassName, weekDayClassName: r3.props.weekDayClassName, monthClassName: r3.props.monthClassName, timeClassName: r3.props.timeClassName, showDateSelect: r3.props.showDateSelect, showTimeSelect: r3.props.showTimeSelect, showTimeSelectOnly: r3.props.showTimeSelectOnly, onTimeChange: r3.handleTimeChange, timeFormat: r3.props.timeFormat, timeIntervals: r3.props.timeIntervals, minTime: r3.props.minTime, maxTime: r3.props.maxTime, excludeTimes: r3.props.excludeTimes, filterTime: r3.props.filterTime, timeCaption: r3.props.timeCaption, className: r3.props.calendarClassName, container: r3.props.calendarContainer, yearItemNumber: r3.props.yearItemNumber, yearDropdownItemNumber: r3.props.yearDropdownItemNumber, previousMonthAriaLabel: r3.props.previousMonthAriaLabel, previousMonthButtonLabel: r3.props.previousMonthButtonLabel, nextMonthAriaLabel: r3.props.nextMonthAriaLabel, nextMonthButtonLabel: r3.props.nextMonthButtonLabel, previousYearAriaLabel: r3.props.previousYearAriaLabel, previousYearButtonLabel: r3.props.previousYearButtonLabel, nextYearAriaLabel: r3.props.nextYearAriaLabel, nextYearButtonLabel: r3.props.nextYearButtonLabel, timeInputLabel: r3.props.timeInputLabel, disabledKeyboardNavigation: r3.props.disabledKeyboardNavigation, renderCustomHeader: r3.props.renderCustomHeader, popperProps: r3.props.popperProps, renderDayContents: r3.props.renderDayContents, renderMonthContent: r3.props.renderMonthContent, renderQuarterContent: r3.props.renderQuarterContent, renderYearContent: r3.props.renderYearContent, onDayMouseEnter: r3.props.onDayMouseEnter, onMonthMouseLeave: r3.props.onMonthMouseLeave, onYearMouseEnter: r3.props.onYearMouseEnter, onYearMouseLeave: r3.props.onYearMouseLeave, selectsDisabledDaysInRange: r3.props.selectsDisabledDaysInRange, showTimeInput: r3.props.showTimeInput, showMonthYearPicker: r3.props.showMonthYearPicker, showFullMonthYearPicker: r3.props.showFullMonthYearPicker, showTwoColumnMonthYearPicker: r3.props.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker: r3.props.showFourColumnMonthYearPicker, showYearPicker: r3.props.showYearPicker, showQuarterYearPicker: r3.props.showQuarterYearPicker, showWeekPicker: r3.props.showWeekPicker, excludeScrollbar: r3.props.excludeScrollbar, handleOnKeyDown: r3.props.onKeyDown, handleOnDayKeyDown: r3.onDayKeyDown, isInputFocused: r3.state.focused, customTimeInput: r3.props.customTimeInput, setPreSelection: r3.setPreSelection }, r3.props.children) : null;
          }), Me(Pe(r3), "renderAriaLiveRegion", function() {
            var e4, t4 = r3.props, n2 = t4.dateFormat, a3 = t4.locale, o2 = r3.props.showTimeInput || r3.props.showTimeSelect ? "PPPPp" : "PPPP";
            return e4 = r3.props.selectsRange ? "Selected start date: ".concat(Fe(r3.props.startDate, { dateFormat: o2, locale: a3 }), ". ").concat(r3.props.endDate ? "End date: " + Fe(r3.props.endDate, { dateFormat: o2, locale: a3 }) : "") : r3.props.showTimeSelectOnly ? "Selected time: ".concat(Fe(r3.props.selected, { dateFormat: n2, locale: a3 })) : r3.props.showYearPicker ? "Selected year: ".concat(Fe(r3.props.selected, { dateFormat: "yyyy", locale: a3 })) : r3.props.showMonthYearPicker ? "Selected month: ".concat(Fe(r3.props.selected, { dateFormat: "MMMM yyyy", locale: a3 })) : r3.props.showQuarterYearPicker ? "Selected quarter: ".concat(Fe(r3.props.selected, { dateFormat: "yyyy, QQQ", locale: a3 })) : "Selected date: ".concat(Fe(r3.props.selected, { dateFormat: o2, locale: a3 })), de.default.createElement("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" }, e4);
          }), Me(Pe(r3), "renderDateInput", function() {
            var e4, t4 = ue.default(r3.props.className, Me({}, or, r3.state.open)), n2 = r3.props.customInput || de.default.createElement("input", { type: "text" }), a3 = r3.props.customInputRef || "ref", o2 = "string" == typeof r3.props.value ? r3.props.value : "string" == typeof r3.state.inputValue ? r3.state.inputValue : r3.props.selectsRange ? function(e5, t5, r4) {
              if (!e5)
                return "";
              var n3 = Fe(e5, r4), a4 = t5 ? Fe(t5, r4) : "";
              return "".concat(n3, " - ").concat(a4);
            }(r3.props.startDate, r3.props.endDate, r3.props) : Fe(r3.props.selected, r3.props);
            return de.default.cloneElement(n2, (Me(Me(Me(Me(Me(Me(Me(Me(Me(Me(e4 = {}, a3, function(e5) {
              r3.input = e5;
            }), "value", o2), "onBlur", r3.handleBlur), "onChange", r3.handleChange), "onClick", r3.onInputClick), "onFocus", r3.handleFocus), "onKeyDown", r3.onInputKeyDown), "id", r3.props.id), "name", r3.props.name), "form", r3.props.form), Me(Me(Me(Me(Me(Me(Me(Me(Me(Me(e4, "autoFocus", r3.props.autoFocus), "placeholder", r3.props.placeholderText), "disabled", r3.props.disabled), "autoComplete", r3.props.autoComplete), "className", ue.default(n2.props.className, t4)), "title", r3.props.title), "readOnly", r3.props.readOnly), "required", r3.props.required), "tabIndex", r3.props.tabIndex), "aria-describedby", r3.props.ariaDescribedBy), Me(Me(Me(e4, "aria-invalid", r3.props.ariaInvalid), "aria-labelledby", r3.props.ariaLabelledBy), "aria-required", r3.props.ariaRequired)));
          }), Me(Pe(r3), "renderClearButton", function() {
            var e4 = r3.props, t4 = e4.isClearable, n2 = e4.disabled, a3 = e4.selected, o2 = e4.startDate, s2 = e4.endDate, i2 = e4.clearButtonTitle, p2 = e4.clearButtonClassName, c3 = void 0 === p2 ? "" : p2, l2 = e4.ariaLabelClose, d2 = void 0 === l2 ? "Close" : l2;
            return !t4 || null == a3 && null == o2 && null == s2 ? null : de.default.createElement("button", { type: "button", className: ue.default("react-datepicker__close-icon", c3, { "react-datepicker__close-icon--disabled": n2 }), disabled: n2, "aria-label": d2, onClick: r3.onClearClick, title: i2, tabIndex: -1 });
          }), r3.state = r3.calcInitialState(), r3.preventFocusTimeout = null, r3;
        }
        return _e3(t3, e2), Se(t3, [{ key: "componentDidMount", value: function() {
          window.addEventListener("scroll", this.onScroll, true);
        } }, { key: "componentDidUpdate", value: function(e3, t4) {
          var r3, n2;
          e3.inline && (r3 = e3.selected, n2 = this.props.selected, r3 && n2 ? C.getMonth(r3) !== C.getMonth(n2) || Y.getYear(r3) !== Y.getYear(n2) : r3 !== n2) && this.setPreSelection(this.props.selected), void 0 !== this.state.monthSelectedIn && e3.monthsShown !== this.props.monthsShown && this.setState({ monthSelectedIn: 0 }), e3.highlightDates !== this.props.highlightDates && this.setState({ highlightDates: Dt(this.props.highlightDates) }), t4.focused || $e(e3.selected, this.props.selected) || this.setState({ inputValue: null }), t4.open !== this.state.open && (false === t4.open && true === this.state.open && this.props.onCalendarOpen(), true === t4.open && false === this.state.open && this.props.onCalendarClose());
        } }, { key: "componentWillUnmount", value: function() {
          this.clearPreventFocusTimeout(), window.removeEventListener("scroll", this.onScroll, true);
        } }, { key: "renderInputContainer", value: function() {
          var e3 = this.props, t4 = e3.showIcon, r3 = e3.icon, n2 = e3.calendarIconClassname, a3 = e3.toggleCalendarOnIconClick, o2 = this.state.open;
          return de.default.createElement("div", { className: "react-datepicker__input-container".concat(t4 ? " react-datepicker__view-calendar-icon" : "") }, t4 && de.default.createElement(Xt, Ce({ icon: r3, className: "".concat(n2, " ").concat(o2 && "react-datepicker-ignore-onclickoutside") }, a3 ? { onClick: this.toggleCalendar } : null)), this.state.isRenderAriaLiveMessage && this.renderAriaLiveRegion(), this.renderDateInput(), this.renderClearButton());
        } }, { key: "render", value: function() {
          var e3 = this.renderCalendar();
          if (this.props.inline)
            return e3;
          if (this.props.withPortal) {
            var t4 = this.state.open ? de.default.createElement(tr, { enableTabLoop: this.props.enableTabLoop }, de.default.createElement("div", { className: "react-datepicker__portal", tabIndex: -1, onKeyDown: this.onPortalKeyDown }, e3)) : null;
            return this.state.open && this.props.portalId && (t4 = de.default.createElement(Zt, { portalId: this.props.portalId, portalHost: this.props.portalHost }, t4)), de.default.createElement("div", null, this.renderInputContainer(), t4);
          }
          return de.default.createElement(ar, { className: this.props.popperClassName, wrapperClassName: this.props.wrapperClassName, hidePopper: !this.isCalendarOpen(), portalId: this.props.portalId, portalHost: this.props.portalHost, popperModifiers: this.props.popperModifiers, targetComponent: this.renderInputContainer(), popperContainer: this.props.popperContainer, popperComponent: e3, popperPlacement: this.props.popperPlacement, popperProps: this.props.popperProps, popperOnKeyDown: this.onPopperKeyDown, enableTabLoop: this.props.enableTabLoop, showArrow: this.props.showPopperArrow });
        } }], [{ key: "defaultProps", get: function() {
          return { allowSameDay: false, dateFormat: "MM/dd/yyyy", dateFormatCalendar: "LLLL yyyy", onChange: function() {
          }, disabled: false, disabledKeyboardNavigation: false, dropdownMode: "scroll", onFocus: function() {
          }, onBlur: function() {
          }, onKeyDown: function() {
          }, onInputClick: function() {
          }, onSelect: function() {
          }, onClickOutside: function() {
          }, onMonthChange: function() {
          }, onCalendarOpen: function() {
          }, onCalendarClose: function() {
          }, preventOpenOnFocus: false, onYearChange: function() {
          }, onInputError: function() {
          }, monthsShown: 1, readOnly: false, withPortal: false, selectsDisabledDaysInRange: false, shouldCloseOnSelect: true, showTimeSelect: false, showTimeInput: false, showPreviousMonths: false, showMonthYearPicker: false, showFullMonthYearPicker: false, showTwoColumnMonthYearPicker: false, showFourColumnMonthYearPicker: false, showYearPicker: false, showQuarterYearPicker: false, showWeekPicker: false, strictParsing: false, timeIntervals: 30, timeCaption: "Time", previousMonthAriaLabel: "Previous Month", previousMonthButtonLabel: "Previous Month", nextMonthAriaLabel: "Next Month", nextMonthButtonLabel: "Next Month", previousYearAriaLabel: "Previous Year", previousYearButtonLabel: "Previous Year", nextYearAriaLabel: "Next Year", nextYearButtonLabel: "Next Year", timeInputLabel: "Time", enableTabLoop: true, yearItemNumber: xe, focusSelectedMonth: false, showPopperArrow: true, excludeScrollbar: true, customTimeInput: null, calendarStartDay: void 0, toggleCalendarOnIconClick: false };
        } }]), t3;
      }(de.default.Component), cr = "input", lr = "navigate";
      e.CalendarContainer = zt, e.default = pr, e.getDefaultLocale = Ge, e.registerLocale = function(e2, t3) {
        var r3 = "undefined" != typeof window ? window : globalThis;
        r3.__localeData__ || (r3.__localeData__ = {}), r3.__localeData__[e2] = t3;
      }, e.setDefaultLocale = function(e2) {
        ("undefined" != typeof window ? window : globalThis).__localeId__ = e2;
      }, Object.defineProperty(e, "__esModule", { value: true });
    });
  }
});

// app/components/TaskTable.jsx
var import_react94 = __toESM(require_react());

// node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js
var React2 = __toESM(require_react());
var import_react = __toESM(require_react());

// node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? false : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (true) {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    if (true) {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index3) {
  return value.charCodeAt(index3) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index3, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index3, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index3) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index3, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index3) {
  while (!token(peek()))
    next();
  return slice(index3, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index3 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index3++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset3:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference2 = ruleset(characters2, root, parent, index3, offset3, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index3 = offset3 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index3++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index3, offset3, rules, points, type, props, children, length2) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules : [""];
  var size3 = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index3; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size3; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props[k++] = z;
  return node(value, root, parent, offset3 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index3, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index3, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index3, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func) {
  var cache = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn2(arg);
    return cache[arg];
  };
}

// node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index3) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index3] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index3 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index3] = 1;
        }
        parsed[index3] += identifierWithPointTracking(position - 1, points, index3);
        break;
      case 2:
        parsed[index3] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index3] = peek() === 58 ? "&\f" : "";
          points[index3] = parsed[index3].length;
          break;
        }
      default:
        parsed[index3] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element) {
  return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache) {
  return function(element, index3, children) {
    if (element.type !== "rule" || cache.compat)
      return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element.parent;
      var commentContainer = isNested ? element.parent.children : (
        // global rule at the root level
        children
      );
      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node2 = commentContainer[i];
        if (node2.line < element.line) {
          break;
        }
        if (node2.column < element.column) {
          if (isIgnoringComment(node2)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index3, children) {
  for (var i = index3 - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element) {
  element.type = "";
  element.value = "";
  element["return"] = "";
  element.children = "";
  element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element, index3, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index3, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
function prefix(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index3, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  if (true) {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container2;
  var nodesToHydrate = [];
  {
    container2 = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if (true) {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, true ? function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    } : rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles3) {
      return serialize(compile(styles3), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (serialized.map !== void 0) {
        currentSheet = {
          insert: function insert2(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container: container2,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
if (true) {
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    if (interpolation.toString() === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles3 = interpolation.styles + ";";
        if (interpolation.map !== void 0) {
          styles3 += interpolation.map;
        }
        return styles3;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else if (true) {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      if (true) {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(match2, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
        }
      }
      break;
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && true) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (_key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
if (true) {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles3 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles3 += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (strings[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles3 += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles3 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      if (strings[i] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles3 += strings[i];
    }
  }
  var sourceMap;
  if (true) {
    styles3 = styles3.replace(sourceMapPattern, function(match3) {
      sourceMap = match3;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles3)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2(styles3) + identifierName;
  if (true) {
    return {
      name,
      styles: styles3,
      map: sourceMap,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }
  return {
    name,
    styles: styles3,
    next: cursor
  };
};

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var React = __toESM(require_react());
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React.useLayoutEffect;

// node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js
var isBrowser2 = true;
var hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = /* @__PURE__ */ React2.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
if (true) {
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
    var cache = (0, import_react.useContext)(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
if (!isBrowser2) {
  withEmotionCache = function withEmotionCache3(func) {
    return function(props) {
      var cache = (0, import_react.useContext)(EmotionCacheContext);
      if (cache === null) {
        cache = createCache({
          key: "css"
        });
        return /* @__PURE__ */ React2.createElement(EmotionCacheContext.Provider, {
          value: cache
        }, func(props, cache));
      } else {
        return func(props, cache);
      }
    };
  };
}
var ThemeContext = /* @__PURE__ */ React2.createContext({});
if (true) {
  ThemeContext.displayName = "EmotionThemeContext";
}
var getTheme = function getTheme2(outerTheme, theme3) {
  if (typeof theme3 === "function") {
    var mergedTheme = theme3(outerTheme);
    if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    }
    return mergedTheme;
  }
  if (theme3 == null || typeof theme3 !== "object" || Array.isArray(theme3)) {
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  }
  return _extends({}, outerTheme, theme3);
};
var createCacheWithTheme = /* @__PURE__ */ weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme3) {
    return getTheme(outerTheme, theme3);
  });
});
var ThemeProvider = function ThemeProvider2(props) {
  var theme3 = React2.useContext(ThemeContext);
  if (props.theme !== theme3) {
    theme3 = createCacheWithTheme(theme3)(props.theme);
  }
  return /* @__PURE__ */ React2.createElement(ThemeContext.Provider, {
    value: theme3
  }, props.children);
};
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var Insertion = function Insertion2(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React2.useContext(ThemeContext));
  if (serialized.name.indexOf("-") === -1) {
    var labelFromStack = props[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && key !== labelPropName) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ React2.createElement(WrappedComponent, newProps));
});
if (true) {
  Emotion.displayName = "EmotionCssPropInternal";
}

// node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var React3 = __toESM(require_react());
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var pkg = {
  name: "@emotion/react",
  version: "11.11.3",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        "default": "./dist/emotion-react.esm.js"
      },
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.3",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.2",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var warnedAboutCssPropForGlobal = false;
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (props.className || props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles3 = props.styles;
  var serialized = serializeStyles([styles3], void 0, React3.useContext(ThemeContext));
  if (!isBrowser2) {
    var _ref;
    var serializedNames = serialized.name;
    var serializedStyles = serialized.styles;
    var next2 = serialized.next;
    while (next2 !== void 0) {
      serializedNames += " " + next2.name;
      serializedStyles += next2.styles;
      next2 = next2.next;
    }
    var shouldCache = cache.compat === true;
    var rules = cache.insert("", {
      name: serializedNames,
      styles: serializedStyles
    }, cache.sheet, shouldCache);
    if (shouldCache) {
      return null;
    }
    return /* @__PURE__ */ React3.createElement("style", (_ref = {}, _ref["data-emotion"] = cache.key + "-global " + serializedNames, _ref.dangerouslySetInnerHTML = {
      __html: rules
    }, _ref.nonce = cache.sheet.nonce, _ref));
  }
  var sheetRef = React3.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
if (true) {
  Global.displayName = "EmotionGlobal";
}
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var classnames = function classnames2(args) {
  var len = args.length;
  var i = 0;
  var cls = "";
  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css4, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css4(registeredStyles);
}
var Insertion3 = function Insertion4(_ref) {
  var cache = _ref.cache, serializedArr = _ref.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i = 0; i < serializedArr.length; i++) {
      insertStyles(cache, serializedArr[i], false);
    }
  });
  return null;
};
var ClassNames = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var hasRendered = false;
  var serializedArr = [];
  var css4 = function css5() {
    if (hasRendered && true) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache.registered);
    serializedArr.push(serialized);
    registerStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };
  var cx2 = function cx3() {
    if (hasRendered && true) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache.registered, css4, classnames(args));
  };
  var content = {
    css: css4,
    cx: cx2,
    theme: React3.useContext(ThemeContext)
  };
  var ele = props.children(content);
  hasRendered = true;
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(Insertion3, {
    cache,
    serializedArr
  }), ele);
});
if (true) {
  ClassNames.displayName = "EmotionClassNames";
}
if (true) {
  isBrowser5 = true;
  isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser5 && !isTestEnv) {
    globalContext = // $FlowIgnore
    typeof globalThis !== "undefined" ? globalThis : isBrowser5 ? window : globalThis;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser5;
var isTestEnv;
var globalContext;
var globalKey;

// node_modules/@chakra-ui/css-reset/dist/chunk-B4LBJQ3X.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
"use client";
var css2 = String.raw;
var vhPolyfill = css2`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`;
var CSSPolyfill = () => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Global, { styles: vhPolyfill });
var CSSReset = ({ scope = "" }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
  Global,
  {
    styles: css2`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${scope} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${scope} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${scope} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${scope} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${scope} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${scope} :where(b, strong) {
        font-weight: bold;
      }

      ${scope} small {
        font-size: 80%;
      }

      ${scope} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${scope} sub {
        bottom: -0.25em;
      }

      ${scope} sup {
        top: -0.5em;
      }

      ${scope} img {
        border-style: none;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${scope} :where(button, input) {
        overflow: visible;
      }

      ${scope} :where(button, select) {
        text-transform: none;
      }

      ${scope} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${scope} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${scope} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${scope} progress {
        vertical-align: baseline;
      }

      ${scope} textarea {
        overflow: auto;
      }

      ${scope} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${scope} input[type="number"]::-webkit-inner-spin-button,
      ${scope} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${scope} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${scope} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${scope} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${scope} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${scope} details {
        display: block;
      }

      ${scope} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${scope} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${scope} button {
        background: transparent;
        padding: 0;
      }

      ${scope} fieldset {
        margin: 0;
        padding: 0;
      }

      ${scope} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${scope} textarea {
        resize: vertical;
      }

      ${scope} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${scope} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${scope} table {
        border-collapse: collapse;
      }

      ${scope} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${scope} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${scope} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${scope} select::-ms-expand {
        display: none;
      }

      ${vhPolyfill}
    `
  }
);

// node_modules/@chakra-ui/css-reset/dist/index.mjs
"use client";

// node_modules/@chakra-ui/react-context/dist/index.mjs
var import_react3 = __toESM(require_react(), 1);
"use client";
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext2(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react3.createContext)(defaultValue);
  Context.displayName = name;
  function useContext22() {
    var _a7;
    const context = (0, import_react3.useContext)(Context);
    if (!context && strict) {
      const error2 = new Error(
        errorMessage != null ? errorMessage : getErrorMessage(hookName, providerName)
      );
      error2.name = "ContextError";
      (_a7 = Error.captureStackTrace) == null ? void 0 : _a7.call(Error, error2, useContext22);
      throw error2;
    }
    return context;
  }
  return [Context.Provider, useContext22, Context];
}

// node_modules/@chakra-ui/portal/dist/chunk-HK66PB7M.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
"use client";
var [PortalManagerContextProvider, usePortalManager] = createContext2({
  strict: false,
  name: "PortalManagerContext"
});
function PortalManager(props) {
  const { children, zIndex } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(PortalManagerContextProvider, { value: { zIndex }, children });
}
PortalManager.displayName = "PortalManager";

// node_modules/@chakra-ui/react-use-safe-layout-effect/dist/index.mjs
var import_react4 = __toESM(require_react(), 1);
"use client";
var useSafeLayoutEffect = Boolean(globalThis == null ? void 0 : globalThis.document) ? import_react4.useLayoutEffect : import_react4.useEffect;

// node_modules/@chakra-ui/portal/dist/chunk-34PD6CUK.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
"use client";
var [PortalContextProvider, usePortalContext] = createContext2({
  strict: false,
  name: "PortalContext"
});
var PORTAL_CLASSNAME = "chakra-portal";
var PORTAL_SELECTOR = `.chakra-portal`;
var Container = (props) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
  "div",
  {
    className: "chakra-portal-zIndex",
    style: {
      position: "absolute",
      zIndex: props.zIndex,
      top: 0,
      left: 0,
      right: 0
      // NB: Don't add `bottom: 0`, it makes the entire app unusable
      // @see https://github.com/chakra-ui/chakra-ui/issues/3201
    },
    children: props.children
  }
);
var DefaultPortal = (props) => {
  const { appendToParentPortal, children } = props;
  const [tempNode, setTempNode] = (0, import_react5.useState)(null);
  const portal = (0, import_react5.useRef)(null);
  const [, forceUpdate] = (0, import_react5.useState)({});
  (0, import_react5.useEffect)(() => forceUpdate({}), []);
  const parentPortal = usePortalContext();
  const manager = usePortalManager();
  useSafeLayoutEffect(() => {
    if (!tempNode)
      return;
    const doc = tempNode.ownerDocument;
    const host = appendToParentPortal ? parentPortal != null ? parentPortal : doc.body : doc.body;
    if (!host)
      return;
    portal.current = doc.createElement("div");
    portal.current.className = PORTAL_CLASSNAME;
    host.appendChild(portal.current);
    forceUpdate({});
    const portalNode = portal.current;
    return () => {
      if (host.contains(portalNode)) {
        host.removeChild(portalNode);
      }
    };
  }, [tempNode]);
  const _children = (manager == null ? void 0 : manager.zIndex) ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Container, { zIndex: manager == null ? void 0 : manager.zIndex, children }) : children;
  return portal.current ? (0, import_react_dom.createPortal)(
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(PortalContextProvider, { value: portal.current, children: _children }),
    portal.current
  ) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    "span",
    {
      ref: (el) => {
        if (el)
          setTempNode(el);
      }
    }
  );
};
var ContainerPortal = (props) => {
  const { children, containerRef, appendToParentPortal } = props;
  const containerEl = containerRef.current;
  const host = containerEl != null ? containerEl : typeof window !== "undefined" ? document.body : void 0;
  const portal = (0, import_react5.useMemo)(() => {
    const node2 = containerEl == null ? void 0 : containerEl.ownerDocument.createElement("div");
    if (node2)
      node2.className = PORTAL_CLASSNAME;
    return node2;
  }, [containerEl]);
  const [, forceUpdate] = (0, import_react5.useState)({});
  useSafeLayoutEffect(() => forceUpdate({}), []);
  useSafeLayoutEffect(() => {
    if (!portal || !host)
      return;
    host.appendChild(portal);
    return () => {
      host.removeChild(portal);
    };
  }, [portal, host]);
  if (host && portal) {
    return (0, import_react_dom.createPortal)(
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(PortalContextProvider, { value: appendToParentPortal ? portal : null, children }),
      portal
    );
  }
  return null;
};
function Portal(props) {
  const portalProps = {
    appendToParentPortal: true,
    ...props
  };
  const { containerRef, ...rest } = portalProps;
  return containerRef ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(ContainerPortal, { containerRef, ...rest }) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(DefaultPortal, { ...rest });
}
Portal.className = PORTAL_CLASSNAME;
Portal.selector = PORTAL_SELECTOR;
Portal.displayName = "Portal";

// node_modules/@chakra-ui/portal/dist/index.mjs
"use client";

// node_modules/@chakra-ui/system/dist/chunk-UIGT7YZF.mjs
var import_react7 = __toESM(require_react(), 1);
"use client";
function useTheme2() {
  const theme3 = (0, import_react7.useContext)(
    ThemeContext
  );
  if (!theme3) {
    throw Error(
      "useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
    );
  }
  return theme3;
}

// node_modules/@chakra-ui/color-mode/dist/chunk-UQDW7KKV.mjs
var import_react8 = __toESM(require_react(), 1);
"use client";
var ColorModeContext = (0, import_react8.createContext)({});
ColorModeContext.displayName = "ColorModeContext";
function useColorMode() {
  const context = (0, import_react8.useContext)(ColorModeContext);
  if (context === void 0) {
    throw new Error("useColorMode must be used within a ColorModeProvider");
  }
  return context;
}

// node_modules/@chakra-ui/color-mode/dist/chunk-X7ZBZ4KW.mjs
"use client";
var classNames = {
  light: "chakra-ui-light",
  dark: "chakra-ui-dark"
};
function getColorModeUtils(options = {}) {
  const { preventTransition = true } = options;
  const utils = {
    setDataset: (value) => {
      const cleanup = preventTransition ? utils.preventTransition() : void 0;
      document.documentElement.dataset.theme = value;
      document.documentElement.style.colorScheme = value;
      cleanup == null ? void 0 : cleanup();
    },
    setClassName(dark) {
      document.body.classList.add(dark ? classNames.dark : classNames.light);
      document.body.classList.remove(dark ? classNames.light : classNames.dark);
    },
    query() {
      return window.matchMedia("(prefers-color-scheme: dark)");
    },
    getSystemTheme(fallback) {
      var _a7;
      const dark = (_a7 = utils.query().matches) != null ? _a7 : fallback === "dark";
      return dark ? "dark" : "light";
    },
    addListener(fn2) {
      const mql = utils.query();
      const listener = (e) => {
        fn2(e.matches ? "dark" : "light");
      };
      if (typeof mql.addListener === "function")
        mql.addListener(listener);
      else
        mql.addEventListener("change", listener);
      return () => {
        if (typeof mql.removeListener === "function")
          mql.removeListener(listener);
        else
          mql.removeEventListener("change", listener);
      };
    },
    preventTransition() {
      const css4 = document.createElement("style");
      css4.appendChild(
        document.createTextNode(
          `*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`
        )
      );
      document.head.appendChild(css4);
      return () => {
        ;
        (() => window.getComputedStyle(document.body))();
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            document.head.removeChild(css4);
          });
        });
      };
    }
  };
  return utils;
}

// node_modules/@chakra-ui/color-mode/dist/chunk-44OWBZ77.mjs
"use client";
var STORAGE_KEY = "chakra-ui-color-mode";
function createLocalStorageManager(key) {
  return {
    ssr: false,
    type: "localStorage",
    get(init) {
      if (!(globalThis == null ? void 0 : globalThis.document))
        return init;
      let value;
      try {
        value = localStorage.getItem(key) || init;
      } catch (e) {
      }
      return value || init;
    },
    set(value) {
      try {
        localStorage.setItem(key, value);
      } catch (e) {
      }
    }
  };
}
var localStorageManager = createLocalStorageManager(STORAGE_KEY);
function parseCookie(cookie, key) {
  const match2 = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match2 == null ? void 0 : match2[2];
}
function createCookieStorageManager(key, cookie) {
  return {
    ssr: !!cookie,
    type: "cookie",
    get(init) {
      if (cookie)
        return parseCookie(cookie, key);
      if (!(globalThis == null ? void 0 : globalThis.document))
        return init;
      return parseCookie(document.cookie, key) || init;
    },
    set(value) {
      document.cookie = `${key}=${value}; max-age=31536000; path=/`;
    }
  };
}
var cookieStorageManager = createCookieStorageManager(STORAGE_KEY);

// node_modules/@chakra-ui/color-mode/dist/chunk-AMBGAKG2.mjs
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
"use client";
var noop = () => {
};
function getTheme3(manager, fallback) {
  return manager.type === "cookie" && manager.ssr ? manager.get(fallback) : fallback;
}
function ColorModeProvider(props) {
  const {
    value,
    children,
    options: {
      useSystemColorMode,
      initialColorMode,
      disableTransitionOnChange
    } = {},
    colorModeManager = localStorageManager
  } = props;
  const defaultColorMode = initialColorMode === "dark" ? "dark" : "light";
  const [colorMode, rawSetColorMode] = (0, import_react9.useState)(
    () => getTheme3(colorModeManager, defaultColorMode)
  );
  const [resolvedColorMode, setResolvedColorMode] = (0, import_react9.useState)(
    () => getTheme3(colorModeManager)
  );
  const { getSystemTheme, setClassName, setDataset, addListener } = (0, import_react9.useMemo)(
    () => getColorModeUtils({ preventTransition: disableTransitionOnChange }),
    [disableTransitionOnChange]
  );
  const resolvedValue = initialColorMode === "system" && !colorMode ? resolvedColorMode : colorMode;
  const setColorMode = (0, import_react9.useCallback)(
    (value2) => {
      const resolved = value2 === "system" ? getSystemTheme() : value2;
      rawSetColorMode(resolved);
      setClassName(resolved === "dark");
      setDataset(resolved);
      colorModeManager.set(resolved);
    },
    [colorModeManager, getSystemTheme, setClassName, setDataset]
  );
  useSafeLayoutEffect(() => {
    if (initialColorMode === "system") {
      setResolvedColorMode(getSystemTheme());
    }
  }, []);
  (0, import_react9.useEffect)(() => {
    const managerValue = colorModeManager.get();
    if (managerValue) {
      setColorMode(managerValue);
      return;
    }
    if (initialColorMode === "system") {
      setColorMode("system");
      return;
    }
    setColorMode(defaultColorMode);
  }, [colorModeManager, defaultColorMode, initialColorMode, setColorMode]);
  const toggleColorMode = (0, import_react9.useCallback)(() => {
    setColorMode(resolvedValue === "dark" ? "light" : "dark");
  }, [resolvedValue, setColorMode]);
  (0, import_react9.useEffect)(() => {
    if (!useSystemColorMode)
      return;
    return addListener(setColorMode);
  }, [useSystemColorMode, addListener, setColorMode]);
  const context = (0, import_react9.useMemo)(
    () => ({
      colorMode: value != null ? value : resolvedValue,
      toggleColorMode: value ? noop : toggleColorMode,
      setColorMode: value ? noop : setColorMode,
      forced: value !== void 0
    }),
    [resolvedValue, toggleColorMode, setColorMode, value]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ColorModeContext.Provider, { value: context, children });
}
ColorModeProvider.displayName = "ColorModeProvider";
function DarkMode(props) {
  const context = (0, import_react9.useMemo)(
    () => ({
      colorMode: "dark",
      toggleColorMode: noop,
      setColorMode: noop,
      forced: true
    }),
    []
  );
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ColorModeContext.Provider, { value: context, ...props });
}
DarkMode.displayName = "DarkMode";
function LightMode(props) {
  const context = (0, import_react9.useMemo)(
    () => ({
      colorMode: "light",
      toggleColorMode: noop,
      setColorMode: noop,
      forced: true
    }),
    []
  );
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ColorModeContext.Provider, { value: context, ...props });
}
LightMode.displayName = "LightMode";

// node_modules/@chakra-ui/color-mode/dist/index.mjs
"use client";

// node_modules/@chakra-ui/system/dist/chunk-7FWEOSAE.mjs
"use client";
function useChakra() {
  const colorModeResult = useColorMode();
  const theme3 = useTheme2();
  return { ...colorModeResult, theme: theme3 };
}

// node_modules/@chakra-ui/shared-utils/dist/index.mjs
var cx = (...classNames2) => classNames2.filter(Boolean).join(" ");
function isObject(value) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function") && !Array.isArray(value);
}
function runIfFn(valueOrFn, ...args) {
  return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}
var isFunction = (value) => typeof value === "function";
var dataAttr = (condition) => condition ? "" : void 0;
var ariaAttr = (condition) => condition ? true : void 0;
function callAllHandlers(...fns) {
  return function func(event) {
    fns.some((fn2) => {
      fn2 == null ? void 0 : fn2(event);
      return event == null ? void 0 : event.defaultPrevented;
    });
  };
}
function callAll(...fns) {
  return function mergedFn(arg) {
    fns.forEach((fn2) => {
      fn2 == null ? void 0 : fn2(arg);
    });
  };
}

// node_modules/@chakra-ui/styled-system/dist/index.mjs
var import_lodash = __toESM(require_lodash(), 1);
var import_lodash2 = __toESM(require_lodash(), 1);
var import_lodash3 = __toESM(require_lodash(), 1);
var import_lodash4 = __toESM(require_lodash(), 1);
var isImportant = (value) => /!(important)?$/.test(value);
var withoutImportant = (value) => typeof value === "string" ? value.replace(/!(important)?$/, "").trim() : value;
var tokenToCSSVar = (scale2, value) => (theme3) => {
  const valueStr = String(value);
  const important = isImportant(valueStr);
  const valueWithoutImportant = withoutImportant(valueStr);
  const key = scale2 ? `${scale2}.${valueWithoutImportant}` : valueWithoutImportant;
  let transformed = isObject(theme3.__cssMap) && key in theme3.__cssMap ? theme3.__cssMap[key].varRef : value;
  transformed = withoutImportant(transformed);
  return important ? `${transformed} !important` : transformed;
};
function createTransform(options) {
  const { scale: scale2, transform: transform2, compose: compose2 } = options;
  const fn2 = (value, theme3) => {
    var _a7;
    const _value = tokenToCSSVar(scale2, value)(theme3);
    let result = (_a7 = transform2 == null ? void 0 : transform2(_value, theme3)) != null ? _a7 : _value;
    if (compose2) {
      result = compose2(result, theme3);
    }
    return result;
  };
  return fn2;
}
var pipe = (...fns) => (v) => fns.reduce((a2, b2) => b2(a2), v);
function toConfig(scale2, transform2) {
  return (property) => {
    const result = { property, scale: scale2 };
    result.transform = createTransform({
      scale: scale2,
      transform: transform2
    });
    return result;
  };
}
var getRtl = ({ rtl, ltr }) => (theme3) => theme3.direction === "rtl" ? rtl : ltr;
function logical(options) {
  const { property, scale: scale2, transform: transform2 } = options;
  return {
    scale: scale2,
    property: getRtl(property),
    transform: scale2 ? createTransform({
      scale: scale2,
      compose: transform2
    }) : transform2
  };
}
var transformTemplate = [
  "rotate(var(--chakra-rotate, 0))",
  "scaleX(var(--chakra-scale-x, 1))",
  "scaleY(var(--chakra-scale-y, 1))",
  "skewX(var(--chakra-skew-x, 0))",
  "skewY(var(--chakra-skew-y, 0))"
];
function getTransformTemplate() {
  return [
    "translateX(var(--chakra-translate-x, 0))",
    "translateY(var(--chakra-translate-y, 0))",
    ...transformTemplate
  ].join(" ");
}
function getTransformGpuTemplate() {
  return [
    "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
    ...transformTemplate
  ].join(" ");
}
var filterTemplate = {
  "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
  filter: [
    "var(--chakra-blur)",
    "var(--chakra-brightness)",
    "var(--chakra-contrast)",
    "var(--chakra-grayscale)",
    "var(--chakra-hue-rotate)",
    "var(--chakra-invert)",
    "var(--chakra-saturate)",
    "var(--chakra-sepia)",
    "var(--chakra-drop-shadow)"
  ].join(" ")
};
var backdropFilterTemplate = {
  backdropFilter: [
    "var(--chakra-backdrop-blur)",
    "var(--chakra-backdrop-brightness)",
    "var(--chakra-backdrop-contrast)",
    "var(--chakra-backdrop-grayscale)",
    "var(--chakra-backdrop-hue-rotate)",
    "var(--chakra-backdrop-invert)",
    "var(--chakra-backdrop-opacity)",
    "var(--chakra-backdrop-saturate)",
    "var(--chakra-backdrop-sepia)"
  ].join(" "),
  "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};
function getRingTemplate(value) {
  return {
    "--chakra-ring-offset-shadow": `var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)`,
    "--chakra-ring-shadow": `var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)`,
    "--chakra-ring-width": value,
    boxShadow: [
      `var(--chakra-ring-offset-shadow)`,
      `var(--chakra-ring-shadow)`,
      `var(--chakra-shadow, 0 0 #0000)`
    ].join(", ")
  };
}
var flexDirectionTemplate = {
  "row-reverse": {
    space: "--chakra-space-x-reverse",
    divide: "--chakra-divide-x-reverse"
  },
  "column-reverse": {
    space: "--chakra-space-y-reverse",
    divide: "--chakra-divide-y-reverse"
  }
};
var directionMap = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
};
var valueSet = new Set(Object.values(directionMap));
var globalSet = /* @__PURE__ */ new Set(
  [
    "none",
    "-moz-initial",
    "inherit",
    "initial",
    "revert",
    "unset"
  ]
);
var trimSpace = (str) => str.trim();
function parseGradient(value, theme3) {
  if (value == null || globalSet.has(value))
    return value;
  const prevent = isCSSFunction(value) || globalSet.has(value);
  if (!prevent)
    return `url('${value}')`;
  const regex = /(^[a-z-A-Z]+)\((.*)\)/g;
  const results = regex.exec(value);
  const type = results == null ? void 0 : results[1];
  const values = results == null ? void 0 : results[2];
  if (!type || !values)
    return value;
  const _type = type.includes("-gradient") ? type : `${type}-gradient`;
  const [maybeDirection, ...stops] = values.split(",").map(trimSpace).filter(Boolean);
  if ((stops == null ? void 0 : stops.length) === 0)
    return value;
  const direction2 = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
  stops.unshift(direction2);
  const _values = stops.map((stop) => {
    if (valueSet.has(stop))
      return stop;
    const firstStop = stop.indexOf(" ");
    const [_color, _stop] = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop];
    const _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(" ");
    const key = `colors.${_color}`;
    const color22 = key in theme3.__cssMap ? theme3.__cssMap[key].varRef : _color;
    return _stopOrFunc ? [
      color22,
      ...Array.isArray(_stopOrFunc) ? _stopOrFunc : [_stopOrFunc]
    ].join(" ") : color22;
  });
  return `${_type}(${_values.join(", ")})`;
}
var isCSSFunction = (value) => {
  return typeof value === "string" && value.includes("(") && value.includes(")");
};
var gradientTransform = (value, theme3) => parseGradient(value, theme3 != null ? theme3 : {});
function isCssVar(value) {
  return /^var\(--.+\)$/.test(value);
}
var analyzeCSSValue = (value) => {
  const num = parseFloat(value.toString());
  const unit = value.toString().replace(String(num), "");
  return { unitless: !unit, value: num, unit };
};
var wrap = (str) => (value) => `${str}(${value})`;
var transformFunctions = {
  filter(value) {
    return value !== "auto" ? value : filterTemplate;
  },
  backdropFilter(value) {
    return value !== "auto" ? value : backdropFilterTemplate;
  },
  ring(value) {
    return getRingTemplate(transformFunctions.px(value));
  },
  bgClip(value) {
    return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
  },
  transform(value) {
    if (value === "auto")
      return getTransformTemplate();
    if (value === "auto-gpu")
      return getTransformGpuTemplate();
    return value;
  },
  vh(value) {
    return value === "$100vh" ? "var(--chakra-vh)" : value;
  },
  px(value) {
    if (value == null)
      return value;
    const { unitless } = analyzeCSSValue(value);
    return unitless || typeof value === "number" ? `${value}px` : value;
  },
  fraction(value) {
    return !(typeof value === "number") || value > 1 ? value : `${value * 100}%`;
  },
  float(value, theme3) {
    const map = { left: "right", right: "left" };
    return theme3.direction === "rtl" ? map[value] : value;
  },
  degree(value) {
    if (isCssVar(value) || value == null)
      return value;
    const unitless = typeof value === "string" && !value.endsWith("deg");
    return typeof value === "number" || unitless ? `${value}deg` : value;
  },
  gradient: gradientTransform,
  blur: wrap("blur"),
  opacity: wrap("opacity"),
  brightness: wrap("brightness"),
  contrast: wrap("contrast"),
  dropShadow: wrap("drop-shadow"),
  grayscale: wrap("grayscale"),
  hueRotate: (value) => wrap("hue-rotate")(transformFunctions.degree(value)),
  invert: wrap("invert"),
  saturate: wrap("saturate"),
  sepia: wrap("sepia"),
  bgImage(value) {
    if (value == null)
      return value;
    const prevent = isCSSFunction(value) || globalSet.has(value);
    return !prevent ? `url(${value})` : value;
  },
  outline(value) {
    const isNoneOrZero = String(value) === "0" || String(value) === "none";
    return value !== null && isNoneOrZero ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: value };
  },
  flexDirection(value) {
    var _a7;
    const { space: space2, divide: divide22 } = (_a7 = flexDirectionTemplate[value]) != null ? _a7 : {};
    const result = { flexDirection: value };
    if (space2)
      result[space2] = 1;
    if (divide22)
      result[divide22] = 1;
    return result;
  }
};
var t = {
  borderWidths: toConfig("borderWidths"),
  borderStyles: toConfig("borderStyles"),
  colors: toConfig("colors"),
  borders: toConfig("borders"),
  gradients: toConfig("gradients", transformFunctions.gradient),
  radii: toConfig("radii", transformFunctions.px),
  space: toConfig("space", pipe(transformFunctions.vh, transformFunctions.px)),
  spaceT: toConfig("space", pipe(transformFunctions.vh, transformFunctions.px)),
  degreeT(property) {
    return { property, transform: transformFunctions.degree };
  },
  prop(property, scale2, transform2) {
    return {
      property,
      scale: scale2,
      ...scale2 && {
        transform: createTransform({ scale: scale2, transform: transform2 })
      }
    };
  },
  propT(property, transform2) {
    return { property, transform: transform2 };
  },
  sizes: toConfig("sizes", pipe(transformFunctions.vh, transformFunctions.px)),
  sizesT: toConfig("sizes", pipe(transformFunctions.vh, transformFunctions.fraction)),
  shadows: toConfig("shadows"),
  logical,
  blur: toConfig("blur", transformFunctions.blur)
};
var background = {
  background: t.colors("background"),
  backgroundColor: t.colors("backgroundColor"),
  backgroundImage: t.gradients("backgroundImage"),
  backgroundSize: true,
  backgroundPosition: true,
  backgroundRepeat: true,
  backgroundAttachment: true,
  backgroundClip: { transform: transformFunctions.bgClip },
  bgSize: t.prop("backgroundSize"),
  bgPosition: t.prop("backgroundPosition"),
  bg: t.colors("background"),
  bgColor: t.colors("backgroundColor"),
  bgPos: t.prop("backgroundPosition"),
  bgRepeat: t.prop("backgroundRepeat"),
  bgAttachment: t.prop("backgroundAttachment"),
  bgGradient: t.gradients("backgroundImage"),
  bgClip: { transform: transformFunctions.bgClip }
};
Object.assign(background, {
  bgImage: background.backgroundImage,
  bgImg: background.backgroundImage
});
var border = {
  border: t.borders("border"),
  borderWidth: t.borderWidths("borderWidth"),
  borderStyle: t.borderStyles("borderStyle"),
  borderColor: t.colors("borderColor"),
  borderRadius: t.radii("borderRadius"),
  borderTop: t.borders("borderTop"),
  borderBlockStart: t.borders("borderBlockStart"),
  borderTopLeftRadius: t.radii("borderTopLeftRadius"),
  borderStartStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopLeftRadius",
      rtl: "borderTopRightRadius"
    }
  }),
  borderEndStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomLeftRadius",
      rtl: "borderBottomRightRadius"
    }
  }),
  borderTopRightRadius: t.radii("borderTopRightRadius"),
  borderStartEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopRightRadius",
      rtl: "borderTopLeftRadius"
    }
  }),
  borderEndEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomRightRadius",
      rtl: "borderBottomLeftRadius"
    }
  }),
  borderRight: t.borders("borderRight"),
  borderInlineEnd: t.borders("borderInlineEnd"),
  borderBottom: t.borders("borderBottom"),
  borderBlockEnd: t.borders("borderBlockEnd"),
  borderBottomLeftRadius: t.radii("borderBottomLeftRadius"),
  borderBottomRightRadius: t.radii("borderBottomRightRadius"),
  borderLeft: t.borders("borderLeft"),
  borderInlineStart: {
    property: "borderInlineStart",
    scale: "borders"
  },
  borderInlineStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
      rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
    }
  }),
  borderInlineEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
      rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
    }
  }),
  borderX: t.borders(["borderLeft", "borderRight"]),
  borderInline: t.borders("borderInline"),
  borderY: t.borders(["borderTop", "borderBottom"]),
  borderBlock: t.borders("borderBlock"),
  borderTopWidth: t.borderWidths("borderTopWidth"),
  borderBlockStartWidth: t.borderWidths("borderBlockStartWidth"),
  borderTopColor: t.colors("borderTopColor"),
  borderBlockStartColor: t.colors("borderBlockStartColor"),
  borderTopStyle: t.borderStyles("borderTopStyle"),
  borderBlockStartStyle: t.borderStyles("borderBlockStartStyle"),
  borderBottomWidth: t.borderWidths("borderBottomWidth"),
  borderBlockEndWidth: t.borderWidths("borderBlockEndWidth"),
  borderBottomColor: t.colors("borderBottomColor"),
  borderBlockEndColor: t.colors("borderBlockEndColor"),
  borderBottomStyle: t.borderStyles("borderBottomStyle"),
  borderBlockEndStyle: t.borderStyles("borderBlockEndStyle"),
  borderLeftWidth: t.borderWidths("borderLeftWidth"),
  borderInlineStartWidth: t.borderWidths("borderInlineStartWidth"),
  borderLeftColor: t.colors("borderLeftColor"),
  borderInlineStartColor: t.colors("borderInlineStartColor"),
  borderLeftStyle: t.borderStyles("borderLeftStyle"),
  borderInlineStartStyle: t.borderStyles("borderInlineStartStyle"),
  borderRightWidth: t.borderWidths("borderRightWidth"),
  borderInlineEndWidth: t.borderWidths("borderInlineEndWidth"),
  borderRightColor: t.colors("borderRightColor"),
  borderInlineEndColor: t.colors("borderInlineEndColor"),
  borderRightStyle: t.borderStyles("borderRightStyle"),
  borderInlineEndStyle: t.borderStyles("borderInlineEndStyle"),
  borderTopRadius: t.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
  borderBottomRadius: t.radii(
    [
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  ),
  borderLeftRadius: t.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
  borderRightRadius: t.radii(
    [
      "borderTopRightRadius",
      "borderBottomRightRadius"
    ]
  )
};
Object.assign(border, {
  rounded: border.borderRadius,
  roundedTop: border.borderTopRadius,
  roundedTopLeft: border.borderTopLeftRadius,
  roundedTopRight: border.borderTopRightRadius,
  roundedTopStart: border.borderStartStartRadius,
  roundedTopEnd: border.borderStartEndRadius,
  roundedBottom: border.borderBottomRadius,
  roundedBottomLeft: border.borderBottomLeftRadius,
  roundedBottomRight: border.borderBottomRightRadius,
  roundedBottomStart: border.borderEndStartRadius,
  roundedBottomEnd: border.borderEndEndRadius,
  roundedLeft: border.borderLeftRadius,
  roundedRight: border.borderRightRadius,
  roundedStart: border.borderInlineStartRadius,
  roundedEnd: border.borderInlineEndRadius,
  borderStart: border.borderInlineStart,
  borderEnd: border.borderInlineEnd,
  borderTopStartRadius: border.borderStartStartRadius,
  borderTopEndRadius: border.borderStartEndRadius,
  borderBottomStartRadius: border.borderEndStartRadius,
  borderBottomEndRadius: border.borderEndEndRadius,
  borderStartRadius: border.borderInlineStartRadius,
  borderEndRadius: border.borderInlineEndRadius,
  borderStartWidth: border.borderInlineStartWidth,
  borderEndWidth: border.borderInlineEndWidth,
  borderStartColor: border.borderInlineStartColor,
  borderEndColor: border.borderInlineEndColor,
  borderStartStyle: border.borderInlineStartStyle,
  borderEndStyle: border.borderInlineEndStyle
});
var color = {
  color: t.colors("color"),
  textColor: t.colors("color"),
  fill: t.colors("fill"),
  stroke: t.colors("stroke")
};
var effect = {
  boxShadow: t.shadows("boxShadow"),
  mixBlendMode: true,
  blendMode: t.prop("mixBlendMode"),
  backgroundBlendMode: true,
  bgBlendMode: t.prop("backgroundBlendMode"),
  opacity: true
};
Object.assign(effect, {
  shadow: effect.boxShadow
});
var filter = {
  filter: { transform: transformFunctions.filter },
  blur: t.blur("--chakra-blur"),
  brightness: t.propT("--chakra-brightness", transformFunctions.brightness),
  contrast: t.propT("--chakra-contrast", transformFunctions.contrast),
  hueRotate: t.propT("--chakra-hue-rotate", transformFunctions.hueRotate),
  invert: t.propT("--chakra-invert", transformFunctions.invert),
  saturate: t.propT("--chakra-saturate", transformFunctions.saturate),
  dropShadow: t.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
  backdropFilter: { transform: transformFunctions.backdropFilter },
  backdropBlur: t.blur("--chakra-backdrop-blur"),
  backdropBrightness: t.propT(
    "--chakra-backdrop-brightness",
    transformFunctions.brightness
  ),
  backdropContrast: t.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
  backdropHueRotate: t.propT(
    "--chakra-backdrop-hue-rotate",
    transformFunctions.hueRotate
  ),
  backdropInvert: t.propT("--chakra-backdrop-invert", transformFunctions.invert),
  backdropSaturate: t.propT("--chakra-backdrop-saturate", transformFunctions.saturate)
};
var flexbox = {
  alignItems: true,
  alignContent: true,
  justifyItems: true,
  justifyContent: true,
  flexWrap: true,
  flexDirection: { transform: transformFunctions.flexDirection },
  flex: true,
  flexFlow: true,
  flexGrow: true,
  flexShrink: true,
  flexBasis: t.sizes("flexBasis"),
  justifySelf: true,
  alignSelf: true,
  order: true,
  placeItems: true,
  placeContent: true,
  placeSelf: true,
  gap: t.space("gap"),
  rowGap: t.space("rowGap"),
  columnGap: t.space("columnGap")
};
Object.assign(flexbox, {
  flexDir: flexbox.flexDirection
});
var grid = {
  gridGap: t.space("gridGap"),
  gridColumnGap: t.space("gridColumnGap"),
  gridRowGap: t.space("gridRowGap"),
  gridColumn: true,
  gridRow: true,
  gridAutoFlow: true,
  gridAutoColumns: true,
  gridColumnStart: true,
  gridColumnEnd: true,
  gridRowStart: true,
  gridRowEnd: true,
  gridAutoRows: true,
  gridTemplate: true,
  gridTemplateColumns: true,
  gridTemplateRows: true,
  gridTemplateAreas: true,
  gridArea: true
};
var interactivity = {
  appearance: true,
  cursor: true,
  resize: true,
  userSelect: true,
  pointerEvents: true,
  outline: { transform: transformFunctions.outline },
  outlineOffset: true,
  outlineColor: t.colors("outlineColor")
};
var layout = {
  width: t.sizesT("width"),
  inlineSize: t.sizesT("inlineSize"),
  height: t.sizes("height"),
  blockSize: t.sizes("blockSize"),
  boxSize: t.sizes(["width", "height"]),
  minWidth: t.sizes("minWidth"),
  minInlineSize: t.sizes("minInlineSize"),
  minHeight: t.sizes("minHeight"),
  minBlockSize: t.sizes("minBlockSize"),
  maxWidth: t.sizes("maxWidth"),
  maxInlineSize: t.sizes("maxInlineSize"),
  maxHeight: t.sizes("maxHeight"),
  maxBlockSize: t.sizes("maxBlockSize"),
  overflow: true,
  overflowX: true,
  overflowY: true,
  overscrollBehavior: true,
  overscrollBehaviorX: true,
  overscrollBehaviorY: true,
  display: true,
  aspectRatio: true,
  hideFrom: {
    scale: "breakpoints",
    transform: (value, theme3) => {
      var _a7, _b5, _c14;
      const breakpoint = (_c14 = (_b5 = (_a7 = theme3.__breakpoints) == null ? void 0 : _a7.get(value)) == null ? void 0 : _b5.minW) != null ? _c14 : value;
      const mq = `@media screen and (min-width: ${breakpoint})`;
      return { [mq]: { display: "none" } };
    }
  },
  hideBelow: {
    scale: "breakpoints",
    transform: (value, theme3) => {
      var _a7, _b5, _c14;
      const breakpoint = (_c14 = (_b5 = (_a7 = theme3.__breakpoints) == null ? void 0 : _a7.get(value)) == null ? void 0 : _b5._minW) != null ? _c14 : value;
      const mq = `@media screen and (max-width: ${breakpoint})`;
      return { [mq]: { display: "none" } };
    }
  },
  verticalAlign: true,
  boxSizing: true,
  boxDecorationBreak: true,
  float: t.propT("float", transformFunctions.float),
  objectFit: true,
  objectPosition: true,
  visibility: true,
  isolation: true
};
Object.assign(layout, {
  w: layout.width,
  h: layout.height,
  minW: layout.minWidth,
  maxW: layout.maxWidth,
  minH: layout.minHeight,
  maxH: layout.maxHeight,
  overscroll: layout.overscrollBehavior,
  overscrollX: layout.overscrollBehaviorX,
  overscrollY: layout.overscrollBehaviorY
});
var list = {
  listStyleType: true,
  listStylePosition: true,
  listStylePos: t.prop("listStylePosition"),
  listStyleImage: true,
  listStyleImg: t.prop("listStyleImage")
};
function get(obj, path, fallback, index3) {
  const key = typeof path === "string" ? path.split(".") : [path];
  for (index3 = 0; index3 < key.length; index3 += 1) {
    if (!obj)
      break;
    obj = obj[key[index3]];
  }
  return obj === void 0 ? fallback : obj;
}
var memoize2 = (fn2) => {
  const cache = /* @__PURE__ */ new WeakMap();
  const memoizedFn = (obj, path, fallback, index3) => {
    if (typeof obj === "undefined") {
      return fn2(obj, path, fallback);
    }
    if (!cache.has(obj)) {
      cache.set(obj, /* @__PURE__ */ new Map());
    }
    const map = cache.get(obj);
    if (map.has(path)) {
      return map.get(path);
    }
    const value = fn2(obj, path, fallback, index3);
    map.set(path, value);
    return value;
  };
  return memoizedFn;
};
var memoizedGet = memoize2(get);
var srOnly = {
  border: "0px",
  clip: "rect(0, 0, 0, 0)",
  width: "1px",
  height: "1px",
  margin: "-1px",
  padding: "0px",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
var srFocusable = {
  position: "static",
  width: "auto",
  height: "auto",
  clip: "auto",
  padding: "0",
  margin: "0",
  overflow: "visible",
  whiteSpace: "normal"
};
var getWithPriority = (theme3, key, styles3) => {
  const result = {};
  const obj = memoizedGet(theme3, key, {});
  for (const prop in obj) {
    const isInStyles = prop in styles3 && styles3[prop] != null;
    if (!isInStyles)
      result[prop] = obj[prop];
  }
  return result;
};
var others = {
  srOnly: {
    transform(value) {
      if (value === true)
        return srOnly;
      if (value === "focusable")
        return srFocusable;
      return {};
    }
  },
  layerStyle: {
    processResult: true,
    transform: (value, theme3, styles3) => getWithPriority(theme3, `layerStyles.${value}`, styles3)
  },
  textStyle: {
    processResult: true,
    transform: (value, theme3, styles3) => getWithPriority(theme3, `textStyles.${value}`, styles3)
  },
  apply: {
    processResult: true,
    transform: (value, theme3, styles3) => getWithPriority(theme3, value, styles3)
  }
};
var position2 = {
  position: true,
  pos: t.prop("position"),
  zIndex: t.prop("zIndex", "zIndices"),
  inset: t.spaceT("inset"),
  insetX: t.spaceT(["left", "right"]),
  insetInline: t.spaceT("insetInline"),
  insetY: t.spaceT(["top", "bottom"]),
  insetBlock: t.spaceT("insetBlock"),
  top: t.spaceT("top"),
  insetBlockStart: t.spaceT("insetBlockStart"),
  bottom: t.spaceT("bottom"),
  insetBlockEnd: t.spaceT("insetBlockEnd"),
  left: t.spaceT("left"),
  insetInlineStart: t.logical({
    scale: "space",
    property: { ltr: "left", rtl: "right" }
  }),
  right: t.spaceT("right"),
  insetInlineEnd: t.logical({
    scale: "space",
    property: { ltr: "right", rtl: "left" }
  })
};
Object.assign(position2, {
  insetStart: position2.insetInlineStart,
  insetEnd: position2.insetInlineEnd
});
var ring = {
  ring: { transform: transformFunctions.ring },
  ringColor: t.colors("--chakra-ring-color"),
  ringOffset: t.prop("--chakra-ring-offset-width"),
  ringOffsetColor: t.colors("--chakra-ring-offset-color"),
  ringInset: t.prop("--chakra-ring-inset")
};
var space = {
  margin: t.spaceT("margin"),
  marginTop: t.spaceT("marginTop"),
  marginBlockStart: t.spaceT("marginBlockStart"),
  marginRight: t.spaceT("marginRight"),
  marginInlineEnd: t.spaceT("marginInlineEnd"),
  marginBottom: t.spaceT("marginBottom"),
  marginBlockEnd: t.spaceT("marginBlockEnd"),
  marginLeft: t.spaceT("marginLeft"),
  marginInlineStart: t.spaceT("marginInlineStart"),
  marginX: t.spaceT(["marginInlineStart", "marginInlineEnd"]),
  marginInline: t.spaceT("marginInline"),
  marginY: t.spaceT(["marginTop", "marginBottom"]),
  marginBlock: t.spaceT("marginBlock"),
  padding: t.space("padding"),
  paddingTop: t.space("paddingTop"),
  paddingBlockStart: t.space("paddingBlockStart"),
  paddingRight: t.space("paddingRight"),
  paddingBottom: t.space("paddingBottom"),
  paddingBlockEnd: t.space("paddingBlockEnd"),
  paddingLeft: t.space("paddingLeft"),
  paddingInlineStart: t.space("paddingInlineStart"),
  paddingInlineEnd: t.space("paddingInlineEnd"),
  paddingX: t.space(["paddingInlineStart", "paddingInlineEnd"]),
  paddingInline: t.space("paddingInline"),
  paddingY: t.space(["paddingTop", "paddingBottom"]),
  paddingBlock: t.space("paddingBlock")
};
Object.assign(space, {
  m: space.margin,
  mt: space.marginTop,
  mr: space.marginRight,
  me: space.marginInlineEnd,
  marginEnd: space.marginInlineEnd,
  mb: space.marginBottom,
  ml: space.marginLeft,
  ms: space.marginInlineStart,
  marginStart: space.marginInlineStart,
  mx: space.marginX,
  my: space.marginY,
  p: space.padding,
  pt: space.paddingTop,
  py: space.paddingY,
  px: space.paddingX,
  pb: space.paddingBottom,
  pl: space.paddingLeft,
  ps: space.paddingInlineStart,
  paddingStart: space.paddingInlineStart,
  pr: space.paddingRight,
  pe: space.paddingInlineEnd,
  paddingEnd: space.paddingInlineEnd
});
var textDecoration = {
  textDecorationColor: t.colors("textDecorationColor"),
  textDecoration: true,
  textDecor: { property: "textDecoration" },
  textDecorationLine: true,
  textDecorationStyle: true,
  textDecorationThickness: true,
  textUnderlineOffset: true,
  textShadow: t.shadows("textShadow")
};
var transform = {
  clipPath: true,
  transform: t.propT("transform", transformFunctions.transform),
  transformOrigin: true,
  translateX: t.spaceT("--chakra-translate-x"),
  translateY: t.spaceT("--chakra-translate-y"),
  skewX: t.degreeT("--chakra-skew-x"),
  skewY: t.degreeT("--chakra-skew-y"),
  scaleX: t.prop("--chakra-scale-x"),
  scaleY: t.prop("--chakra-scale-y"),
  scale: t.prop(["--chakra-scale-x", "--chakra-scale-y"]),
  rotate: t.degreeT("--chakra-rotate")
};
var transition = {
  transition: true,
  transitionDelay: true,
  animation: true,
  willChange: true,
  transitionDuration: t.prop("transitionDuration", "transition.duration"),
  transitionProperty: t.prop("transitionProperty", "transition.property"),
  transitionTimingFunction: t.prop(
    "transitionTimingFunction",
    "transition.easing"
  )
};
var typography = {
  fontFamily: t.prop("fontFamily", "fonts"),
  fontSize: t.prop("fontSize", "fontSizes", transformFunctions.px),
  fontWeight: t.prop("fontWeight", "fontWeights"),
  lineHeight: t.prop("lineHeight", "lineHeights"),
  letterSpacing: t.prop("letterSpacing", "letterSpacings"),
  textAlign: true,
  fontStyle: true,
  textIndent: true,
  wordBreak: true,
  overflowWrap: true,
  textOverflow: true,
  textTransform: true,
  whiteSpace: true,
  isTruncated: {
    transform(value) {
      if (value === true) {
        return {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
      }
    }
  },
  noOfLines: {
    static: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      //@ts-ignore
      WebkitLineClamp: "var(--chakra-line-clamp)"
    },
    property: "--chakra-line-clamp"
  }
};
var scroll = {
  scrollBehavior: true,
  scrollSnapAlign: true,
  scrollSnapStop: true,
  scrollSnapType: true,
  // scroll margin
  scrollMargin: t.spaceT("scrollMargin"),
  scrollMarginTop: t.spaceT("scrollMarginTop"),
  scrollMarginBottom: t.spaceT("scrollMarginBottom"),
  scrollMarginLeft: t.spaceT("scrollMarginLeft"),
  scrollMarginRight: t.spaceT("scrollMarginRight"),
  scrollMarginX: t.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
  scrollMarginY: t.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
  // scroll padding
  scrollPadding: t.spaceT("scrollPadding"),
  scrollPaddingTop: t.spaceT("scrollPaddingTop"),
  scrollPaddingBottom: t.spaceT("scrollPaddingBottom"),
  scrollPaddingLeft: t.spaceT("scrollPaddingLeft"),
  scrollPaddingRight: t.spaceT("scrollPaddingRight"),
  scrollPaddingX: t.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
  scrollPaddingY: t.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
};
function resolveReference(operand) {
  if (isObject(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
var add = (...operands) => `calc(${toExpression("+", ...operands)})`;
var subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
var multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
var divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
var negate = (x) => {
  const value = resolveReference(x);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
var calc = Object.assign(
  (x) => ({
    add: (...operands) => calc(add(x, ...operands)),
    subtract: (...operands) => calc(subtract(x, ...operands)),
    multiply: (...operands) => calc(multiply(x, ...operands)),
    divide: (...operands) => calc(divide(x, ...operands)),
    negate: () => calc(negate(x)),
    toString: () => x.toString()
  }),
  {
    add,
    subtract,
    multiply,
    divide,
    negate
  }
);
function replaceWhiteSpace(value, replaceValue = "-") {
  return value.replace(/\s+/g, replaceValue);
}
function escape(value) {
  const valueStr = replaceWhiteSpace(value.toString());
  return escapeSymbol(escapeDot(valueStr));
}
function escapeDot(value) {
  if (value.includes("\\."))
    return value;
  const isDecimal2 = !Number.isInteger(parseFloat(value.toString()));
  return isDecimal2 ? value.replace(".", `\\.`) : value;
}
function escapeSymbol(value) {
  return value.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
}
function addPrefix(value, prefix2 = "") {
  return [prefix2, value].filter(Boolean).join("-");
}
function toVarReference(name, fallback) {
  return `var(${name}${fallback ? `, ${fallback}` : ""})`;
}
function toVarDefinition(value, prefix2 = "") {
  return escape(`--${addPrefix(value, prefix2)}`);
}
function cssVar(name, fallback, cssVarPrefix) {
  const cssVariable = toVarDefinition(name, cssVarPrefix);
  return {
    variable: cssVariable,
    reference: toVarReference(cssVariable, fallback)
  };
}
function defineCssVars(scope, keys2) {
  const vars2 = {};
  for (const key of keys2) {
    if (Array.isArray(key)) {
      const [name, fallback] = key;
      vars2[name] = cssVar(`${scope}-${name}`, fallback);
      continue;
    }
    vars2[key] = cssVar(`${scope}-${key}`);
  }
  return vars2;
}
function getLastItem(array) {
  const length2 = array == null ? 0 : array.length;
  return length2 ? array[length2 - 1] : void 0;
}
function analyzeCSSValue2(value) {
  const num = parseFloat(value.toString());
  const unit = value.toString().replace(String(num), "");
  return { unitless: !unit, value: num, unit };
}
function px(value) {
  if (value == null)
    return value;
  const { unitless } = analyzeCSSValue2(value);
  return unitless || typeof value === "number" ? `${value}px` : value;
}
var sortByBreakpointValue = (a2, b2) => parseInt(a2[1], 10) > parseInt(b2[1], 10) ? 1 : -1;
var sortBps = (breakpoints3) => Object.fromEntries(Object.entries(breakpoints3).sort(sortByBreakpointValue));
function normalize(breakpoints3) {
  const sorted = sortBps(breakpoints3);
  return Object.assign(Object.values(sorted), sorted);
}
function keys(breakpoints3) {
  const value = Object.keys(sortBps(breakpoints3));
  return new Set(value);
}
function subtract2(value) {
  var _a7;
  if (!value)
    return value;
  value = (_a7 = px(value)) != null ? _a7 : value;
  const OFFSET = -0.02;
  return typeof value === "number" ? `${value + OFFSET}` : value.replace(/(\d+\.?\d*)/u, (m) => `${parseFloat(m) + OFFSET}`);
}
function toMediaQueryString(min2, max2) {
  const query = ["@media screen"];
  if (min2)
    query.push("and", `(min-width: ${px(min2)})`);
  if (max2)
    query.push("and", `(max-width: ${px(max2)})`);
  return query.join(" ");
}
function analyzeBreakpoints(breakpoints3) {
  var _a7;
  if (!breakpoints3)
    return null;
  breakpoints3.base = (_a7 = breakpoints3.base) != null ? _a7 : "0px";
  const normalized = normalize(breakpoints3);
  const queries = Object.entries(breakpoints3).sort(sortByBreakpointValue).map(([breakpoint, minW], index3, entry) => {
    var _a24;
    let [, maxW] = (_a24 = entry[index3 + 1]) != null ? _a24 : [];
    maxW = parseFloat(maxW) > 0 ? subtract2(maxW) : void 0;
    return {
      _minW: subtract2(minW),
      breakpoint,
      minW,
      maxW,
      maxWQuery: toMediaQueryString(null, maxW),
      minWQuery: toMediaQueryString(minW),
      minMaxQuery: toMediaQueryString(minW, maxW)
    };
  });
  const _keys = keys(breakpoints3);
  const _keysArr = Array.from(_keys.values());
  return {
    keys: _keys,
    normalized,
    isResponsive(test2) {
      const keys2 = Object.keys(test2);
      return keys2.length > 0 && keys2.every((key) => _keys.has(key));
    },
    asObject: sortBps(breakpoints3),
    asArray: normalize(breakpoints3),
    details: queries,
    get(key) {
      return queries.find((q) => q.breakpoint === key);
    },
    media: [
      null,
      ...normalized.map((minW) => toMediaQueryString(minW)).slice(1)
    ],
    /**
     * Converts the object responsive syntax to array syntax
     *
     * @example
     * toArrayValue({ base: 1, sm: 2, md: 3 }) // => [1, 2, 3]
     */
    toArrayValue(test2) {
      if (!isObject(test2)) {
        throw new Error("toArrayValue: value must be an object");
      }
      const result = _keysArr.map((bp) => {
        var _a24;
        return (_a24 = test2[bp]) != null ? _a24 : null;
      });
      while (getLastItem(result) === null) {
        result.pop();
      }
      return result;
    },
    /**
     * Converts the array responsive syntax to object syntax
     *
     * @example
     * toObjectValue([1, 2, 3]) // => { base: 1, sm: 2, md: 3 }
     */
    toObjectValue(test2) {
      if (!Array.isArray(test2)) {
        throw new Error("toObjectValue: value must be an array");
      }
      return test2.reduce((acc, value, index3) => {
        const key = _keysArr[index3];
        if (key != null && value != null)
          acc[key] = value;
        return acc;
      }, {});
    }
  };
}
var state = {
  hover: (str, post) => `${str}:hover ${post}, ${str}[data-hover] ${post}`,
  focus: (str, post) => `${str}:focus ${post}, ${str}[data-focus] ${post}`,
  focusVisible: (str, post) => `${str}:focus-visible ${post}`,
  focusWithin: (str, post) => `${str}:focus-within ${post}`,
  active: (str, post) => `${str}:active ${post}, ${str}[data-active] ${post}`,
  disabled: (str, post) => `${str}:disabled ${post}, ${str}[data-disabled] ${post}`,
  invalid: (str, post) => `${str}:invalid ${post}, ${str}[data-invalid] ${post}`,
  checked: (str, post) => `${str}:checked ${post}, ${str}[data-checked] ${post}`,
  indeterminate: (str, post) => `${str}:indeterminate ${post}, ${str}[aria-checked=mixed] ${post}, ${str}[data-indeterminate] ${post}`,
  readOnly: (str, post) => `${str}:read-only ${post}, ${str}[readonly] ${post}, ${str}[data-read-only] ${post}`,
  expanded: (str, post) => `${str}:read-only ${post}, ${str}[aria-expanded=true] ${post}, ${str}[data-expanded] ${post}`,
  placeholderShown: (str, post) => `${str}:placeholder-shown ${post}`
};
var toGroup = (fn2) => merge2((v) => fn2(v, "&"), "[role=group]", "[data-group]", ".group");
var toPeer = (fn2) => merge2((v) => fn2(v, "~ &"), "[data-peer]", ".peer");
var merge2 = (fn2, ...selectors) => selectors.map(fn2).join(", ");
var pseudoSelectors = {
  /**
   * Styles for CSS selector `&:hover`
   */
  _hover: "&:hover, &[data-hover]",
  /**
   * Styles for CSS Selector `&:active`
   */
  _active: "&:active, &[data-active]",
  /**
   * Styles for CSS selector `&:focus`
   *
   */
  _focus: "&:focus, &[data-focus]",
  /**
   * Styles for the highlighted state.
   */
  _highlighted: "&[data-highlighted]",
  /**
   * Styles to apply when a child of this element has received focus
   * - CSS Selector `&:focus-within`
   */
  _focusWithin: "&:focus-within",
  /**
   * Styles to apply when this element has received focus via tabbing
   * - CSS Selector `&:focus-visible`
   */
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  /**
   * Styles to apply when this element is disabled. The passed styles are applied to these CSS selectors:
   * - `&[aria-disabled=true]`
   * - `&:disabled`
   * - `&[data-disabled]`
   * - `&[disabled]`
   */
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  /**
   * Styles for CSS Selector `&:readonly`
   */
  _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
  /**
   * Styles for CSS selector `&::before`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _before={{content:`""` }}/>
   * ```
   */
  _before: "&::before",
  /**
   * Styles for CSS selector `&::after`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _after={{content:`""` }}/>
   * ```
   */
  _after: "&::after",
  /**
   * Styles for CSS selector `&:empty`
   */
  _empty: "&:empty",
  /**
   * Styles to apply when the ARIA attribute `aria-expanded` is `true`
   * - CSS selector `&[aria-expanded=true]`
   */
  _expanded: "&[aria-expanded=true], &[data-expanded]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `true`
   * - CSS selector `&[aria-checked=true]`
   */
  _checked: "&[aria-checked=true], &[data-checked]",
  /**
   * Styles to apply when the ARIA attribute `aria-grabbed` is `true`
   * - CSS selector `&[aria-grabbed=true]`
   */
  _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
  /**
   * Styles for CSS Selector `&[aria-pressed=true]`
   * Typically used to style the current "pressed" state of toggle buttons
   */
  _pressed: "&[aria-pressed=true], &[data-pressed]",
  /**
   * Styles to apply when the ARIA attribute `aria-invalid` is `true`
   * - CSS selector `&[aria-invalid=true]`
   */
  _invalid: "&[aria-invalid=true], &[data-invalid]",
  /**
   * Styles for the valid state
   * - CSS selector `&[data-valid], &[data-state=valid]`
   */
  _valid: "&[data-valid], &[data-state=valid]",
  /**
   * Styles for CSS Selector `&[aria-busy=true]` or `&[data-loading=true]`.
   * Useful for styling loading states
   */
  _loading: "&[data-loading], &[aria-busy=true]",
  /**
   * Styles to apply when the ARIA attribute `aria-selected` is `true`
   *
   * - CSS selector `&[aria-selected=true]`
   */
  _selected: "&[aria-selected=true], &[data-selected]",
  /**
   * Styles for CSS Selector `[hidden=true]`
   */
  _hidden: "&[hidden], &[data-hidden]",
  /**
   * Styles for CSS Selector `&:-webkit-autofill`
   */
  _autofill: "&:-webkit-autofill",
  /**
   * Styles for CSS Selector `&:nth-child(even)`
   */
  _even: "&:nth-of-type(even)",
  /**
   * Styles for CSS Selector `&:nth-child(odd)`
   */
  _odd: "&:nth-of-type(odd)",
  /**
   * Styles for CSS Selector `&:first-of-type`
   */
  _first: "&:first-of-type",
  /**
   * Styles for CSS selector `&::first-letter`
   *
   * NOTE: This selector is only applied for block-level elements and not preceded by an image or table.
   * @example
   * ```jsx
   * <Text _firstLetter={{ textDecoration: 'underline' }}>Once upon a time</Text>
   * ```
   */
  _firstLetter: "&::first-letter",
  /**
   * Styles for CSS Selector `&:last-of-type`
   */
  _last: "&:last-of-type",
  /**
   * Styles for CSS Selector `&:not(:first-of-type)`
   */
  _notFirst: "&:not(:first-of-type)",
  /**
   * Styles for CSS Selector `&:not(:last-of-type)`
   */
  _notLast: "&:not(:last-of-type)",
  /**
   * Styles for CSS Selector `&:visited`
   */
  _visited: "&:visited",
  /**
   * Used to style the active link in a navigation
   * Styles for CSS Selector `&[aria-current=page]`
   */
  _activeLink: "&[aria-current=page]",
  /**
   * Used to style the current step within a process
   * Styles for CSS Selector `&[aria-current=step]`
   */
  _activeStep: "&[aria-current=step]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `mixed`
   * - CSS selector `&[aria-checked=mixed]`
   */
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is hovered
   */
  _groupHover: toGroup(state.hover),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is hovered
   */
  _peerHover: toPeer(state.hover),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is focused
   */
  _groupFocus: toGroup(state.focus),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is focused
   */
  _peerFocus: toPeer(state.focus),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` has visible focus
   */
  _groupFocusVisible: toGroup(state.focusVisible),
  /**
   * Styles to apply when a sibling element with `.peer`or `data-peer` has visible focus
   */
  _peerFocusVisible: toPeer(state.focusVisible),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is active
   */
  _groupActive: toGroup(state.active),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is active
   */
  _peerActive: toPeer(state.active),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is disabled
   */
  _groupDisabled: toGroup(state.disabled),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is disabled
   */
  _peerDisabled: toPeer(state.disabled),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` is invalid
   */
  _groupInvalid: toGroup(state.invalid),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is invalid
   */
  _peerInvalid: toPeer(state.invalid),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is checked
   */
  _groupChecked: toGroup(state.checked),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is checked
   */
  _peerChecked: toPeer(state.checked),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` has focus within
   */
  _groupFocusWithin: toGroup(state.focusWithin),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` has focus within
   */
  _peerFocusWithin: toPeer(state.focusWithin),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` has placeholder shown
   */
  _peerPlaceholderShown: toPeer(state.placeholderShown),
  /**
   * Styles for CSS Selector `&::placeholder`.
   */
  _placeholder: "&::placeholder",
  /**
   * Styles for CSS Selector `&:placeholder-shown`.
   */
  _placeholderShown: "&:placeholder-shown",
  /**
   * Styles for CSS Selector `&:fullscreen`.
   */
  _fullScreen: "&:fullscreen",
  /**
   * Styles for CSS Selector `&::selection`
   */
  _selection: "&::selection",
  /**
   * Styles for CSS Selector `[dir=rtl] &`
   * It is applied when a parent element or this element has `dir="rtl"`
   */
  _rtl: "[dir=rtl] &, &[dir=rtl]",
  /**
   * Styles for CSS Selector `[dir=ltr] &`
   * It is applied when a parent element or this element has `dir="ltr"`
   */
  _ltr: "[dir=ltr] &, &[dir=ltr]",
  /**
   * Styles for CSS Selector `@media (prefers-color-scheme: dark)`
   * It is used when the user has requested the system use a light or dark color theme.
   */
  _mediaDark: "@media (prefers-color-scheme: dark)",
  /**
   * Styles for CSS Selector `@media (prefers-reduced-motion: reduce)`
   * It is used when the user has requested the system to reduce the amount of animations.
   */
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
  /**
   * Styles for the CSS Selector `&[data-orientation=horizontal]`
   */
  _horizontal: "&[data-orientation=horizontal]",
  /**
   * Styles for the CSS Selector `&[data-orientation=vertical]`
   */
  _vertical: "&[data-orientation=vertical]"
};
var pseudoPropNames = Object.keys(
  pseudoSelectors
);
function tokenToCssVar(token2, prefix2) {
  return cssVar(String(token2).replace(/\./g, "-"), void 0, prefix2);
}
function createThemeVars(flatTokens, options) {
  let cssVars2 = {};
  const cssMap = {};
  for (const [token2, tokenValue] of Object.entries(flatTokens)) {
    const { isSemantic, value } = tokenValue;
    const { variable, reference: reference2 } = tokenToCssVar(token2, options == null ? void 0 : options.cssVarPrefix);
    if (!isSemantic) {
      if (token2.startsWith("space")) {
        const keys2 = token2.split(".");
        const [firstKey, ...referenceKeys] = keys2;
        const negativeLookupKey = `${firstKey}.-${referenceKeys.join(".")}`;
        const negativeValue = calc.negate(value);
        const negatedReference = calc.negate(reference2);
        cssMap[negativeLookupKey] = {
          value: negativeValue,
          var: variable,
          varRef: negatedReference
        };
      }
      cssVars2[variable] = value;
      cssMap[token2] = {
        value,
        var: variable,
        varRef: reference2
      };
      continue;
    }
    const lookupToken = (maybeToken) => {
      const scale2 = String(token2).split(".")[0];
      const withScale = [scale2, maybeToken].join(".");
      const resolvedTokenValue = flatTokens[withScale];
      if (!resolvedTokenValue)
        return maybeToken;
      const { reference: reference22 } = tokenToCssVar(withScale, options == null ? void 0 : options.cssVarPrefix);
      return reference22;
    };
    const normalizedValue = isObject(value) ? value : { default: value };
    cssVars2 = (0, import_lodash.default)(
      cssVars2,
      Object.entries(normalizedValue).reduce(
        (acc, [conditionAlias, conditionValue]) => {
          var _a7, _b5;
          if (!conditionValue)
            return acc;
          const tokenReference = lookupToken(`${conditionValue}`);
          if (conditionAlias === "default") {
            acc[variable] = tokenReference;
            return acc;
          }
          const conditionSelector = (_b5 = (_a7 = pseudoSelectors) == null ? void 0 : _a7[conditionAlias]) != null ? _b5 : conditionAlias;
          acc[conditionSelector] = { [variable]: tokenReference };
          return acc;
        },
        {}
      )
    );
    cssMap[token2] = {
      value: reference2,
      var: variable,
      varRef: reference2
    };
  }
  return {
    cssVars: cssVars2,
    cssMap
  };
}
function omit(object, keysToOmit = []) {
  const clone = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone) {
      delete clone[key];
    }
  }
  return clone;
}
function pick(object, keysToPick) {
  const result = {};
  for (const key of keysToPick) {
    if (key in object) {
      result[key] = object[key];
    }
  }
  return result;
}
function isObject5(value) {
  return typeof value === "object" && value != null && !Array.isArray(value);
}
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner2(value, path = []) {
    var _a7;
    if (isObject5(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key = (_a7 = getKey == null ? void 0 : getKey(prop)) != null ? _a7 : prop;
        const childPath = [...path, key];
        if (stop == null ? void 0 : stop(value, childPath)) {
          return predicate(value, path);
        }
        result[key] = inner2(child, childPath);
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner2(target);
}
var tokens = [
  "colors",
  "borders",
  "borderWidths",
  "borderStyles",
  "fonts",
  "fontSizes",
  "fontWeights",
  "gradients",
  "letterSpacings",
  "lineHeights",
  "radii",
  "space",
  "shadows",
  "sizes",
  "zIndices",
  "transition",
  "blur",
  "breakpoints"
];
function extractTokens(theme3) {
  const _tokens = tokens;
  return pick(theme3, _tokens);
}
function extractSemanticTokens(theme3) {
  return theme3.semanticTokens;
}
function omitVars(rawTheme) {
  const { __cssMap, __cssVars, __breakpoints, ...cleanTheme } = rawTheme;
  return cleanTheme;
}
var isSemanticCondition = (key) => pseudoPropNames.includes(key) || "default" === key;
function flattenTokens({
  tokens: tokens2,
  semanticTokens: semanticTokens2
}) {
  const result = {};
  walkObject(tokens2, (value, path) => {
    if (value == null)
      return;
    result[path.join(".")] = { isSemantic: false, value };
  });
  walkObject(
    semanticTokens2,
    (value, path) => {
      if (value == null)
        return;
      result[path.join(".")] = { isSemantic: true, value };
    },
    {
      stop: (value) => Object.keys(value).every(isSemanticCondition)
    }
  );
  return result;
}
function toCSSVar(rawTheme) {
  var _a7;
  const theme3 = omitVars(rawTheme);
  const tokens2 = extractTokens(theme3);
  const semanticTokens2 = extractSemanticTokens(theme3);
  const flatTokens = flattenTokens({ tokens: tokens2, semanticTokens: semanticTokens2 });
  const cssVarPrefix = (_a7 = theme3.config) == null ? void 0 : _a7.cssVarPrefix;
  const {
    /**
     * This is more like a dictionary of tokens users will type `green.500`,
     * and their equivalent css variable.
     */
    cssMap,
    /**
     * The extracted css variables will be stored here, and used in
     * the emotion's <Global/> component to attach variables to `:root`
     */
    cssVars: cssVars2
  } = createThemeVars(flatTokens, { cssVarPrefix });
  const defaultCssVars = {
    "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-ring-offset-width": "0px",
    "--chakra-ring-offset-color": "#fff",
    "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
    "--chakra-ring-offset-shadow": "0 0 #0000",
    "--chakra-ring-shadow": "0 0 #0000",
    "--chakra-space-x-reverse": "0",
    "--chakra-space-y-reverse": "0"
  };
  Object.assign(theme3, {
    __cssVars: { ...defaultCssVars, ...cssVars2 },
    __cssMap: cssMap,
    __breakpoints: analyzeBreakpoints(theme3.breakpoints)
  });
  return theme3;
}
var systemProps = (0, import_lodash3.default)(
  {},
  background,
  border,
  color,
  flexbox,
  layout,
  filter,
  ring,
  interactivity,
  grid,
  others,
  position2,
  effect,
  space,
  scroll,
  typography,
  textDecoration,
  transform,
  list,
  transition
);
var layoutSystem = Object.assign({}, space, layout, flexbox, grid, position2);
var layoutPropNames = Object.keys(
  layoutSystem
);
var propNames = [...Object.keys(systemProps), ...pseudoPropNames];
var styleProps = { ...systemProps, ...pseudoSelectors };
var isStyleProp = (prop) => prop in styleProps;
var expandResponsive = (styles3) => (theme3) => {
  if (!theme3.__breakpoints)
    return styles3;
  const { isResponsive, toArrayValue, media: medias } = theme3.__breakpoints;
  const computedStyles = {};
  for (const key in styles3) {
    let value = runIfFn(styles3[key], theme3);
    if (value == null)
      continue;
    value = isObject(value) && isResponsive(value) ? toArrayValue(value) : value;
    if (!Array.isArray(value)) {
      computedStyles[key] = value;
      continue;
    }
    const queries = value.slice(0, medias.length).length;
    for (let index3 = 0; index3 < queries; index3 += 1) {
      const media = medias == null ? void 0 : medias[index3];
      if (!media) {
        computedStyles[key] = value[index3];
        continue;
      }
      computedStyles[media] = computedStyles[media] || {};
      if (value[index3] == null) {
        continue;
      }
      computedStyles[media][key] = value[index3];
    }
  }
  return computedStyles;
};
function splitByComma(value) {
  const chunks = [];
  let chunk = "";
  let inParens = false;
  for (let i = 0; i < value.length; i++) {
    const char2 = value[i];
    if (char2 === "(") {
      inParens = true;
      chunk += char2;
    } else if (char2 === ")") {
      inParens = false;
      chunk += char2;
    } else if (char2 === "," && !inParens) {
      chunks.push(chunk);
      chunk = "";
    } else {
      chunk += char2;
    }
  }
  chunk = chunk.trim();
  if (chunk) {
    chunks.push(chunk);
  }
  return chunks;
}
function isCssVar2(value) {
  return /^var\(--.+\)$/.test(value);
}
var isCSSVariableTokenValue = (key, value) => key.startsWith("--") && typeof value === "string" && !isCssVar2(value);
var resolveTokenValue = (theme3, value) => {
  var _a7, _b5;
  if (value == null)
    return value;
  const getVar = (val) => {
    var _a24, _b22;
    return (_b22 = (_a24 = theme3.__cssMap) == null ? void 0 : _a24[val]) == null ? void 0 : _b22.varRef;
  };
  const getValue = (val) => {
    var _a24;
    return (_a24 = getVar(val)) != null ? _a24 : val;
  };
  const [tokenValue, fallbackValue] = splitByComma(value);
  value = (_b5 = (_a7 = getVar(tokenValue)) != null ? _a7 : getValue(fallbackValue)) != null ? _b5 : getValue(value);
  return value;
};
function getCss(options) {
  const { configs = {}, pseudos = {}, theme: theme3 } = options;
  const css22 = (stylesOrFn, nested = false) => {
    var _a7, _b5, _c14;
    const _styles = runIfFn(stylesOrFn, theme3);
    const styles3 = expandResponsive(_styles)(theme3);
    let computedStyles = {};
    for (let key in styles3) {
      const valueOrFn = styles3[key];
      let value = runIfFn(valueOrFn, theme3);
      if (key in pseudos) {
        key = pseudos[key];
      }
      if (isCSSVariableTokenValue(key, value)) {
        value = resolveTokenValue(theme3, value);
      }
      let config2 = configs[key];
      if (config2 === true) {
        config2 = { property: key };
      }
      if (isObject(value)) {
        computedStyles[key] = (_a7 = computedStyles[key]) != null ? _a7 : {};
        computedStyles[key] = (0, import_lodash2.default)(
          {},
          computedStyles[key],
          css22(value, true)
        );
        continue;
      }
      let rawValue = (_c14 = (_b5 = config2 == null ? void 0 : config2.transform) == null ? void 0 : _b5.call(config2, value, theme3, _styles)) != null ? _c14 : value;
      rawValue = (config2 == null ? void 0 : config2.processResult) ? css22(rawValue, true) : rawValue;
      const configProperty = runIfFn(config2 == null ? void 0 : config2.property, theme3);
      if (!nested && (config2 == null ? void 0 : config2.static)) {
        const staticStyles = runIfFn(config2.static, theme3);
        computedStyles = (0, import_lodash2.default)({}, computedStyles, staticStyles);
      }
      if (configProperty && Array.isArray(configProperty)) {
        for (const property of configProperty) {
          computedStyles[property] = rawValue;
        }
        continue;
      }
      if (configProperty) {
        if (configProperty === "&" && isObject(rawValue)) {
          computedStyles = (0, import_lodash2.default)({}, computedStyles, rawValue);
        } else {
          computedStyles[configProperty] = rawValue;
        }
        continue;
      }
      if (isObject(rawValue)) {
        computedStyles = (0, import_lodash2.default)({}, computedStyles, rawValue);
        continue;
      }
      computedStyles[key] = rawValue;
    }
    return computedStyles;
  };
  return css22;
}
var css3 = (styles3) => (theme3) => {
  const cssFn = getCss({
    theme: theme3,
    pseudos: pseudoSelectors,
    configs: systemProps
  });
  return cssFn(styles3);
};
function defineStyle(styles3) {
  return styles3;
}
function defineStyleConfig(config2) {
  return config2;
}
function createMultiStyleConfigHelpers(parts) {
  return {
    definePartsStyle(config2) {
      return config2;
    },
    defineMultiStyleConfig(config2) {
      return { parts, ...config2 };
    }
  };
}
function normalize2(value, toArray) {
  if (Array.isArray(value))
    return value;
  if (isObject(value))
    return toArray(value);
  if (value != null)
    return [value];
}
function getNextIndex(values, i) {
  for (let j = i + 1; j < values.length; j++) {
    if (values[j] != null)
      return j;
  }
  return -1;
}
function createResolver(theme3) {
  const breakpointUtil = theme3.__breakpoints;
  return function resolver(config2, prop, value, props) {
    var _a7, _b5;
    if (!breakpointUtil)
      return;
    const result = {};
    const normalized = normalize2(value, breakpointUtil.toArrayValue);
    if (!normalized)
      return result;
    const len = normalized.length;
    const isSingle = len === 1;
    const isMultipart = !!config2.parts;
    for (let i = 0; i < len; i++) {
      const key = breakpointUtil.details[i];
      const nextKey = breakpointUtil.details[getNextIndex(normalized, i)];
      const query = toMediaQueryString(key.minW, nextKey == null ? void 0 : nextKey._minW);
      const styles3 = runIfFn((_a7 = config2[prop]) == null ? void 0 : _a7[normalized[i]], props);
      if (!styles3)
        continue;
      if (isMultipart) {
        (_b5 = config2.parts) == null ? void 0 : _b5.forEach((part) => {
          (0, import_lodash4.default)(result, {
            [part]: isSingle ? styles3[part] : { [query]: styles3[part] }
          });
        });
        continue;
      }
      if (!isMultipart) {
        if (isSingle)
          (0, import_lodash4.default)(result, styles3);
        else
          result[query] = styles3;
        continue;
      }
      result[query] = styles3;
    }
    return result;
  };
}
function resolveStyleConfig(config2) {
  return (props) => {
    var _a7;
    const { variant, size: size3, theme: theme3 } = props;
    const recipe = createResolver(theme3);
    return (0, import_lodash4.default)(
      {},
      runIfFn((_a7 = config2.baseStyle) != null ? _a7 : {}, props),
      recipe(config2, "sizes", size3, props),
      recipe(config2, "variants", variant, props)
    );
  };
}
function omitThemingProps(props) {
  return omit(props, ["styleConfig", "size", "variant", "colorScheme"]);
}

// node_modules/@chakra-ui/theme/dist/chunk-P56GPN75.mjs
var requiredChakraThemeKeys = [
  "borders",
  "breakpoints",
  "colors",
  "components",
  "config",
  "direction",
  "fonts",
  "fontSizes",
  "fontWeights",
  "letterSpacings",
  "lineHeights",
  "radii",
  "shadows",
  "sizes",
  "space",
  "styles",
  "transition",
  "zIndices"
];
function isChakraTheme(unit) {
  if (!isObject(unit)) {
    return false;
  }
  return requiredChakraThemeKeys.every(
    (propertyName) => Object.prototype.hasOwnProperty.call(unit, propertyName)
  );
}

// node_modules/@chakra-ui/theme/dist/chunk-SIH73G3H.mjs
var transitionProperty = {
  common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
  colors: "background-color, border-color, color, fill, stroke",
  dimensions: "width, height",
  position: "left, right, top, bottom",
  background: "background-color, background-image, background-position"
};
var transitionTimingFunction = {
  "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
  "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
};
var transitionDuration = {
  "ultra-fast": "50ms",
  faster: "100ms",
  fast: "150ms",
  normal: "200ms",
  slow: "300ms",
  slower: "400ms",
  "ultra-slow": "500ms"
};
var transition2 = {
  property: transitionProperty,
  easing: transitionTimingFunction,
  duration: transitionDuration
};
var transition_default = transition2;

// node_modules/@chakra-ui/theme/dist/chunk-45VJLTIL.mjs
var zIndices = {
  hide: -1,
  auto: "auto",
  base: 0,
  docked: 10,
  dropdown: 1e3,
  sticky: 1100,
  banner: 1200,
  overlay: 1300,
  modal: 1400,
  popover: 1500,
  skipLink: 1600,
  toast: 1700,
  tooltip: 1800
};
var z_index_default = zIndices;

// node_modules/@chakra-ui/theme/dist/chunk-B75T2J64.mjs
var borders = {
  none: 0,
  "1px": "1px solid",
  "2px": "2px solid",
  "4px": "4px solid",
  "8px": "8px solid"
};
var borders_default = borders;

// node_modules/@chakra-ui/theme/dist/chunk-TXLFBUTF.mjs
var breakpoints = {
  base: "0em",
  sm: "30em",
  md: "48em",
  lg: "62em",
  xl: "80em",
  "2xl": "96em"
};
var breakpoints_default = breakpoints;

// node_modules/@chakra-ui/theme/dist/chunk-E47HH2QS.mjs
var colors = {
  transparent: "transparent",
  current: "currentColor",
  black: "#000000",
  white: "#FFFFFF",
  whiteAlpha: {
    50: "rgba(255, 255, 255, 0.04)",
    100: "rgba(255, 255, 255, 0.06)",
    200: "rgba(255, 255, 255, 0.08)",
    300: "rgba(255, 255, 255, 0.16)",
    400: "rgba(255, 255, 255, 0.24)",
    500: "rgba(255, 255, 255, 0.36)",
    600: "rgba(255, 255, 255, 0.48)",
    700: "rgba(255, 255, 255, 0.64)",
    800: "rgba(255, 255, 255, 0.80)",
    900: "rgba(255, 255, 255, 0.92)"
  },
  blackAlpha: {
    50: "rgba(0, 0, 0, 0.04)",
    100: "rgba(0, 0, 0, 0.06)",
    200: "rgba(0, 0, 0, 0.08)",
    300: "rgba(0, 0, 0, 0.16)",
    400: "rgba(0, 0, 0, 0.24)",
    500: "rgba(0, 0, 0, 0.36)",
    600: "rgba(0, 0, 0, 0.48)",
    700: "rgba(0, 0, 0, 0.64)",
    800: "rgba(0, 0, 0, 0.80)",
    900: "rgba(0, 0, 0, 0.92)"
  },
  gray: {
    50: "#F7FAFC",
    100: "#EDF2F7",
    200: "#E2E8F0",
    300: "#CBD5E0",
    400: "#A0AEC0",
    500: "#718096",
    600: "#4A5568",
    700: "#2D3748",
    800: "#1A202C",
    900: "#171923"
  },
  red: {
    50: "#FFF5F5",
    100: "#FED7D7",
    200: "#FEB2B2",
    300: "#FC8181",
    400: "#F56565",
    500: "#E53E3E",
    600: "#C53030",
    700: "#9B2C2C",
    800: "#822727",
    900: "#63171B"
  },
  orange: {
    50: "#FFFAF0",
    100: "#FEEBC8",
    200: "#FBD38D",
    300: "#F6AD55",
    400: "#ED8936",
    500: "#DD6B20",
    600: "#C05621",
    700: "#9C4221",
    800: "#7B341E",
    900: "#652B19"
  },
  yellow: {
    50: "#FFFFF0",
    100: "#FEFCBF",
    200: "#FAF089",
    300: "#F6E05E",
    400: "#ECC94B",
    500: "#D69E2E",
    600: "#B7791F",
    700: "#975A16",
    800: "#744210",
    900: "#5F370E"
  },
  green: {
    50: "#F0FFF4",
    100: "#C6F6D5",
    200: "#9AE6B4",
    300: "#68D391",
    400: "#48BB78",
    500: "#38A169",
    600: "#2F855A",
    700: "#276749",
    800: "#22543D",
    900: "#1C4532"
  },
  teal: {
    50: "#E6FFFA",
    100: "#B2F5EA",
    200: "#81E6D9",
    300: "#4FD1C5",
    400: "#38B2AC",
    500: "#319795",
    600: "#2C7A7B",
    700: "#285E61",
    800: "#234E52",
    900: "#1D4044"
  },
  blue: {
    50: "#ebf8ff",
    100: "#bee3f8",
    200: "#90cdf4",
    300: "#63b3ed",
    400: "#4299e1",
    500: "#3182ce",
    600: "#2b6cb0",
    700: "#2c5282",
    800: "#2a4365",
    900: "#1A365D"
  },
  cyan: {
    50: "#EDFDFD",
    100: "#C4F1F9",
    200: "#9DECF9",
    300: "#76E4F7",
    400: "#0BC5EA",
    500: "#00B5D8",
    600: "#00A3C4",
    700: "#0987A0",
    800: "#086F83",
    900: "#065666"
  },
  purple: {
    50: "#FAF5FF",
    100: "#E9D8FD",
    200: "#D6BCFA",
    300: "#B794F4",
    400: "#9F7AEA",
    500: "#805AD5",
    600: "#6B46C1",
    700: "#553C9A",
    800: "#44337A",
    900: "#322659"
  },
  pink: {
    50: "#FFF5F7",
    100: "#FED7E2",
    200: "#FBB6CE",
    300: "#F687B3",
    400: "#ED64A6",
    500: "#D53F8C",
    600: "#B83280",
    700: "#97266D",
    800: "#702459",
    900: "#521B41"
  },
  linkedin: {
    50: "#E8F4F9",
    100: "#CFEDFB",
    200: "#9BDAF3",
    300: "#68C7EC",
    400: "#34B3E4",
    500: "#00A0DC",
    600: "#008CC9",
    700: "#0077B5",
    800: "#005E93",
    900: "#004471"
  },
  facebook: {
    50: "#E8F4F9",
    100: "#D9DEE9",
    200: "#B7C2DA",
    300: "#6482C0",
    400: "#4267B2",
    500: "#385898",
    600: "#314E89",
    700: "#29487D",
    800: "#223B67",
    900: "#1E355B"
  },
  messenger: {
    50: "#D0E6FF",
    100: "#B9DAFF",
    200: "#A2CDFF",
    300: "#7AB8FF",
    400: "#2E90FF",
    500: "#0078FF",
    600: "#0063D1",
    700: "#0052AC",
    800: "#003C7E",
    900: "#002C5C"
  },
  whatsapp: {
    50: "#dffeec",
    100: "#b9f5d0",
    200: "#90edb3",
    300: "#65e495",
    400: "#3cdd78",
    500: "#22c35e",
    600: "#179848",
    700: "#0c6c33",
    800: "#01421c",
    900: "#001803"
  },
  twitter: {
    50: "#E5F4FD",
    100: "#C8E9FB",
    200: "#A8DCFA",
    300: "#83CDF7",
    400: "#57BBF5",
    500: "#1DA1F2",
    600: "#1A94DA",
    700: "#1681BF",
    800: "#136B9E",
    900: "#0D4D71"
  },
  telegram: {
    50: "#E3F2F9",
    100: "#C5E4F3",
    200: "#A2D4EC",
    300: "#7AC1E4",
    400: "#47A9DA",
    500: "#0088CC",
    600: "#007AB8",
    700: "#006BA1",
    800: "#005885",
    900: "#003F5E"
  }
};
var colors_default = colors;

// node_modules/@chakra-ui/theme/dist/chunk-VIVTPWHP.mjs
var radii = {
  none: "0",
  sm: "0.125rem",
  base: "0.25rem",
  md: "0.375rem",
  lg: "0.5rem",
  xl: "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  full: "9999px"
};
var radius_default = radii;

// node_modules/@chakra-ui/theme/dist/chunk-IZUFFCXS.mjs
var shadows = {
  xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
  sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
  base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
  md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
  lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
  xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
  "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
  outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
  inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
  none: "none",
  "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
};
var shadows_default = shadows;

// node_modules/@chakra-ui/theme/dist/chunk-HQ6WXDYV.mjs
var blur = {
  none: 0,
  sm: "4px",
  base: "8px",
  md: "12px",
  lg: "16px",
  xl: "24px",
  "2xl": "40px",
  "3xl": "64px"
};
var blur_default = blur;

// node_modules/@chakra-ui/theme/dist/chunk-6XA2KDUD.mjs
var typography2 = {
  letterSpacings: {
    tighter: "-0.05em",
    tight: "-0.025em",
    normal: "0",
    wide: "0.025em",
    wider: "0.05em",
    widest: "0.1em"
  },
  lineHeights: {
    normal: "normal",
    none: 1,
    shorter: 1.25,
    short: 1.375,
    base: 1.5,
    tall: 1.625,
    taller: "2",
    "3": ".75rem",
    "4": "1rem",
    "5": "1.25rem",
    "6": "1.5rem",
    "7": "1.75rem",
    "8": "2rem",
    "9": "2.25rem",
    "10": "2.5rem"
  },
  fontWeights: {
    hairline: 100,
    thin: 200,
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    black: 900
  },
  fonts: {
    heading: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    body: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    mono: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  },
  fontSizes: {
    "3xs": "0.45rem",
    "2xs": "0.625rem",
    xs: "0.75rem",
    sm: "0.875rem",
    md: "1rem",
    lg: "1.125rem",
    xl: "1.25rem",
    "2xl": "1.5rem",
    "3xl": "1.875rem",
    "4xl": "2.25rem",
    "5xl": "3rem",
    "6xl": "3.75rem",
    "7xl": "4.5rem",
    "8xl": "6rem",
    "9xl": "8rem"
  }
};
var typography_default = typography2;

// node_modules/@chakra-ui/theme/dist/chunk-V7WMN6TQ.mjs
var spacing = {
  px: "1px",
  0.5: "0.125rem",
  1: "0.25rem",
  1.5: "0.375rem",
  2: "0.5rem",
  2.5: "0.625rem",
  3: "0.75rem",
  3.5: "0.875rem",
  4: "1rem",
  5: "1.25rem",
  6: "1.5rem",
  7: "1.75rem",
  8: "2rem",
  9: "2.25rem",
  10: "2.5rem",
  12: "3rem",
  14: "3.5rem",
  16: "4rem",
  20: "5rem",
  24: "6rem",
  28: "7rem",
  32: "8rem",
  36: "9rem",
  40: "10rem",
  44: "11rem",
  48: "12rem",
  52: "13rem",
  56: "14rem",
  60: "15rem",
  64: "16rem",
  72: "18rem",
  80: "20rem",
  96: "24rem"
};

// node_modules/@chakra-ui/theme/dist/chunk-NJCYBKFH.mjs
var largeSizes = {
  max: "max-content",
  min: "min-content",
  full: "100%",
  "3xs": "14rem",
  "2xs": "16rem",
  xs: "20rem",
  sm: "24rem",
  md: "28rem",
  lg: "32rem",
  xl: "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "8xl": "90rem",
  prose: "60ch"
};
var container = {
  sm: "640px",
  md: "768px",
  lg: "1024px",
  xl: "1280px"
};
var sizes = {
  ...spacing,
  ...largeSizes,
  container
};
var sizes_default = sizes;

// node_modules/@chakra-ui/theme/dist/chunk-3WO5B3NB.mjs
var foundations = {
  breakpoints: breakpoints_default,
  zIndices: z_index_default,
  radii: radius_default,
  blur: blur_default,
  colors: colors_default,
  ...typography_default,
  sizes: sizes_default,
  shadows: shadows_default,
  space: spacing,
  borders: borders_default,
  transition: transition_default
};

// node_modules/@chakra-ui/theme/dist/chunk-Q5NOVGYN.mjs
var { defineMultiStyleConfig, definePartsStyle } = createMultiStyleConfigHelpers([
  "stepper",
  "step",
  "title",
  "description",
  "indicator",
  "separator",
  "icon",
  "number"
]);
var $size = cssVar("stepper-indicator-size");
var $iconSize = cssVar("stepper-icon-size");
var $titleFontSize = cssVar("stepper-title-font-size");
var $descFontSize = cssVar("stepper-description-font-size");
var $accentColor = cssVar("stepper-accent-color");
var baseStyle = definePartsStyle(({ colorScheme: c2 }) => ({
  stepper: {
    display: "flex",
    justifyContent: "space-between",
    gap: "4",
    "&[data-orientation=vertical]": {
      flexDirection: "column",
      alignItems: "flex-start"
    },
    "&[data-orientation=horizontal]": {
      flexDirection: "row",
      alignItems: "center"
    },
    [$accentColor.variable]: `colors.${c2}.500`,
    _dark: {
      [$accentColor.variable]: `colors.${c2}.200`
    }
  },
  title: {
    fontSize: $titleFontSize.reference,
    fontWeight: "medium"
  },
  description: {
    fontSize: $descFontSize.reference,
    color: "chakra-subtle-text"
  },
  number: {
    fontSize: $titleFontSize.reference
  },
  step: {
    flexShrink: 0,
    position: "relative",
    display: "flex",
    gap: "2",
    "&[data-orientation=horizontal]": {
      alignItems: "center"
    },
    flex: "1",
    "&:last-of-type:not([data-stretch])": {
      flex: "initial"
    }
  },
  icon: {
    flexShrink: 0,
    width: $iconSize.reference,
    height: $iconSize.reference
  },
  indicator: {
    flexShrink: 0,
    borderRadius: "full",
    width: $size.reference,
    height: $size.reference,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    "&[data-status=active]": {
      borderWidth: "2px",
      borderColor: $accentColor.reference
    },
    "&[data-status=complete]": {
      bg: $accentColor.reference,
      color: "chakra-inverse-text"
    },
    "&[data-status=incomplete]": {
      borderWidth: "2px"
    }
  },
  separator: {
    bg: "chakra-border-color",
    flex: "1",
    "&[data-status=complete]": {
      bg: $accentColor.reference
    },
    "&[data-orientation=horizontal]": {
      width: "100%",
      height: "2px",
      marginStart: "2"
    },
    "&[data-orientation=vertical]": {
      width: "2px",
      position: "absolute",
      height: "100%",
      maxHeight: `calc(100% - ${$size.reference} - 8px)`,
      top: `calc(${$size.reference} + 4px)`,
      insetStart: `calc(${$size.reference} / 2 - 1px)`
    }
  }
}));
var stepperTheme = defineMultiStyleConfig({
  baseStyle,
  sizes: {
    xs: definePartsStyle({
      stepper: {
        [$size.variable]: "sizes.4",
        [$iconSize.variable]: "sizes.3",
        [$titleFontSize.variable]: "fontSizes.xs",
        [$descFontSize.variable]: "fontSizes.xs"
      }
    }),
    sm: definePartsStyle({
      stepper: {
        [$size.variable]: "sizes.6",
        [$iconSize.variable]: "sizes.4",
        [$titleFontSize.variable]: "fontSizes.sm",
        [$descFontSize.variable]: "fontSizes.xs"
      }
    }),
    md: definePartsStyle({
      stepper: {
        [$size.variable]: "sizes.8",
        [$iconSize.variable]: "sizes.5",
        [$titleFontSize.variable]: "fontSizes.md",
        [$descFontSize.variable]: "fontSizes.sm"
      }
    }),
    lg: definePartsStyle({
      stepper: {
        [$size.variable]: "sizes.10",
        [$iconSize.variable]: "sizes.6",
        [$titleFontSize.variable]: "fontSizes.lg",
        [$descFontSize.variable]: "fontSizes.md"
      }
    })
  },
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});

// node_modules/@chakra-ui/anatomy/dist/chunk-OA3DH5LS.mjs
function anatomy(name, map = {}) {
  let called = false;
  function assert() {
    if (!called) {
      called = true;
      return;
    }
    throw new Error(
      "[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?"
    );
  }
  function parts(...values) {
    assert();
    for (const part of values) {
      ;
      map[part] = toPart(part);
    }
    return anatomy(name, map);
  }
  function extend(...parts2) {
    for (const part of parts2) {
      if (part in map)
        continue;
      map[part] = toPart(part);
    }
    return anatomy(name, map);
  }
  function selectors() {
    const value = Object.fromEntries(
      Object.entries(map).map(([key, part]) => [key, part.selector])
    );
    return value;
  }
  function classnames3() {
    const value = Object.fromEntries(
      Object.entries(map).map(([key, part]) => [key, part.className])
    );
    return value;
  }
  function toPart(part) {
    const el = ["container", "root"].includes(part != null ? part : "") ? [name] : [name, part];
    const attr2 = el.filter(Boolean).join("__");
    const className = `chakra-${attr2}`;
    const partObj = {
      className,
      selector: `.${className}`,
      toString: () => part
    };
    return partObj;
  }
  const __type = {};
  return {
    parts,
    toPart,
    extend,
    selectors,
    classnames: classnames3,
    get keys() {
      return Object.keys(map);
    },
    __type
  };
}

// node_modules/@chakra-ui/anatomy/dist/chunk-7OOI6RFH.mjs
var accordionAnatomy = anatomy("accordion").parts("root", "container", "button", "panel").extend("icon");
var alertAnatomy = anatomy("alert").parts("title", "description", "container").extend("icon", "spinner");
var avatarAnatomy = anatomy("avatar").parts("label", "badge", "container").extend("excessLabel", "group");
var breadcrumbAnatomy = anatomy("breadcrumb").parts("link", "item", "container").extend("separator");
var buttonAnatomy = anatomy("button").parts();
var checkboxAnatomy = anatomy("checkbox").parts("control", "icon", "container").extend("label");
var circularProgressAnatomy = anatomy("progress").parts("track", "filledTrack").extend("label");
var drawerAnatomy = anatomy("drawer").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
var editableAnatomy = anatomy("editable").parts(
  "preview",
  "input",
  "textarea"
);
var formAnatomy = anatomy("form").parts(
  "container",
  "requiredIndicator",
  "helperText"
);
var formErrorAnatomy = anatomy("formError").parts("text", "icon");
var inputAnatomy = anatomy("input").parts(
  "addon",
  "field",
  "element",
  "group"
);
var listAnatomy = anatomy("list").parts("container", "item", "icon");
var menuAnatomy = anatomy("menu").parts("button", "list", "item").extend("groupTitle", "icon", "command", "divider");
var modalAnatomy = anatomy("modal").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
var numberInputAnatomy = anatomy("numberinput").parts(
  "root",
  "field",
  "stepperGroup",
  "stepper"
);
var pinInputAnatomy = anatomy("pininput").parts("field");
var popoverAnatomy = anatomy("popover").parts("content", "header", "body", "footer").extend("popper", "arrow", "closeButton");
var progressAnatomy = anatomy("progress").parts(
  "label",
  "filledTrack",
  "track"
);
var radioAnatomy = anatomy("radio").parts(
  "container",
  "control",
  "label"
);
var selectAnatomy = anatomy("select").parts("field", "icon");
var sliderAnatomy = anatomy("slider").parts(
  "container",
  "track",
  "thumb",
  "filledTrack",
  "mark"
);
var statAnatomy = anatomy("stat").parts(
  "container",
  "label",
  "helpText",
  "number",
  "icon"
);
var switchAnatomy = anatomy("switch").parts(
  "container",
  "track",
  "thumb",
  "label"
);
var tableAnatomy = anatomy("table").parts(
  "table",
  "thead",
  "tbody",
  "tr",
  "th",
  "td",
  "tfoot",
  "caption"
);
var tabsAnatomy = anatomy("tabs").parts(
  "root",
  "tab",
  "tablist",
  "tabpanel",
  "tabpanels",
  "indicator"
);
var tagAnatomy = anatomy("tag").parts(
  "container",
  "label",
  "closeButton"
);
var cardAnatomy = anatomy("card").parts(
  "container",
  "header",
  "body",
  "footer"
);
var stepperAnatomy = anatomy("stepper").parts(
  "stepper",
  "step",
  "title",
  "description",
  "indicator",
  "separator",
  "icon",
  "number"
);

// node_modules/color2k/dist/index.exports.import.es.mjs
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
var ColorError = class extends Error {
  constructor(color3) {
    super(`Failed to parse color: "${color3}"`);
  }
};
var ColorError$1 = ColorError;
function parseToRgba(color3) {
  if (typeof color3 !== "string")
    throw new ColorError$1(color3);
  if (color3.trim().toLowerCase() === "transparent")
    return [0, 0, 0, 0];
  let normalizedColor = color3.trim();
  normalizedColor = namedColorRegex.test(color3) ? nameToHex(color3) : color3;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex.exec(normalizedColor);
  if (hslaMatch) {
    const [h, s, l, a2] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s) !== s)
      throw new ColorError$1(color3);
    if (guard(0, 100, l) !== l)
      throw new ColorError$1(color3);
    return [...hslToRgb(h, s, l), Number.isNaN(a2) ? 1 : a2];
  }
  throw new ColorError$1(color3);
}
function hash2(str) {
  let hash5 = 5381;
  let i = str.length;
  while (i) {
    hash5 = hash5 * 33 ^ str.charCodeAt(--i);
  }
  return (hash5 >>> 0) % 2341;
}
var colorToInt = (x) => parseInt(x.replace(/_/g, ""), 36);
var compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next2) => {
  const key = colorToInt(next2.substring(0, 3));
  const hex2 = colorToInt(next2.substring(3)).toString(16);
  let prefix2 = "";
  for (let i = 0; i < 6 - hex2.length; i++) {
    prefix2 += "0";
  }
  acc[key] = `${prefix2}${hex2}`;
  return acc;
}, {});
function nameToHex(color3) {
  const normalizedColorName = color3.toLowerCase().trim();
  const result = compressedColorMap[hash2(normalizedColorName)];
  if (!result)
    throw new ColorError$1(color3);
  return `#${result}`;
}
var r = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
var reducedHexRegex = new RegExp(`^#${r("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
var hexRegex = new RegExp(`^#${r("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
var rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
var hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
var namedColorRegex = /^[a-z]+$/i;
var roundColor = (color3) => {
  return Math.round(color3 * 255);
};
var hslToRgb = (hue, saturation, lightness) => {
  let l = lightness / 100;
  if (saturation === 0) {
    return [l, l, l].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function rgba(red, green, blue, alpha2) {
  return `rgba(${guard(0, 255, red).toFixed()}, ${guard(0, 255, green).toFixed()}, ${guard(0, 255, blue).toFixed()}, ${parseFloat(guard(0, 1, alpha2).toFixed(3))})`;
}
function transparentize(color3, amount) {
  const [r2, g, b2, a2] = parseToRgba(color3);
  return rgba(r2, g, b2, a2 - amount);
}
function toHex(color3) {
  const [r2, g, b2, a2] = parseToRgba(color3);
  let hex2 = (x) => {
    const h = guard(0, 255, x).toString(16);
    return h.length === 1 ? `0${h}` : h;
  };
  return `#${hex2(r2)}${hex2(g)}${hex2(b2)}${a2 < 1 ? hex2(Math.round(a2 * 255)) : ""}`;
}

// node_modules/@chakra-ui/theme-tools/dist/chunk-6IC2I3BY.mjs
function dlv_es_default(t2, e, l, n, r2) {
  for (e = e.split ? e.split(".") : e, n = 0; n < e.length; n++)
    t2 = t2 ? t2[e[n]] : r2;
  return t2 === r2 ? l : t2;
}
var isEmptyObject = (obj) => Object.keys(obj).length === 0;
var getColor = (theme3, color3, fallback) => {
  const hex2 = dlv_es_default(theme3, `colors.${color3}`, color3);
  try {
    toHex(hex2);
    return hex2;
  } catch {
    return fallback != null ? fallback : "#000000";
  }
};
var getBrightness = (color3) => {
  const [r2, g, b2] = parseToRgba(color3);
  return (r2 * 299 + g * 587 + b2 * 114) / 1e3;
};
var tone = (color3) => (theme3) => {
  const hex2 = getColor(theme3, color3);
  const brightness = getBrightness(hex2);
  const isDark2 = brightness < 128;
  return isDark2 ? "dark" : "light";
};
var isDark = (color3) => (theme3) => tone(color3)(theme3) === "dark";
var transparentize2 = (color3, opacity) => (theme3) => {
  const raw = getColor(theme3, color3);
  return transparentize(raw, 1 - opacity);
};
function generateStripe(size3 = "1rem", color3 = "rgba(255, 255, 255, 0.15)") {
  return {
    backgroundImage: `linear-gradient(
    45deg,
    ${color3} 25%,
    transparent 25%,
    transparent 50%,
    ${color3} 50%,
    ${color3} 75%,
    transparent 75%,
    transparent
  )`,
    backgroundSize: `${size3} ${size3}`
  };
}
var randomHex = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
function randomColor(opts) {
  const fallback = randomHex();
  if (!opts || isEmptyObject(opts)) {
    return fallback;
  }
  if (opts.string && opts.colors) {
    return randomColorFromList(opts.string, opts.colors);
  }
  if (opts.string && !opts.colors) {
    return randomColorFromString(opts.string);
  }
  if (opts.colors && !opts.string) {
    return randomFromList(opts.colors);
  }
  return fallback;
}
function randomColorFromString(str) {
  let hash5 = 0;
  if (str.length === 0)
    return hash5.toString();
  for (let i = 0; i < str.length; i += 1) {
    hash5 = str.charCodeAt(i) + ((hash5 << 5) - hash5);
    hash5 = hash5 & hash5;
  }
  let color3 = "#";
  for (let j = 0; j < 3; j += 1) {
    const value = hash5 >> j * 8 & 255;
    color3 += `00${value.toString(16)}`.substr(-2);
  }
  return color3;
}
function randomColorFromList(str, list2) {
  let index3 = 0;
  if (str.length === 0)
    return list2[0];
  for (let i = 0; i < str.length; i += 1) {
    index3 = str.charCodeAt(i) + ((index3 << 5) - index3);
    index3 = index3 & index3;
  }
  index3 = (index3 % list2.length + list2.length) % list2.length;
  return list2[index3];
}
function randomFromList(list2) {
  return list2[Math.floor(Math.random() * list2.length)];
}

// node_modules/@chakra-ui/theme-tools/dist/chunk-FNB7ZWWX.mjs
function mode(light, dark) {
  return (props) => props.colorMode === "dark" ? dark : light;
}
function orient(options) {
  const { orientation, vertical, horizontal } = options;
  if (!orientation)
    return {};
  return orientation === "vertical" ? vertical : horizontal;
}

// node_modules/@chakra-ui/theme-tools/dist/chunk-XMZHFSTS.mjs
function toRef(operand) {
  if (isObject(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpr = (operator, ...operands) => operands.map(toRef).join(` ${operator} `).replace(/calc/g, "");
var add2 = (...operands) => `calc(${toExpr("+", ...operands)})`;
var subtract3 = (...operands) => `calc(${toExpr("-", ...operands)})`;
var multiply2 = (...operands) => `calc(${toExpr("*", ...operands)})`;
var divide2 = (...operands) => `calc(${toExpr("/", ...operands)})`;
var negate2 = (x) => {
  const value = toRef(x);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply2(value, -1);
};
var calc2 = Object.assign(
  (x) => ({
    add: (...operands) => calc2(add2(x, ...operands)),
    subtract: (...operands) => calc2(subtract3(x, ...operands)),
    multiply: (...operands) => calc2(multiply2(x, ...operands)),
    divide: (...operands) => calc2(divide2(x, ...operands)),
    negate: () => calc2(negate2(x)),
    toString: () => x.toString()
  }),
  {
    add: add2,
    subtract: subtract3,
    multiply: multiply2,
    divide: divide2,
    negate: negate2
  }
);

// node_modules/@chakra-ui/theme-tools/dist/chunk-WSAJBJJ4.mjs
function isDecimal(value) {
  return !Number.isInteger(parseFloat(value.toString()));
}
function replaceWhiteSpace2(value, replaceValue = "-") {
  return value.replace(/\s+/g, replaceValue);
}
function escape2(value) {
  const valueStr = replaceWhiteSpace2(value.toString());
  if (valueStr.includes("\\."))
    return value;
  return isDecimal(value) ? valueStr.replace(".", `\\.`) : value;
}
function addPrefix2(value, prefix2 = "") {
  return [prefix2, escape2(value)].filter(Boolean).join("-");
}
function toVarRef(name, fallback) {
  return `var(${escape2(name)}${fallback ? `, ${fallback}` : ""})`;
}
function toVar(value, prefix2 = "") {
  return `--${addPrefix2(value, prefix2)}`;
}
function cssVar2(name, options) {
  const cssVariable = toVar(name, options == null ? void 0 : options.prefix);
  return {
    variable: cssVariable,
    reference: toVarRef(cssVariable, getFallback(options == null ? void 0 : options.fallback))
  };
}
function getFallback(fallback) {
  if (typeof fallback === "string")
    return fallback;
  return fallback == null ? void 0 : fallback.reference;
}

// node_modules/@chakra-ui/theme/dist/chunk-SG67NFYS.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig2, definePartsStyle: definePartsStyle2 } = createMultiStyleConfigHelpers(switchAnatomy.keys);
var $width = cssVar2("switch-track-width");
var $height = cssVar2("switch-track-height");
var $diff = cssVar2("switch-track-diff");
var diffValue = calc2.subtract($width, $height);
var $translateX = cssVar2("switch-thumb-x");
var $bg = cssVar2("switch-bg");
var baseStyleTrack = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    borderRadius: "full",
    p: "0.5",
    width: [$width.reference],
    height: [$height.reference],
    transitionProperty: "common",
    transitionDuration: "fast",
    [$bg.variable]: "colors.gray.300",
    _dark: {
      [$bg.variable]: "colors.whiteAlpha.400"
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    _checked: {
      [$bg.variable]: `colors.${c2}.500`,
      _dark: {
        [$bg.variable]: `colors.${c2}.200`
      }
    },
    bg: $bg.reference
  };
});
var baseStyleThumb = defineStyle({
  bg: "white",
  transitionProperty: "transform",
  transitionDuration: "normal",
  borderRadius: "inherit",
  width: [$height.reference],
  height: [$height.reference],
  _checked: {
    transform: `translateX(${$translateX.reference})`
  }
});
var baseStyle2 = definePartsStyle2((props) => ({
  container: {
    [$diff.variable]: diffValue,
    [$translateX.variable]: $diff.reference,
    _rtl: {
      [$translateX.variable]: calc2($diff).negate().toString()
    }
  },
  track: baseStyleTrack(props),
  thumb: baseStyleThumb
}));
var sizes2 = {
  sm: definePartsStyle2({
    container: {
      [$width.variable]: "1.375rem",
      [$height.variable]: "sizes.3"
    }
  }),
  md: definePartsStyle2({
    container: {
      [$width.variable]: "1.875rem",
      [$height.variable]: "sizes.4"
    }
  }),
  lg: definePartsStyle2({
    container: {
      [$width.variable]: "2.875rem",
      [$height.variable]: "sizes.6"
    }
  })
};
var switchTheme = defineMultiStyleConfig2({
  baseStyle: baseStyle2,
  sizes: sizes2,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-QWN3S45W.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig3, definePartsStyle: definePartsStyle3 } = createMultiStyleConfigHelpers(tableAnatomy.keys);
var baseStyle3 = definePartsStyle3({
  table: {
    fontVariantNumeric: "lining-nums tabular-nums",
    borderCollapse: "collapse",
    width: "full"
  },
  th: {
    fontFamily: "heading",
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: "wider",
    textAlign: "start"
  },
  td: {
    textAlign: "start"
  },
  caption: {
    mt: 4,
    fontFamily: "heading",
    textAlign: "center",
    fontWeight: "medium"
  }
});
var numericStyles = defineStyle({
  "&[data-is-numeric=true]": {
    textAlign: "end"
  }
});
var variantSimple = definePartsStyle3((props) => {
  const { colorScheme: c2 } = props;
  return {
    th: {
      color: mode("gray.600", "gray.400")(props),
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    td: {
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    caption: {
      color: mode("gray.600", "gray.100")(props)
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
});
var variantStripe = definePartsStyle3((props) => {
  const { colorScheme: c2 } = props;
  return {
    th: {
      color: mode("gray.600", "gray.400")(props),
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    td: {
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    caption: {
      color: mode("gray.600", "gray.100")(props)
    },
    tbody: {
      tr: {
        "&:nth-of-type(odd)": {
          "th, td": {
            borderBottomWidth: "1px",
            borderColor: mode(`${c2}.100`, `${c2}.700`)(props)
          },
          td: {
            background: mode(`${c2}.100`, `${c2}.700`)(props)
          }
        }
      }
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
});
var variants = {
  simple: variantSimple,
  striped: variantStripe,
  unstyled: defineStyle({})
};
var sizes3 = {
  sm: definePartsStyle3({
    th: {
      px: "4",
      py: "1",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "4",
      py: "2",
      fontSize: "sm",
      lineHeight: "4"
    },
    caption: {
      px: "4",
      py: "2",
      fontSize: "xs"
    }
  }),
  md: definePartsStyle3({
    th: {
      px: "6",
      py: "3",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "6",
      py: "4",
      lineHeight: "5"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "sm"
    }
  }),
  lg: definePartsStyle3({
    th: {
      px: "8",
      py: "4",
      lineHeight: "5",
      fontSize: "sm"
    },
    td: {
      px: "8",
      py: "5",
      lineHeight: "6"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "md"
    }
  })
};
var tableTheme = defineMultiStyleConfig3({
  baseStyle: baseStyle3,
  variants,
  sizes: sizes3,
  defaultProps: {
    variant: "simple",
    size: "md",
    colorScheme: "gray"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-GYISOX2E.mjs
var $fg = cssVar("tabs-color");
var $bg2 = cssVar("tabs-bg");
var $border = cssVar("tabs-border-color");
var { defineMultiStyleConfig: defineMultiStyleConfig4, definePartsStyle: definePartsStyle4 } = createMultiStyleConfigHelpers(tabsAnatomy.keys);
var baseStyleRoot = defineStyle((props) => {
  const { orientation } = props;
  return {
    display: orientation === "vertical" ? "flex" : "block"
  };
});
var baseStyleTab = defineStyle((props) => {
  const { isFitted } = props;
  return {
    flex: isFitted ? 1 : void 0,
    transitionProperty: "common",
    transitionDuration: "normal",
    _focusVisible: {
      zIndex: 1,
      boxShadow: "outline"
    },
    _disabled: {
      cursor: "not-allowed",
      opacity: 0.4
    }
  };
});
var baseStyleTablist = defineStyle((props) => {
  const { align = "start", orientation } = props;
  const alignments = {
    end: "flex-end",
    center: "center",
    start: "flex-start"
  };
  return {
    justifyContent: alignments[align],
    flexDirection: orientation === "vertical" ? "column" : "row"
  };
});
var baseStyleTabpanel = defineStyle({
  p: 4
});
var baseStyle4 = definePartsStyle4((props) => ({
  root: baseStyleRoot(props),
  tab: baseStyleTab(props),
  tablist: baseStyleTablist(props),
  tabpanel: baseStyleTabpanel
}));
var sizes4 = {
  sm: definePartsStyle4({
    tab: {
      py: 1,
      px: 4,
      fontSize: "sm"
    }
  }),
  md: definePartsStyle4({
    tab: {
      fontSize: "md",
      py: 2,
      px: 4
    }
  }),
  lg: definePartsStyle4({
    tab: {
      fontSize: "lg",
      py: 3,
      px: 4
    }
  })
};
var variantLine = definePartsStyle4((props) => {
  const { colorScheme: c2, orientation } = props;
  const isVertical = orientation === "vertical";
  const borderProp = isVertical ? "borderStart" : "borderBottom";
  const marginProp = isVertical ? "marginStart" : "marginBottom";
  return {
    tablist: {
      [borderProp]: "2px solid",
      borderColor: "inherit"
    },
    tab: {
      [borderProp]: "2px solid",
      borderColor: "transparent",
      [marginProp]: "-2px",
      _selected: {
        [$fg.variable]: `colors.${c2}.600`,
        _dark: {
          [$fg.variable]: `colors.${c2}.300`
        },
        borderColor: "currentColor"
      },
      _active: {
        [$bg2.variable]: "colors.gray.200",
        _dark: {
          [$bg2.variable]: "colors.whiteAlpha.300"
        }
      },
      _disabled: {
        _active: { bg: "none" }
      },
      color: $fg.reference,
      bg: $bg2.reference
    }
  };
});
var variantEnclosed = definePartsStyle4((props) => {
  const { colorScheme: c2 } = props;
  return {
    tab: {
      borderTopRadius: "md",
      border: "1px solid",
      borderColor: "transparent",
      mb: "-1px",
      [$border.variable]: "transparent",
      _selected: {
        [$fg.variable]: `colors.${c2}.600`,
        [$border.variable]: `colors.white`,
        _dark: {
          [$fg.variable]: `colors.${c2}.300`,
          [$border.variable]: `colors.gray.800`
        },
        borderColor: "inherit",
        borderBottomColor: $border.reference
      },
      color: $fg.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
});
var variantEnclosedColored = definePartsStyle4((props) => {
  const { colorScheme: c2 } = props;
  return {
    tab: {
      border: "1px solid",
      borderColor: "inherit",
      [$bg2.variable]: "colors.gray.50",
      _dark: {
        [$bg2.variable]: "colors.whiteAlpha.50"
      },
      mb: "-1px",
      _notLast: {
        marginEnd: "-1px"
      },
      _selected: {
        [$bg2.variable]: "colors.white",
        [$fg.variable]: `colors.${c2}.600`,
        _dark: {
          [$bg2.variable]: "colors.gray.800",
          [$fg.variable]: `colors.${c2}.300`
        },
        borderColor: "inherit",
        borderTopColor: "currentColor",
        borderBottomColor: "transparent"
      },
      color: $fg.reference,
      bg: $bg2.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
});
var variantSoftRounded = definePartsStyle4((props) => {
  const { colorScheme: c2, theme: theme3 } = props;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      color: "gray.600",
      _selected: {
        color: getColor(theme3, `${c2}.700`),
        bg: getColor(theme3, `${c2}.100`)
      }
    }
  };
});
var variantSolidRounded = definePartsStyle4((props) => {
  const { colorScheme: c2 } = props;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      [$fg.variable]: "colors.gray.600",
      _dark: {
        [$fg.variable]: "inherit"
      },
      _selected: {
        [$fg.variable]: "colors.white",
        [$bg2.variable]: `colors.${c2}.600`,
        _dark: {
          [$fg.variable]: "colors.gray.800",
          [$bg2.variable]: `colors.${c2}.300`
        }
      },
      color: $fg.reference,
      bg: $bg2.reference
    }
  };
});
var variantUnstyled = definePartsStyle4({});
var variants2 = {
  line: variantLine,
  enclosed: variantEnclosed,
  "enclosed-colored": variantEnclosedColored,
  "soft-rounded": variantSoftRounded,
  "solid-rounded": variantSolidRounded,
  unstyled: variantUnstyled
};
var tabsTheme = defineMultiStyleConfig4({
  baseStyle: baseStyle4,
  sizes: sizes4,
  variants: variants2,
  defaultProps: {
    size: "md",
    variant: "line",
    colorScheme: "blue"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-ZQMLTFF3.mjs
var vars = defineCssVars("badge", ["bg", "color", "shadow"]);
var baseStyle5 = defineStyle({
  px: 1,
  textTransform: "uppercase",
  fontSize: "xs",
  borderRadius: "sm",
  fontWeight: "bold",
  bg: vars.bg.reference,
  color: vars.color.reference,
  boxShadow: vars.shadow.reference
});
var variantSolid = defineStyle((props) => {
  const { colorScheme: c2, theme: theme3 } = props;
  const dark = transparentize2(`${c2}.500`, 0.6)(theme3);
  return {
    [vars.bg.variable]: `colors.${c2}.500`,
    [vars.color.variable]: `colors.white`,
    _dark: {
      [vars.bg.variable]: dark,
      [vars.color.variable]: `colors.whiteAlpha.800`
    }
  };
});
var variantSubtle = defineStyle((props) => {
  const { colorScheme: c2, theme: theme3 } = props;
  const darkBg = transparentize2(`${c2}.200`, 0.16)(theme3);
  return {
    [vars.bg.variable]: `colors.${c2}.100`,
    [vars.color.variable]: `colors.${c2}.800`,
    _dark: {
      [vars.bg.variable]: darkBg,
      [vars.color.variable]: `colors.${c2}.200`
    }
  };
});
var variantOutline = defineStyle((props) => {
  const { colorScheme: c2, theme: theme3 } = props;
  const darkColor = transparentize2(`${c2}.200`, 0.8)(theme3);
  return {
    [vars.color.variable]: `colors.${c2}.500`,
    _dark: {
      [vars.color.variable]: darkColor
    },
    [vars.shadow.variable]: `inset 0 0 0px 1px ${vars.color.reference}`
  };
});
var variants3 = {
  solid: variantSolid,
  subtle: variantSubtle,
  outline: variantOutline
};
var badgeTheme = defineStyleConfig({
  baseStyle: baseStyle5,
  variants: variants3,
  defaultProps: {
    variant: "subtle",
    colorScheme: "gray"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-7RVLYCMR.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig5, definePartsStyle: definePartsStyle5 } = createMultiStyleConfigHelpers(tagAnatomy.keys);
var $bg3 = cssVar("tag-bg");
var $color = cssVar("tag-color");
var $shadow = cssVar("tag-shadow");
var $minH = cssVar("tag-min-height");
var $minW = cssVar("tag-min-width");
var $fontSize = cssVar("tag-font-size");
var $paddingX = cssVar("tag-padding-inline");
var baseStyleContainer = defineStyle({
  fontWeight: "medium",
  lineHeight: 1.2,
  outline: 0,
  [$color.variable]: vars.color.reference,
  [$bg3.variable]: vars.bg.reference,
  [$shadow.variable]: vars.shadow.reference,
  color: $color.reference,
  bg: $bg3.reference,
  boxShadow: $shadow.reference,
  borderRadius: "md",
  minH: $minH.reference,
  minW: $minW.reference,
  fontSize: $fontSize.reference,
  px: $paddingX.reference,
  _focusVisible: {
    [$shadow.variable]: "shadows.outline"
  }
});
var baseStyleLabel = defineStyle({
  lineHeight: 1.2,
  overflow: "visible"
});
var baseStyleCloseButton = defineStyle({
  fontSize: "lg",
  w: "5",
  h: "5",
  transitionProperty: "common",
  transitionDuration: "normal",
  borderRadius: "full",
  marginStart: "1.5",
  marginEnd: "-1",
  opacity: 0.5,
  _disabled: {
    opacity: 0.4
  },
  _focusVisible: {
    boxShadow: "outline",
    bg: "rgba(0, 0, 0, 0.14)"
  },
  _hover: {
    opacity: 0.8
  },
  _active: {
    opacity: 1
  }
});
var baseStyle6 = definePartsStyle5({
  container: baseStyleContainer,
  label: baseStyleLabel,
  closeButton: baseStyleCloseButton
});
var sizes5 = {
  sm: definePartsStyle5({
    container: {
      [$minH.variable]: "sizes.5",
      [$minW.variable]: "sizes.5",
      [$fontSize.variable]: "fontSizes.xs",
      [$paddingX.variable]: "space.2"
    },
    closeButton: {
      marginEnd: "-2px",
      marginStart: "0.35rem"
    }
  }),
  md: definePartsStyle5({
    container: {
      [$minH.variable]: "sizes.6",
      [$minW.variable]: "sizes.6",
      [$fontSize.variable]: "fontSizes.sm",
      [$paddingX.variable]: "space.2"
    }
  }),
  lg: definePartsStyle5({
    container: {
      [$minH.variable]: "sizes.8",
      [$minW.variable]: "sizes.8",
      [$fontSize.variable]: "fontSizes.md",
      [$paddingX.variable]: "space.3"
    }
  })
};
var variants4 = {
  subtle: definePartsStyle5((props) => {
    var _a7;
    return {
      container: (_a7 = badgeTheme.variants) == null ? void 0 : _a7.subtle(props)
    };
  }),
  solid: definePartsStyle5((props) => {
    var _a7;
    return {
      container: (_a7 = badgeTheme.variants) == null ? void 0 : _a7.solid(props)
    };
  }),
  outline: definePartsStyle5((props) => {
    var _a7;
    return {
      container: (_a7 = badgeTheme.variants) == null ? void 0 : _a7.outline(props)
    };
  })
};
var tagTheme = defineMultiStyleConfig5({
  variants: variants4,
  baseStyle: baseStyle6,
  sizes: sizes5,
  defaultProps: {
    size: "md",
    variant: "subtle",
    colorScheme: "gray"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-ICL3HPTT.mjs
var { definePartsStyle: definePartsStyle6, defineMultiStyleConfig: defineMultiStyleConfig6 } = createMultiStyleConfigHelpers(inputAnatomy.keys);
var $height2 = cssVar("input-height");
var $fontSize2 = cssVar("input-font-size");
var $padding = cssVar("input-padding");
var $borderRadius = cssVar("input-border-radius");
var baseStyle7 = definePartsStyle6({
  addon: {
    height: $height2.reference,
    fontSize: $fontSize2.reference,
    px: $padding.reference,
    borderRadius: $borderRadius.reference
  },
  field: {
    width: "100%",
    height: $height2.reference,
    fontSize: $fontSize2.reference,
    px: $padding.reference,
    borderRadius: $borderRadius.reference,
    minWidth: 0,
    outline: 0,
    position: "relative",
    appearance: "none",
    transitionProperty: "common",
    transitionDuration: "normal",
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    }
  }
});
var size2 = {
  lg: defineStyle({
    [$fontSize2.variable]: "fontSizes.lg",
    [$padding.variable]: "space.4",
    [$borderRadius.variable]: "radii.md",
    [$height2.variable]: "sizes.12"
  }),
  md: defineStyle({
    [$fontSize2.variable]: "fontSizes.md",
    [$padding.variable]: "space.4",
    [$borderRadius.variable]: "radii.md",
    [$height2.variable]: "sizes.10"
  }),
  sm: defineStyle({
    [$fontSize2.variable]: "fontSizes.sm",
    [$padding.variable]: "space.3",
    [$borderRadius.variable]: "radii.sm",
    [$height2.variable]: "sizes.8"
  }),
  xs: defineStyle({
    [$fontSize2.variable]: "fontSizes.xs",
    [$padding.variable]: "space.2",
    [$borderRadius.variable]: "radii.sm",
    [$height2.variable]: "sizes.6"
  })
};
var sizes6 = {
  lg: definePartsStyle6({
    field: size2.lg,
    group: size2.lg
  }),
  md: definePartsStyle6({
    field: size2.md,
    group: size2.md
  }),
  sm: definePartsStyle6({
    field: size2.sm,
    group: size2.sm
  }),
  xs: definePartsStyle6({
    field: size2.xs,
    group: size2.xs
  })
};
function getDefaults(props) {
  const { focusBorderColor: fc, errorBorderColor: ec } = props;
  return {
    focusBorderColor: fc || mode("blue.500", "blue.300")(props),
    errorBorderColor: ec || mode("red.500", "red.300")(props)
  };
}
var variantOutline2 = definePartsStyle6((props) => {
  const { theme: theme3 } = props;
  const { focusBorderColor: fc, errorBorderColor: ec } = getDefaults(props);
  return {
    field: {
      border: "1px solid",
      borderColor: "inherit",
      bg: "inherit",
      _hover: {
        borderColor: mode("gray.300", "whiteAlpha.400")(props)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: getColor(theme3, ec),
        boxShadow: `0 0 0 1px ${getColor(theme3, ec)}`
      },
      _focusVisible: {
        zIndex: 1,
        borderColor: getColor(theme3, fc),
        boxShadow: `0 0 0 1px ${getColor(theme3, fc)}`
      }
    },
    addon: {
      border: "1px solid",
      borderColor: mode("inherit", "whiteAlpha.50")(props),
      bg: mode("gray.100", "whiteAlpha.300")(props)
    }
  };
});
var variantFilled = definePartsStyle6((props) => {
  const { theme: theme3 } = props;
  const { focusBorderColor: fc, errorBorderColor: ec } = getDefaults(props);
  return {
    field: {
      border: "2px solid",
      borderColor: "transparent",
      bg: mode("gray.100", "whiteAlpha.50")(props),
      _hover: {
        bg: mode("gray.200", "whiteAlpha.100")(props)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: getColor(theme3, ec)
      },
      _focusVisible: {
        bg: "transparent",
        borderColor: getColor(theme3, fc)
      }
    },
    addon: {
      border: "2px solid",
      borderColor: "transparent",
      bg: mode("gray.100", "whiteAlpha.50")(props)
    }
  };
});
var variantFlushed = definePartsStyle6((props) => {
  const { theme: theme3 } = props;
  const { focusBorderColor: fc, errorBorderColor: ec } = getDefaults(props);
  return {
    field: {
      borderBottom: "1px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent",
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: getColor(theme3, ec),
        boxShadow: `0px 1px 0px 0px ${getColor(theme3, ec)}`
      },
      _focusVisible: {
        borderColor: getColor(theme3, fc),
        boxShadow: `0px 1px 0px 0px ${getColor(theme3, fc)}`
      }
    },
    addon: {
      borderBottom: "2px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent"
    }
  };
});
var variantUnstyled2 = definePartsStyle6({
  field: {
    bg: "transparent",
    px: "0",
    height: "auto"
  },
  addon: {
    bg: "transparent",
    px: "0",
    height: "auto"
  }
});
var variants5 = {
  outline: variantOutline2,
  filled: variantFilled,
  flushed: variantFlushed,
  unstyled: variantUnstyled2
};
var inputTheme = defineMultiStyleConfig6({
  baseStyle: baseStyle7,
  sizes: sizes6,
  variants: variants5,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-KJ26FGJD.mjs
var _a;
var baseStyle8 = defineStyle({
  ...(_a = inputTheme.baseStyle) == null ? void 0 : _a.field,
  paddingY: "2",
  minHeight: "20",
  lineHeight: "short",
  verticalAlign: "top"
});
var _a2;
var _b;
var variants6 = {
  outline: defineStyle(
    (props) => {
      var _a42, _b32;
      return (_b32 = (_a42 = inputTheme.variants) == null ? void 0 : _a42.outline(props).field) != null ? _b32 : {};
    }
  ),
  flushed: defineStyle(
    (props) => {
      var _a42, _b32;
      return (_b32 = (_a42 = inputTheme.variants) == null ? void 0 : _a42.flushed(props).field) != null ? _b32 : {};
    }
  ),
  filled: defineStyle(
    (props) => {
      var _a42, _b32;
      return (_b32 = (_a42 = inputTheme.variants) == null ? void 0 : _a42.filled(props).field) != null ? _b32 : {};
    }
  ),
  unstyled: (_b = (_a2 = inputTheme.variants) == null ? void 0 : _a2.unstyled.field) != null ? _b : {}
};
var _a3;
var _b2;
var _c;
var _d;
var _e;
var _f;
var _g;
var _h;
var sizes7 = {
  xs: (_b2 = (_a3 = inputTheme.sizes) == null ? void 0 : _a3.xs.field) != null ? _b2 : {},
  sm: (_d = (_c = inputTheme.sizes) == null ? void 0 : _c.sm.field) != null ? _d : {},
  md: (_f = (_e = inputTheme.sizes) == null ? void 0 : _e.md.field) != null ? _f : {},
  lg: (_h = (_g = inputTheme.sizes) == null ? void 0 : _g.lg.field) != null ? _h : {}
};
var textareaTheme = defineStyleConfig({
  baseStyle: baseStyle8,
  sizes: sizes7,
  variants: variants6,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-R7ZISUMV.mjs
var $bg4 = cssVar2("tooltip-bg");
var $fg2 = cssVar2("tooltip-fg");
var $arrowBg = cssVar2("popper-arrow-bg");
var baseStyle9 = defineStyle({
  bg: $bg4.reference,
  color: $fg2.reference,
  [$bg4.variable]: "colors.gray.700",
  [$fg2.variable]: "colors.whiteAlpha.900",
  _dark: {
    [$bg4.variable]: "colors.gray.300",
    [$fg2.variable]: "colors.gray.900"
  },
  [$arrowBg.variable]: $bg4.reference,
  px: "2",
  py: "0.5",
  borderRadius: "sm",
  fontWeight: "medium",
  fontSize: "sm",
  boxShadow: "md",
  maxW: "xs",
  zIndex: "tooltip"
});
var tooltipTheme = defineStyleConfig({
  baseStyle: baseStyle9
});

// node_modules/@chakra-ui/theme/dist/chunk-37MNRBP2.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig7, definePartsStyle: definePartsStyle7 } = createMultiStyleConfigHelpers(progressAnatomy.keys);
var filledStyle = defineStyle((props) => {
  const { colorScheme: c2, theme: t2, isIndeterminate, hasStripe } = props;
  const stripeStyle = mode(
    generateStripe(),
    generateStripe("1rem", "rgba(0,0,0,0.1)")
  )(props);
  const bgColor = mode(`${c2}.500`, `${c2}.200`)(props);
  const gradient = `linear-gradient(
    to right,
    transparent 0%,
    ${getColor(t2, bgColor)} 50%,
    transparent 100%
  )`;
  const addStripe = !isIndeterminate && hasStripe;
  return {
    ...addStripe && stripeStyle,
    ...isIndeterminate ? { bgImage: gradient } : { bgColor }
  };
});
var baseStyleLabel2 = defineStyle({
  lineHeight: "1",
  fontSize: "0.25em",
  fontWeight: "bold",
  color: "white"
});
var baseStyleTrack2 = defineStyle((props) => {
  return {
    bg: mode("gray.100", "whiteAlpha.300")(props)
  };
});
var baseStyleFilledTrack = defineStyle((props) => {
  return {
    transitionProperty: "common",
    transitionDuration: "slow",
    ...filledStyle(props)
  };
});
var baseStyle10 = definePartsStyle7((props) => ({
  label: baseStyleLabel2,
  filledTrack: baseStyleFilledTrack(props),
  track: baseStyleTrack2(props)
}));
var sizes8 = {
  xs: definePartsStyle7({
    track: { h: "1" }
  }),
  sm: definePartsStyle7({
    track: { h: "2" }
  }),
  md: definePartsStyle7({
    track: { h: "3" }
  }),
  lg: definePartsStyle7({
    track: { h: "4" }
  })
};
var progressTheme = defineMultiStyleConfig7({
  sizes: sizes8,
  baseStyle: baseStyle10,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-UV3F75RF.mjs
var isFunction2 = (value) => typeof value === "function";
function runIfFn2(valueOrFn, ...args) {
  return isFunction2(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}

// node_modules/@chakra-ui/theme/dist/chunk-XHYVH6UO.mjs
var { definePartsStyle: definePartsStyle8, defineMultiStyleConfig: defineMultiStyleConfig8 } = createMultiStyleConfigHelpers(checkboxAnatomy.keys);
var $size2 = cssVar("checkbox-size");
var baseStyleControl = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    w: $size2.reference,
    h: $size2.reference,
    transitionProperty: "box-shadow",
    transitionDuration: "normal",
    border: "2px solid",
    borderRadius: "sm",
    borderColor: "inherit",
    color: "white",
    _checked: {
      bg: mode(`${c2}.500`, `${c2}.200`)(props),
      borderColor: mode(`${c2}.500`, `${c2}.200`)(props),
      color: mode("white", "gray.900")(props),
      _hover: {
        bg: mode(`${c2}.600`, `${c2}.300`)(props),
        borderColor: mode(`${c2}.600`, `${c2}.300`)(props)
      },
      _disabled: {
        borderColor: mode("gray.200", "transparent")(props),
        bg: mode("gray.200", "whiteAlpha.300")(props),
        color: mode("gray.500", "whiteAlpha.500")(props)
      }
    },
    _indeterminate: {
      bg: mode(`${c2}.500`, `${c2}.200`)(props),
      borderColor: mode(`${c2}.500`, `${c2}.200`)(props),
      color: mode("white", "gray.900")(props)
    },
    _disabled: {
      bg: mode("gray.100", "whiteAlpha.100")(props),
      borderColor: mode("gray.100", "transparent")(props)
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _invalid: {
      borderColor: mode("red.500", "red.300")(props)
    }
  };
});
var baseStyleContainer2 = defineStyle({
  _disabled: { cursor: "not-allowed" }
});
var baseStyleLabel3 = defineStyle({
  userSelect: "none",
  _disabled: { opacity: 0.4 }
});
var baseStyleIcon = defineStyle({
  transitionProperty: "transform",
  transitionDuration: "normal"
});
var baseStyle11 = definePartsStyle8((props) => ({
  icon: baseStyleIcon,
  container: baseStyleContainer2,
  control: runIfFn2(baseStyleControl, props),
  label: baseStyleLabel3
}));
var sizes9 = {
  sm: definePartsStyle8({
    control: { [$size2.variable]: "sizes.3" },
    label: { fontSize: "sm" },
    icon: { fontSize: "3xs" }
  }),
  md: definePartsStyle8({
    control: { [$size2.variable]: "sizes.4" },
    label: { fontSize: "md" },
    icon: { fontSize: "2xs" }
  }),
  lg: definePartsStyle8({
    control: { [$size2.variable]: "sizes.5" },
    label: { fontSize: "lg" },
    icon: { fontSize: "2xs" }
  })
};
var checkboxTheme = defineMultiStyleConfig8({
  baseStyle: baseStyle11,
  sizes: sizes9,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-VZUATZ4E.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig9, definePartsStyle: definePartsStyle9 } = createMultiStyleConfigHelpers(radioAnatomy.keys);
var baseStyleControl2 = defineStyle((props) => {
  var _a7;
  const controlStyle = (_a7 = runIfFn2(checkboxTheme.baseStyle, props)) == null ? void 0 : _a7.control;
  return {
    ...controlStyle,
    borderRadius: "full",
    _checked: {
      ...controlStyle == null ? void 0 : controlStyle["_checked"],
      _before: {
        content: `""`,
        display: "inline-block",
        pos: "relative",
        w: "50%",
        h: "50%",
        borderRadius: "50%",
        bg: "currentColor"
      }
    }
  };
});
var baseStyle12 = definePartsStyle9((props) => {
  var _a7, _b5, _c14, _d3;
  return {
    label: (_b5 = (_a7 = checkboxTheme).baseStyle) == null ? void 0 : _b5.call(_a7, props).label,
    container: (_d3 = (_c14 = checkboxTheme).baseStyle) == null ? void 0 : _d3.call(_c14, props).container,
    control: baseStyleControl2(props)
  };
});
var sizes10 = {
  md: definePartsStyle9({
    control: { w: "4", h: "4" },
    label: { fontSize: "md" }
  }),
  lg: definePartsStyle9({
    control: { w: "5", h: "5" },
    label: { fontSize: "lg" }
  }),
  sm: definePartsStyle9({
    control: { width: "3", height: "3" },
    label: { fontSize: "sm" }
  })
};
var radioTheme = defineMultiStyleConfig9({
  baseStyle: baseStyle12,
  sizes: sizes10,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-NNA4E64A.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig10, definePartsStyle: definePartsStyle10 } = createMultiStyleConfigHelpers(selectAnatomy.keys);
var $bg5 = cssVar("select-bg");
var _a4;
var baseStyleField = defineStyle({
  ...(_a4 = inputTheme.baseStyle) == null ? void 0 : _a4.field,
  appearance: "none",
  paddingBottom: "1px",
  lineHeight: "normal",
  bg: $bg5.reference,
  [$bg5.variable]: "colors.white",
  _dark: {
    [$bg5.variable]: "colors.gray.700"
  },
  "> option, > optgroup": {
    bg: $bg5.reference
  }
});
var baseStyleIcon2 = defineStyle({
  width: "6",
  height: "100%",
  insetEnd: "2",
  position: "relative",
  color: "currentColor",
  fontSize: "xl",
  _disabled: {
    opacity: 0.5
  }
});
var baseStyle13 = definePartsStyle10({
  field: baseStyleField,
  icon: baseStyleIcon2
});
var iconSpacing = defineStyle({
  paddingInlineEnd: "8"
});
var _a22;
var _b3;
var _c2;
var _d2;
var _e2;
var _f2;
var _g2;
var _h2;
var sizes11 = {
  lg: {
    ...(_a22 = inputTheme.sizes) == null ? void 0 : _a22.lg,
    field: {
      ...(_b3 = inputTheme.sizes) == null ? void 0 : _b3.lg.field,
      ...iconSpacing
    }
  },
  md: {
    ...(_c2 = inputTheme.sizes) == null ? void 0 : _c2.md,
    field: {
      ...(_d2 = inputTheme.sizes) == null ? void 0 : _d2.md.field,
      ...iconSpacing
    }
  },
  sm: {
    ...(_e2 = inputTheme.sizes) == null ? void 0 : _e2.sm,
    field: {
      ...(_f2 = inputTheme.sizes) == null ? void 0 : _f2.sm.field,
      ...iconSpacing
    }
  },
  xs: {
    ...(_g2 = inputTheme.sizes) == null ? void 0 : _g2.xs,
    field: {
      ...(_h2 = inputTheme.sizes) == null ? void 0 : _h2.xs.field,
      ...iconSpacing
    },
    icon: {
      insetEnd: "1"
    }
  }
};
var selectTheme = defineMultiStyleConfig10({
  baseStyle: baseStyle13,
  sizes: sizes11,
  variants: inputTheme.variants,
  defaultProps: inputTheme.defaultProps
});

// node_modules/@chakra-ui/theme/dist/chunk-X6XFE4TF.mjs
var $startColor = cssVar("skeleton-start-color");
var $endColor = cssVar("skeleton-end-color");
var baseStyle14 = defineStyle({
  [$startColor.variable]: "colors.gray.100",
  [$endColor.variable]: "colors.gray.400",
  _dark: {
    [$startColor.variable]: "colors.gray.800",
    [$endColor.variable]: "colors.gray.600"
  },
  background: $startColor.reference,
  borderColor: $endColor.reference,
  opacity: 0.7,
  borderRadius: "sm"
});
var skeletonTheme = defineStyleConfig({
  baseStyle: baseStyle14
});

// node_modules/@chakra-ui/theme/dist/chunk-ZREGO6US.mjs
var $bg6 = cssVar("skip-link-bg");
var baseStyle15 = defineStyle({
  borderRadius: "md",
  fontWeight: "semibold",
  _focusVisible: {
    boxShadow: "outline",
    padding: "4",
    position: "fixed",
    top: "6",
    insetStart: "6",
    [$bg6.variable]: "colors.white",
    _dark: {
      [$bg6.variable]: "colors.gray.700"
    },
    bg: $bg6.reference
  }
});
var skipLinkTheme = defineStyleConfig({
  baseStyle: baseStyle15
});

// node_modules/@chakra-ui/theme/dist/chunk-5FA7Y3RP.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig11, definePartsStyle: definePartsStyle11 } = createMultiStyleConfigHelpers(sliderAnatomy.keys);
var $thumbSize = cssVar("slider-thumb-size");
var $trackSize = cssVar("slider-track-size");
var $bg7 = cssVar("slider-bg");
var baseStyleContainer3 = defineStyle((props) => {
  const { orientation } = props;
  return {
    display: "inline-block",
    position: "relative",
    cursor: "pointer",
    _disabled: {
      opacity: 0.6,
      cursor: "default",
      pointerEvents: "none"
    },
    ...orient({
      orientation,
      vertical: { h: "100%" },
      horizontal: { w: "100%" }
    })
  };
});
var baseStyleTrack3 = defineStyle((props) => {
  const orientationStyles = orient({
    orientation: props.orientation,
    horizontal: { h: $trackSize.reference },
    vertical: { w: $trackSize.reference }
  });
  return {
    ...orientationStyles,
    overflow: "hidden",
    borderRadius: "sm",
    [$bg7.variable]: "colors.gray.200",
    _dark: {
      [$bg7.variable]: "colors.whiteAlpha.200"
    },
    _disabled: {
      [$bg7.variable]: "colors.gray.300",
      _dark: {
        [$bg7.variable]: "colors.whiteAlpha.300"
      }
    },
    bg: $bg7.reference
  };
});
var baseStyleThumb2 = defineStyle((props) => {
  const { orientation } = props;
  const orientationStyle = orient({
    orientation,
    vertical: {
      left: "50%",
      transform: `translateX(-50%)`,
      _active: {
        transform: `translateX(-50%) scale(1.15)`
      }
    },
    horizontal: {
      top: "50%",
      transform: `translateY(-50%)`,
      _active: {
        transform: `translateY(-50%) scale(1.15)`
      }
    }
  });
  return {
    ...orientationStyle,
    w: $thumbSize.reference,
    h: $thumbSize.reference,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    outline: 0,
    zIndex: 1,
    borderRadius: "full",
    bg: "white",
    boxShadow: "base",
    border: "1px solid",
    borderColor: "transparent",
    transitionProperty: "transform",
    transitionDuration: "normal",
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      bg: "gray.300"
    }
  };
});
var baseStyleFilledTrack2 = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    width: "inherit",
    height: "inherit",
    [$bg7.variable]: `colors.${c2}.500`,
    _dark: {
      [$bg7.variable]: `colors.${c2}.200`
    },
    bg: $bg7.reference
  };
});
var baseStyle16 = definePartsStyle11((props) => ({
  container: baseStyleContainer3(props),
  track: baseStyleTrack3(props),
  thumb: baseStyleThumb2(props),
  filledTrack: baseStyleFilledTrack2(props)
}));
var sizeLg = definePartsStyle11({
  container: {
    [$thumbSize.variable]: `sizes.4`,
    [$trackSize.variable]: `sizes.1`
  }
});
var sizeMd = definePartsStyle11({
  container: {
    [$thumbSize.variable]: `sizes.3.5`,
    [$trackSize.variable]: `sizes.1`
  }
});
var sizeSm = definePartsStyle11({
  container: {
    [$thumbSize.variable]: `sizes.2.5`,
    [$trackSize.variable]: `sizes.0.5`
  }
});
var sizes12 = {
  lg: sizeLg,
  md: sizeMd,
  sm: sizeSm
};
var sliderTheme = defineMultiStyleConfig11({
  baseStyle: baseStyle16,
  sizes: sizes12,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-L3YAB6CV.mjs
var $size3 = cssVar2("spinner-size");
var baseStyle17 = defineStyle({
  width: [$size3.reference],
  height: [$size3.reference]
});
var sizes13 = {
  xs: defineStyle({
    [$size3.variable]: "sizes.3"
  }),
  sm: defineStyle({
    [$size3.variable]: "sizes.4"
  }),
  md: defineStyle({
    [$size3.variable]: "sizes.6"
  }),
  lg: defineStyle({
    [$size3.variable]: "sizes.8"
  }),
  xl: defineStyle({
    [$size3.variable]: "sizes.12"
  })
};
var spinnerTheme = defineStyleConfig({
  baseStyle: baseStyle17,
  sizes: sizes13,
  defaultProps: {
    size: "md"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-2KWJXISX.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig12, definePartsStyle: definePartsStyle12 } = createMultiStyleConfigHelpers(statAnatomy.keys);
var baseStyleLabel4 = defineStyle({
  fontWeight: "medium"
});
var baseStyleHelpText = defineStyle({
  opacity: 0.8,
  marginBottom: "2"
});
var baseStyleNumber = defineStyle({
  verticalAlign: "baseline",
  fontWeight: "semibold"
});
var baseStyleIcon3 = defineStyle({
  marginEnd: 1,
  w: "3.5",
  h: "3.5",
  verticalAlign: "middle"
});
var baseStyle18 = definePartsStyle12({
  container: {},
  label: baseStyleLabel4,
  helpText: baseStyleHelpText,
  number: baseStyleNumber,
  icon: baseStyleIcon3
});
var sizes14 = {
  md: definePartsStyle12({
    label: { fontSize: "sm" },
    helpText: { fontSize: "sm" },
    number: { fontSize: "2xl" }
  })
};
var statTheme = defineMultiStyleConfig12({
  baseStyle: baseStyle18,
  sizes: sizes14,
  defaultProps: {
    size: "md"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-AFCBUAM5.mjs
var $bg8 = cssVar("kbd-bg");
var baseStyle19 = defineStyle({
  [$bg8.variable]: "colors.gray.100",
  _dark: {
    [$bg8.variable]: "colors.whiteAlpha.100"
  },
  bg: $bg8.reference,
  borderRadius: "md",
  borderWidth: "1px",
  borderBottomWidth: "3px",
  fontSize: "0.8em",
  fontWeight: "bold",
  lineHeight: "normal",
  px: "0.4em",
  whiteSpace: "nowrap"
});
var kbdTheme = defineStyleConfig({
  baseStyle: baseStyle19
});

// node_modules/@chakra-ui/theme/dist/chunk-V5KSHSOQ.mjs
var baseStyle20 = defineStyle({
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  cursor: "pointer",
  textDecoration: "none",
  outline: "none",
  color: "inherit",
  _hover: {
    textDecoration: "underline"
  },
  _focusVisible: {
    boxShadow: "outline"
  }
});
var linkTheme = defineStyleConfig({
  baseStyle: baseStyle20
});

// node_modules/@chakra-ui/theme/dist/chunk-MGNM2WZQ.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig13, definePartsStyle: definePartsStyle13 } = createMultiStyleConfigHelpers(listAnatomy.keys);
var baseStyleIcon4 = defineStyle({
  marginEnd: "2",
  display: "inline",
  verticalAlign: "text-bottom"
});
var baseStyle21 = definePartsStyle13({
  icon: baseStyleIcon4
});
var listTheme = defineMultiStyleConfig13({
  baseStyle: baseStyle21
});

// node_modules/@chakra-ui/theme/dist/chunk-N2GP2AF7.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig14, definePartsStyle: definePartsStyle14 } = createMultiStyleConfigHelpers(menuAnatomy.keys);
var $bg9 = cssVar("menu-bg");
var $shadow2 = cssVar("menu-shadow");
var baseStyleList = defineStyle({
  [$bg9.variable]: "#fff",
  [$shadow2.variable]: "shadows.sm",
  _dark: {
    [$bg9.variable]: "colors.gray.700",
    [$shadow2.variable]: "shadows.dark-lg"
  },
  color: "inherit",
  minW: "3xs",
  py: "2",
  zIndex: 1,
  borderRadius: "md",
  borderWidth: "1px",
  bg: $bg9.reference,
  boxShadow: $shadow2.reference
});
var baseStyleItem = defineStyle({
  py: "1.5",
  px: "3",
  transitionProperty: "background",
  transitionDuration: "ultra-fast",
  transitionTimingFunction: "ease-in",
  _focus: {
    [$bg9.variable]: "colors.gray.100",
    _dark: {
      [$bg9.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [$bg9.variable]: "colors.gray.200",
    _dark: {
      [$bg9.variable]: "colors.whiteAlpha.200"
    }
  },
  _expanded: {
    [$bg9.variable]: "colors.gray.100",
    _dark: {
      [$bg9.variable]: "colors.whiteAlpha.100"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  bg: $bg9.reference
});
var baseStyleGroupTitle = defineStyle({
  mx: 4,
  my: 2,
  fontWeight: "semibold",
  fontSize: "sm"
});
var baseStyleIcon5 = defineStyle({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0
});
var baseStyleCommand = defineStyle({
  opacity: 0.6
});
var baseStyleDivider = defineStyle({
  border: 0,
  borderBottom: "1px solid",
  borderColor: "inherit",
  my: "2",
  opacity: 0.6
});
var baseStyleButton = defineStyle({
  transitionProperty: "common",
  transitionDuration: "normal"
});
var baseStyle22 = definePartsStyle14({
  button: baseStyleButton,
  list: baseStyleList,
  item: baseStyleItem,
  groupTitle: baseStyleGroupTitle,
  icon: baseStyleIcon5,
  command: baseStyleCommand,
  divider: baseStyleDivider
});
var menuTheme = defineMultiStyleConfig14({
  baseStyle: baseStyle22
});

// node_modules/@chakra-ui/theme/dist/chunk-JN6QBAR6.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig15, definePartsStyle: definePartsStyle15 } = createMultiStyleConfigHelpers(modalAnatomy.keys);
var $bg10 = cssVar("modal-bg");
var $shadow3 = cssVar("modal-shadow");
var baseStyleOverlay = defineStyle({
  bg: "blackAlpha.600",
  zIndex: "modal"
});
var baseStyleDialogContainer = defineStyle((props) => {
  const { isCentered, scrollBehavior } = props;
  return {
    display: "flex",
    zIndex: "modal",
    justifyContent: "center",
    alignItems: isCentered ? "center" : "flex-start",
    overflow: scrollBehavior === "inside" ? "hidden" : "auto",
    overscrollBehaviorY: "none"
  };
});
var baseStyleDialog = defineStyle((props) => {
  const { isCentered, scrollBehavior } = props;
  return {
    borderRadius: "md",
    color: "inherit",
    my: isCentered ? "auto" : "16",
    mx: isCentered ? "auto" : void 0,
    zIndex: "modal",
    maxH: scrollBehavior === "inside" ? "calc(100% - 7.5rem)" : void 0,
    [$bg10.variable]: "colors.white",
    [$shadow3.variable]: "shadows.lg",
    _dark: {
      [$bg10.variable]: "colors.gray.700",
      [$shadow3.variable]: "shadows.dark-lg"
    },
    bg: $bg10.reference,
    boxShadow: $shadow3.reference
  };
});
var baseStyleHeader = defineStyle({
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
});
var baseStyleCloseButton2 = defineStyle({
  position: "absolute",
  top: "2",
  insetEnd: "3"
});
var baseStyleBody = defineStyle((props) => {
  const { scrollBehavior } = props;
  return {
    px: "6",
    py: "2",
    flex: "1",
    overflow: scrollBehavior === "inside" ? "auto" : void 0
  };
});
var baseStyleFooter = defineStyle({
  px: "6",
  py: "4"
});
var baseStyle23 = definePartsStyle15((props) => ({
  overlay: baseStyleOverlay,
  dialogContainer: runIfFn2(baseStyleDialogContainer, props),
  dialog: runIfFn2(baseStyleDialog, props),
  header: baseStyleHeader,
  closeButton: baseStyleCloseButton2,
  body: runIfFn2(baseStyleBody, props),
  footer: baseStyleFooter
}));
function getSize(value) {
  if (value === "full") {
    return definePartsStyle15({
      dialog: {
        maxW: "100vw",
        minH: "$100vh",
        my: "0",
        borderRadius: "0"
      }
    });
  }
  return definePartsStyle15({
    dialog: { maxW: value }
  });
}
var sizes15 = {
  xs: getSize("xs"),
  sm: getSize("sm"),
  md: getSize("md"),
  lg: getSize("lg"),
  xl: getSize("xl"),
  "2xl": getSize("2xl"),
  "3xl": getSize("3xl"),
  "4xl": getSize("4xl"),
  "5xl": getSize("5xl"),
  "6xl": getSize("6xl"),
  full: getSize("full")
};
var modalTheme = defineMultiStyleConfig15({
  baseStyle: baseStyle23,
  sizes: sizes15,
  defaultProps: { size: "md" }
});

// node_modules/@chakra-ui/theme/dist/chunk-57T4IAPW.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig16, definePartsStyle: definePartsStyle16 } = createMultiStyleConfigHelpers(numberInputAnatomy.keys);
var $stepperWidth = cssVar2("number-input-stepper-width");
var $inputPadding = cssVar2("number-input-input-padding");
var inputPaddingValue = calc2($stepperWidth).add("0.5rem").toString();
var $bg11 = cssVar2("number-input-bg");
var $fg3 = cssVar2("number-input-color");
var $border2 = cssVar2("number-input-border-color");
var baseStyleRoot2 = defineStyle({
  [$stepperWidth.variable]: "sizes.6",
  [$inputPadding.variable]: inputPaddingValue
});
var baseStyleField2 = defineStyle(
  (props) => {
    var _a7, _b5;
    return (_b5 = (_a7 = runIfFn2(inputTheme.baseStyle, props)) == null ? void 0 : _a7.field) != null ? _b5 : {};
  }
);
var baseStyleStepperGroup = defineStyle({
  width: $stepperWidth.reference
});
var baseStyleStepper = defineStyle({
  borderStart: "1px solid",
  borderStartColor: $border2.reference,
  color: $fg3.reference,
  bg: $bg11.reference,
  [$fg3.variable]: "colors.chakra-body-text",
  [$border2.variable]: "colors.chakra-border-color",
  _dark: {
    [$fg3.variable]: "colors.whiteAlpha.800",
    [$border2.variable]: "colors.whiteAlpha.300"
  },
  _active: {
    [$bg11.variable]: "colors.gray.200",
    _dark: {
      [$bg11.variable]: "colors.whiteAlpha.300"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  }
});
var baseStyle24 = definePartsStyle16((props) => {
  var _a7;
  return {
    root: baseStyleRoot2,
    field: (_a7 = runIfFn2(baseStyleField2, props)) != null ? _a7 : {},
    stepperGroup: baseStyleStepperGroup,
    stepper: baseStyleStepper
  };
});
function getSize2(size3) {
  var _a7, _b5, _c14;
  const sizeStyle = (_a7 = inputTheme.sizes) == null ? void 0 : _a7[size3];
  const radius = {
    lg: "md",
    md: "md",
    sm: "sm",
    xs: "sm"
  };
  const _fontSize = (_c14 = (_b5 = sizeStyle.field) == null ? void 0 : _b5.fontSize) != null ? _c14 : "md";
  const fontSize = typography_default.fontSizes[_fontSize];
  return definePartsStyle16({
    field: {
      ...sizeStyle.field,
      paddingInlineEnd: $inputPadding.reference,
      verticalAlign: "top"
    },
    stepper: {
      fontSize: calc2(fontSize).multiply(0.75).toString(),
      _first: {
        borderTopEndRadius: radius[size3]
      },
      _last: {
        borderBottomEndRadius: radius[size3],
        mt: "-1px",
        borderTopWidth: 1
      }
    }
  });
}
var sizes16 = {
  xs: getSize2("xs"),
  sm: getSize2("sm"),
  md: getSize2("md"),
  lg: getSize2("lg")
};
var numberInputTheme = defineMultiStyleConfig16({
  baseStyle: baseStyle24,
  sizes: sizes16,
  variants: inputTheme.variants,
  defaultProps: inputTheme.defaultProps
});

// node_modules/@chakra-ui/theme/dist/chunk-OEFJDLVS.mjs
var _a5;
var baseStyle25 = defineStyle({
  ...(_a5 = inputTheme.baseStyle) == null ? void 0 : _a5.field,
  textAlign: "center"
});
var sizes17 = {
  lg: defineStyle({
    fontSize: "lg",
    w: 12,
    h: 12,
    borderRadius: "md"
  }),
  md: defineStyle({
    fontSize: "md",
    w: 10,
    h: 10,
    borderRadius: "md"
  }),
  sm: defineStyle({
    fontSize: "sm",
    w: 8,
    h: 8,
    borderRadius: "sm"
  }),
  xs: defineStyle({
    fontSize: "xs",
    w: 6,
    h: 6,
    borderRadius: "sm"
  })
};
var _a23;
var _b4;
var variants7 = {
  outline: defineStyle(
    (props) => {
      var _a32, _b22, _c14;
      return (_c14 = (_b22 = runIfFn2((_a32 = inputTheme.variants) == null ? void 0 : _a32.outline, props)) == null ? void 0 : _b22.field) != null ? _c14 : {};
    }
  ),
  flushed: defineStyle(
    (props) => {
      var _a32, _b22, _c14;
      return (_c14 = (_b22 = runIfFn2((_a32 = inputTheme.variants) == null ? void 0 : _a32.flushed, props)) == null ? void 0 : _b22.field) != null ? _c14 : {};
    }
  ),
  filled: defineStyle(
    (props) => {
      var _a32, _b22, _c14;
      return (_c14 = (_b22 = runIfFn2((_a32 = inputTheme.variants) == null ? void 0 : _a32.filled, props)) == null ? void 0 : _b22.field) != null ? _c14 : {};
    }
  ),
  unstyled: (_b4 = (_a23 = inputTheme.variants) == null ? void 0 : _a23.unstyled.field) != null ? _b4 : {}
};
var pinInputTheme = defineStyleConfig({
  baseStyle: baseStyle25,
  sizes: sizes17,
  variants: variants7,
  defaultProps: inputTheme.defaultProps
});

// node_modules/@chakra-ui/theme/dist/chunk-U3INMHUO.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig17, definePartsStyle: definePartsStyle17 } = createMultiStyleConfigHelpers(popoverAnatomy.keys);
var $popperBg = cssVar2("popper-bg");
var $arrowBg2 = cssVar2("popper-arrow-bg");
var $arrowShadowColor = cssVar2("popper-arrow-shadow-color");
var baseStylePopper = defineStyle({ zIndex: 10 });
var baseStyleContent = defineStyle({
  [$popperBg.variable]: `colors.white`,
  bg: $popperBg.reference,
  [$arrowBg2.variable]: $popperBg.reference,
  [$arrowShadowColor.variable]: `colors.gray.200`,
  _dark: {
    [$popperBg.variable]: `colors.gray.700`,
    [$arrowShadowColor.variable]: `colors.whiteAlpha.300`
  },
  width: "xs",
  border: "1px solid",
  borderColor: "inherit",
  borderRadius: "md",
  boxShadow: "sm",
  zIndex: "inherit",
  _focusVisible: {
    outline: 0,
    boxShadow: "outline"
  }
});
var baseStyleHeader2 = defineStyle({
  px: 3,
  py: 2,
  borderBottomWidth: "1px"
});
var baseStyleBody2 = defineStyle({
  px: 3,
  py: 2
});
var baseStyleFooter2 = defineStyle({
  px: 3,
  py: 2,
  borderTopWidth: "1px"
});
var baseStyleCloseButton3 = defineStyle({
  position: "absolute",
  borderRadius: "md",
  top: 1,
  insetEnd: 2,
  padding: 2
});
var baseStyle26 = definePartsStyle17({
  popper: baseStylePopper,
  content: baseStyleContent,
  header: baseStyleHeader2,
  body: baseStyleBody2,
  footer: baseStyleFooter2,
  closeButton: baseStyleCloseButton3
});
var popoverTheme = defineMultiStyleConfig17({
  baseStyle: baseStyle26
});

// node_modules/@chakra-ui/theme/dist/chunk-VWP3ZVQT.mjs
var { definePartsStyle: definePartsStyle18, defineMultiStyleConfig: defineMultiStyleConfig18 } = createMultiStyleConfigHelpers(drawerAnatomy.keys);
var $bg12 = cssVar("drawer-bg");
var $bs = cssVar("drawer-box-shadow");
function getSize3(value) {
  if (value === "full") {
    return definePartsStyle18({
      dialog: { maxW: "100vw", h: "100vh" }
    });
  }
  return definePartsStyle18({
    dialog: { maxW: value }
  });
}
var baseStyleOverlay2 = defineStyle({
  bg: "blackAlpha.600",
  zIndex: "modal"
});
var baseStyleDialogContainer2 = defineStyle({
  display: "flex",
  zIndex: "modal",
  justifyContent: "center"
});
var baseStyleDialog2 = defineStyle((props) => {
  const { isFullHeight } = props;
  return {
    ...isFullHeight && { height: "100vh" },
    zIndex: "modal",
    maxH: "100vh",
    color: "inherit",
    [$bg12.variable]: "colors.white",
    [$bs.variable]: "shadows.lg",
    _dark: {
      [$bg12.variable]: "colors.gray.700",
      [$bs.variable]: "shadows.dark-lg"
    },
    bg: $bg12.reference,
    boxShadow: $bs.reference
  };
});
var baseStyleHeader3 = defineStyle({
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
});
var baseStyleCloseButton4 = defineStyle({
  position: "absolute",
  top: "2",
  insetEnd: "3"
});
var baseStyleBody3 = defineStyle({
  px: "6",
  py: "2",
  flex: "1",
  overflow: "auto"
});
var baseStyleFooter3 = defineStyle({
  px: "6",
  py: "4"
});
var baseStyle27 = definePartsStyle18((props) => ({
  overlay: baseStyleOverlay2,
  dialogContainer: baseStyleDialogContainer2,
  dialog: runIfFn2(baseStyleDialog2, props),
  header: baseStyleHeader3,
  closeButton: baseStyleCloseButton4,
  body: baseStyleBody3,
  footer: baseStyleFooter3
}));
var sizes18 = {
  xs: getSize3("xs"),
  sm: getSize3("md"),
  md: getSize3("lg"),
  lg: getSize3("2xl"),
  xl: getSize3("4xl"),
  full: getSize3("full")
};
var drawerTheme = defineMultiStyleConfig18({
  baseStyle: baseStyle27,
  sizes: sizes18,
  defaultProps: {
    size: "xs"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-D6DZ26HA.mjs
var { definePartsStyle: definePartsStyle19, defineMultiStyleConfig: defineMultiStyleConfig19 } = createMultiStyleConfigHelpers(editableAnatomy.keys);
var baseStylePreview = defineStyle({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal"
});
var baseStyleInput = defineStyle({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
});
var baseStyleTextarea = defineStyle({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
});
var baseStyle28 = definePartsStyle19({
  preview: baseStylePreview,
  input: baseStyleInput,
  textarea: baseStyleTextarea
});
var editableTheme = defineMultiStyleConfig19({
  baseStyle: baseStyle28
});

// node_modules/@chakra-ui/theme/dist/chunk-O6GGGS4Y.mjs
var { definePartsStyle: definePartsStyle20, defineMultiStyleConfig: defineMultiStyleConfig20 } = createMultiStyleConfigHelpers(formAnatomy.keys);
var $fg4 = cssVar("form-control-color");
var baseStyleRequiredIndicator = defineStyle({
  marginStart: "1",
  [$fg4.variable]: "colors.red.500",
  _dark: {
    [$fg4.variable]: "colors.red.300"
  },
  color: $fg4.reference
});
var baseStyleHelperText = defineStyle({
  mt: "2",
  [$fg4.variable]: "colors.gray.600",
  _dark: {
    [$fg4.variable]: "colors.whiteAlpha.600"
  },
  color: $fg4.reference,
  lineHeight: "normal",
  fontSize: "sm"
});
var baseStyle29 = definePartsStyle20({
  container: {
    width: "100%",
    position: "relative"
  },
  requiredIndicator: baseStyleRequiredIndicator,
  helperText: baseStyleHelperText
});
var formTheme = defineMultiStyleConfig20({
  baseStyle: baseStyle29
});

// node_modules/@chakra-ui/theme/dist/chunk-SRBDDT7F.mjs
var { definePartsStyle: definePartsStyle21, defineMultiStyleConfig: defineMultiStyleConfig21 } = createMultiStyleConfigHelpers(formErrorAnatomy.keys);
var $fg5 = cssVar("form-error-color");
var baseStyleText = defineStyle({
  [$fg5.variable]: `colors.red.500`,
  _dark: {
    [$fg5.variable]: `colors.red.300`
  },
  color: $fg5.reference,
  mt: "2",
  fontSize: "sm",
  lineHeight: "normal"
});
var baseStyleIcon6 = defineStyle({
  marginEnd: "0.5em",
  [$fg5.variable]: `colors.red.500`,
  _dark: {
    [$fg5.variable]: `colors.red.300`
  },
  color: $fg5.reference
});
var baseStyle30 = definePartsStyle21({
  text: baseStyleText,
  icon: baseStyleIcon6
});
var formErrorTheme = defineMultiStyleConfig21({
  baseStyle: baseStyle30
});

// node_modules/@chakra-ui/theme/dist/chunk-VHM7WLW6.mjs
var baseStyle31 = defineStyle({
  fontSize: "md",
  marginEnd: "3",
  mb: "2",
  fontWeight: "medium",
  transitionProperty: "common",
  transitionDuration: "normal",
  opacity: 1,
  _disabled: {
    opacity: 0.4
  }
});
var formLabelTheme = defineStyleConfig({
  baseStyle: baseStyle31
});

// node_modules/@chakra-ui/theme/dist/chunk-WXARPSDQ.mjs
var baseStyle32 = defineStyle({
  fontFamily: "heading",
  fontWeight: "bold"
});
var sizes19 = {
  "4xl": defineStyle({
    fontSize: ["6xl", null, "7xl"],
    lineHeight: 1
  }),
  "3xl": defineStyle({
    fontSize: ["5xl", null, "6xl"],
    lineHeight: 1
  }),
  "2xl": defineStyle({
    fontSize: ["4xl", null, "5xl"],
    lineHeight: [1.2, null, 1]
  }),
  xl: defineStyle({
    fontSize: ["3xl", null, "4xl"],
    lineHeight: [1.33, null, 1.2]
  }),
  lg: defineStyle({
    fontSize: ["2xl", null, "3xl"],
    lineHeight: [1.33, null, 1.2]
  }),
  md: defineStyle({
    fontSize: "xl",
    lineHeight: 1.2
  }),
  sm: defineStyle({
    fontSize: "md",
    lineHeight: 1.2
  }),
  xs: defineStyle({
    fontSize: "sm",
    lineHeight: 1.2
  })
};
var headingTheme = defineStyleConfig({
  baseStyle: baseStyle32,
  sizes: sizes19,
  defaultProps: {
    size: "xl"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-FU5DDBRC.mjs
var { defineMultiStyleConfig: defineMultiStyleConfig22, definePartsStyle: definePartsStyle22 } = createMultiStyleConfigHelpers(breadcrumbAnatomy.keys);
var $decor = cssVar("breadcrumb-link-decor");
var baseStyleLink = defineStyle({
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  outline: "none",
  color: "inherit",
  textDecoration: $decor.reference,
  [$decor.variable]: "none",
  "&:not([aria-current=page])": {
    cursor: "pointer",
    _hover: {
      [$decor.variable]: "underline"
    },
    _focusVisible: {
      boxShadow: "outline"
    }
  }
});
var baseStyle33 = definePartsStyle22({
  link: baseStyleLink
});
var breadcrumbTheme = defineMultiStyleConfig22({
  baseStyle: baseStyle33
});

// node_modules/@chakra-ui/theme/dist/chunk-MBVM6PEK.mjs
var baseStyle34 = defineStyle({
  lineHeight: "1.2",
  borderRadius: "md",
  fontWeight: "semibold",
  transitionProperty: "common",
  transitionDuration: "normal",
  _focusVisible: {
    boxShadow: "outline"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    _disabled: {
      bg: "initial"
    }
  }
});
var variantGhost = defineStyle((props) => {
  const { colorScheme: c2, theme: theme3 } = props;
  if (c2 === "gray") {
    return {
      color: mode(`gray.800`, `whiteAlpha.900`)(props),
      _hover: {
        bg: mode(`gray.100`, `whiteAlpha.200`)(props)
      },
      _active: { bg: mode(`gray.200`, `whiteAlpha.300`)(props) }
    };
  }
  const darkHoverBg = transparentize2(`${c2}.200`, 0.12)(theme3);
  const darkActiveBg = transparentize2(`${c2}.200`, 0.24)(theme3);
  return {
    color: mode(`${c2}.600`, `${c2}.200`)(props),
    bg: "transparent",
    _hover: {
      bg: mode(`${c2}.50`, darkHoverBg)(props)
    },
    _active: {
      bg: mode(`${c2}.100`, darkActiveBg)(props)
    }
  };
});
var variantOutline3 = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  const borderColor = mode(`gray.200`, `whiteAlpha.300`)(props);
  return {
    border: "1px solid",
    borderColor: c2 === "gray" ? borderColor : "currentColor",
    ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": { marginEnd: "-1px" },
    ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": { marginBottom: "-1px" },
    ...runIfFn2(variantGhost, props)
  };
});
var accessibleColorMap = {
  yellow: {
    bg: "yellow.400",
    color: "black",
    hoverBg: "yellow.500",
    activeBg: "yellow.600"
  },
  cyan: {
    bg: "cyan.400",
    color: "black",
    hoverBg: "cyan.500",
    activeBg: "cyan.600"
  }
};
var variantSolid2 = defineStyle((props) => {
  var _a7;
  const { colorScheme: c2 } = props;
  if (c2 === "gray") {
    const bg2 = mode(`gray.100`, `whiteAlpha.200`)(props);
    return {
      bg: bg2,
      color: mode(`gray.800`, `whiteAlpha.900`)(props),
      _hover: {
        bg: mode(`gray.200`, `whiteAlpha.300`)(props),
        _disabled: {
          bg: bg2
        }
      },
      _active: { bg: mode(`gray.300`, `whiteAlpha.400`)(props) }
    };
  }
  const {
    bg = `${c2}.500`,
    color: color3 = "white",
    hoverBg = `${c2}.600`,
    activeBg = `${c2}.700`
  } = (_a7 = accessibleColorMap[c2]) != null ? _a7 : {};
  const background2 = mode(bg, `${c2}.200`)(props);
  return {
    bg: background2,
    color: mode(color3, `gray.800`)(props),
    _hover: {
      bg: mode(hoverBg, `${c2}.300`)(props),
      _disabled: {
        bg: background2
      }
    },
    _active: { bg: mode(activeBg, `${c2}.400`)(props) }
  };
});
var variantLink = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    padding: 0,
    height: "auto",
    lineHeight: "normal",
    verticalAlign: "baseline",
    color: mode(`${c2}.500`, `${c2}.200`)(props),
    _hover: {
      textDecoration: "underline",
      _disabled: {
        textDecoration: "none"
      }
    },
    _active: {
      color: mode(`${c2}.700`, `${c2}.500`)(props)
    }
  };
});
var variantUnstyled3 = defineStyle({
  bg: "none",
  color: "inherit",
  display: "inline",
  lineHeight: "inherit",
  m: "0",
  p: "0"
});
var variants8 = {
  ghost: variantGhost,
  outline: variantOutline3,
  solid: variantSolid2,
  link: variantLink,
  unstyled: variantUnstyled3
};
var sizes20 = {
  lg: defineStyle({
    h: "12",
    minW: "12",
    fontSize: "lg",
    px: "6"
  }),
  md: defineStyle({
    h: "10",
    minW: "10",
    fontSize: "md",
    px: "4"
  }),
  sm: defineStyle({
    h: "8",
    minW: "8",
    fontSize: "sm",
    px: "3"
  }),
  xs: defineStyle({
    h: "6",
    minW: "6",
    fontSize: "xs",
    px: "2"
  })
};
var buttonTheme = defineStyleConfig({
  baseStyle: baseStyle34,
  variants: variants8,
  sizes: sizes20,
  defaultProps: {
    variant: "solid",
    size: "md",
    colorScheme: "gray"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-F7CKIHPM.mjs
var { definePartsStyle: definePartsStyle23, defineMultiStyleConfig: defineMultiStyleConfig23 } = createMultiStyleConfigHelpers(cardAnatomy.keys);
var $bg13 = cssVar("card-bg");
var $padding2 = cssVar("card-padding");
var $shadow4 = cssVar("card-shadow");
var $radius = cssVar("card-radius");
var $border3 = cssVar("card-border-width", "0");
var $borderColor = cssVar("card-border-color");
var baseStyle35 = definePartsStyle23({
  container: {
    [$bg13.variable]: "colors.chakra-body-bg",
    backgroundColor: $bg13.reference,
    boxShadow: $shadow4.reference,
    borderRadius: $radius.reference,
    color: "chakra-body-text",
    borderWidth: $border3.reference,
    borderColor: $borderColor.reference
  },
  body: {
    padding: $padding2.reference,
    flex: "1 1 0%"
  },
  header: {
    padding: $padding2.reference
  },
  footer: {
    padding: $padding2.reference
  }
});
var sizes21 = {
  sm: definePartsStyle23({
    container: {
      [$radius.variable]: "radii.base",
      [$padding2.variable]: "space.3"
    }
  }),
  md: definePartsStyle23({
    container: {
      [$radius.variable]: "radii.md",
      [$padding2.variable]: "space.5"
    }
  }),
  lg: definePartsStyle23({
    container: {
      [$radius.variable]: "radii.xl",
      [$padding2.variable]: "space.7"
    }
  })
};
var variants9 = {
  elevated: definePartsStyle23({
    container: {
      [$shadow4.variable]: "shadows.base",
      _dark: {
        [$bg13.variable]: "colors.gray.700"
      }
    }
  }),
  outline: definePartsStyle23({
    container: {
      [$border3.variable]: "1px",
      [$borderColor.variable]: "colors.chakra-border-color"
    }
  }),
  filled: definePartsStyle23({
    container: {
      [$bg13.variable]: "colors.chakra-subtle-bg"
    }
  }),
  unstyled: {
    body: {
      [$padding2.variable]: 0
    },
    header: {
      [$padding2.variable]: 0
    },
    footer: {
      [$padding2.variable]: 0
    }
  }
};
var cardTheme = defineMultiStyleConfig23({
  baseStyle: baseStyle35,
  variants: variants9,
  sizes: sizes21,
  defaultProps: {
    variant: "elevated",
    size: "md"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-OB7MMEC3.mjs
var $size4 = cssVar2("close-button-size");
var $bg14 = cssVar2("close-button-bg");
var baseStyle36 = defineStyle({
  w: [$size4.reference],
  h: [$size4.reference],
  borderRadius: "md",
  transitionProperty: "common",
  transitionDuration: "normal",
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    [$bg14.variable]: "colors.blackAlpha.100",
    _dark: {
      [$bg14.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [$bg14.variable]: "colors.blackAlpha.200",
    _dark: {
      [$bg14.variable]: "colors.whiteAlpha.200"
    }
  },
  _focusVisible: {
    boxShadow: "outline"
  },
  bg: $bg14.reference
});
var sizes22 = {
  lg: defineStyle({
    [$size4.variable]: "sizes.10",
    fontSize: "md"
  }),
  md: defineStyle({
    [$size4.variable]: "sizes.8",
    fontSize: "xs"
  }),
  sm: defineStyle({
    [$size4.variable]: "sizes.6",
    fontSize: "2xs"
  })
};
var closeButtonTheme = defineStyleConfig({
  baseStyle: baseStyle36,
  sizes: sizes22,
  defaultProps: {
    size: "md"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-K3RH7Y2L.mjs
var { variants: variants10, defaultProps } = badgeTheme;
var baseStyle37 = defineStyle({
  fontFamily: "mono",
  fontSize: "sm",
  px: "0.2em",
  borderRadius: "sm",
  bg: vars.bg.reference,
  color: vars.color.reference,
  boxShadow: vars.shadow.reference
});
var codeTheme = defineStyleConfig({
  baseStyle: baseStyle37,
  variants: variants10,
  defaultProps
});

// node_modules/@chakra-ui/theme/dist/chunk-TECE6HDR.mjs
var baseStyle38 = defineStyle({
  w: "100%",
  mx: "auto",
  maxW: "prose",
  px: "4"
});
var containerTheme = defineStyleConfig({
  baseStyle: baseStyle38
});

// node_modules/@chakra-ui/theme/dist/chunk-5S44M2O4.mjs
var baseStyle39 = defineStyle({
  opacity: 0.6,
  borderColor: "inherit"
});
var variantSolid3 = defineStyle({
  borderStyle: "solid"
});
var variantDashed = defineStyle({
  borderStyle: "dashed"
});
var variants11 = {
  solid: variantSolid3,
  dashed: variantDashed
};
var dividerTheme = defineStyleConfig({
  baseStyle: baseStyle39,
  variants: variants11,
  defaultProps: {
    variant: "solid"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-J7AGDWFO.mjs
var { definePartsStyle: definePartsStyle24, defineMultiStyleConfig: defineMultiStyleConfig24 } = createMultiStyleConfigHelpers(accordionAnatomy.keys);
var baseStyleContainer4 = defineStyle({
  borderTopWidth: "1px",
  borderColor: "inherit",
  _last: {
    borderBottomWidth: "1px"
  }
});
var baseStyleButton2 = defineStyle({
  transitionProperty: "common",
  transitionDuration: "normal",
  fontSize: "md",
  _focusVisible: {
    boxShadow: "outline"
  },
  _hover: {
    bg: "blackAlpha.50"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  px: "4",
  py: "2"
});
var baseStylePanel = defineStyle({
  pt: "2",
  px: "4",
  pb: "5"
});
var baseStyleIcon7 = defineStyle({
  fontSize: "1.25em"
});
var baseStyle40 = definePartsStyle24({
  container: baseStyleContainer4,
  button: baseStyleButton2,
  panel: baseStylePanel,
  icon: baseStyleIcon7
});
var accordionTheme = defineMultiStyleConfig24({ baseStyle: baseStyle40 });

// node_modules/@chakra-ui/theme/dist/chunk-BNQWYFTH.mjs
var { definePartsStyle: definePartsStyle25, defineMultiStyleConfig: defineMultiStyleConfig25 } = createMultiStyleConfigHelpers(alertAnatomy.keys);
var $fg6 = cssVar("alert-fg");
var $bg15 = cssVar("alert-bg");
var baseStyle41 = definePartsStyle25({
  container: {
    bg: $bg15.reference,
    px: "4",
    py: "3"
  },
  title: {
    fontWeight: "bold",
    lineHeight: "6",
    marginEnd: "2"
  },
  description: {
    lineHeight: "6"
  },
  icon: {
    color: $fg6.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "6"
  },
  spinner: {
    color: $fg6.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "5"
  }
});
function getBg(props) {
  const { theme: theme3, colorScheme: c2 } = props;
  const darkBg = transparentize2(`${c2}.200`, 0.16)(theme3);
  return {
    light: `colors.${c2}.100`,
    dark: darkBg
  };
}
var variantSubtle2 = definePartsStyle25((props) => {
  const { colorScheme: c2 } = props;
  const bg = getBg(props);
  return {
    container: {
      [$fg6.variable]: `colors.${c2}.600`,
      [$bg15.variable]: bg.light,
      _dark: {
        [$fg6.variable]: `colors.${c2}.200`,
        [$bg15.variable]: bg.dark
      }
    }
  };
});
var variantLeftAccent = definePartsStyle25((props) => {
  const { colorScheme: c2 } = props;
  const bg = getBg(props);
  return {
    container: {
      [$fg6.variable]: `colors.${c2}.600`,
      [$bg15.variable]: bg.light,
      _dark: {
        [$fg6.variable]: `colors.${c2}.200`,
        [$bg15.variable]: bg.dark
      },
      paddingStart: "3",
      borderStartWidth: "4px",
      borderStartColor: $fg6.reference
    }
  };
});
var variantTopAccent = definePartsStyle25((props) => {
  const { colorScheme: c2 } = props;
  const bg = getBg(props);
  return {
    container: {
      [$fg6.variable]: `colors.${c2}.600`,
      [$bg15.variable]: bg.light,
      _dark: {
        [$fg6.variable]: `colors.${c2}.200`,
        [$bg15.variable]: bg.dark
      },
      pt: "2",
      borderTopWidth: "4px",
      borderTopColor: $fg6.reference
    }
  };
});
var variantSolid4 = definePartsStyle25((props) => {
  const { colorScheme: c2 } = props;
  return {
    container: {
      [$fg6.variable]: `colors.white`,
      [$bg15.variable]: `colors.${c2}.600`,
      _dark: {
        [$fg6.variable]: `colors.gray.900`,
        [$bg15.variable]: `colors.${c2}.200`
      },
      color: $fg6.reference
    }
  };
});
var variants12 = {
  subtle: variantSubtle2,
  "left-accent": variantLeftAccent,
  "top-accent": variantTopAccent,
  solid: variantSolid4
};
var alertTheme = defineMultiStyleConfig25({
  baseStyle: baseStyle41,
  variants: variants12,
  defaultProps: {
    variant: "subtle",
    colorScheme: "blue"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-Q5ZQE4MD.mjs
var { definePartsStyle: definePartsStyle26, defineMultiStyleConfig: defineMultiStyleConfig26 } = createMultiStyleConfigHelpers(avatarAnatomy.keys);
var $border4 = cssVar("avatar-border-color");
var $bg16 = cssVar("avatar-bg");
var $fs = cssVar("avatar-font-size");
var $size5 = cssVar("avatar-size");
var baseStyleBadge = defineStyle({
  borderRadius: "full",
  border: "0.2em solid",
  borderColor: $border4.reference,
  [$border4.variable]: "white",
  _dark: {
    [$border4.variable]: "colors.gray.800"
  }
});
var baseStyleExcessLabel = defineStyle({
  bg: $bg16.reference,
  fontSize: $fs.reference,
  width: $size5.reference,
  height: $size5.reference,
  lineHeight: "1",
  [$bg16.variable]: "colors.gray.200",
  _dark: {
    [$bg16.variable]: "colors.whiteAlpha.400"
  }
});
var baseStyleContainer5 = defineStyle((props) => {
  const { name, theme: theme3 } = props;
  const bg = name ? randomColor({ string: name }) : "colors.gray.400";
  const isBgDark = isDark(bg)(theme3);
  let color3 = "white";
  if (!isBgDark)
    color3 = "gray.800";
  return {
    bg: $bg16.reference,
    fontSize: $fs.reference,
    color: color3,
    borderColor: $border4.reference,
    verticalAlign: "top",
    width: $size5.reference,
    height: $size5.reference,
    "&:not([data-loaded])": {
      [$bg16.variable]: bg
    },
    [$border4.variable]: "colors.white",
    _dark: {
      [$border4.variable]: "colors.gray.800"
    }
  };
});
var baseStyleLabel5 = defineStyle({
  fontSize: $fs.reference,
  lineHeight: "1"
});
var baseStyle42 = definePartsStyle26((props) => ({
  badge: runIfFn2(baseStyleBadge, props),
  excessLabel: runIfFn2(baseStyleExcessLabel, props),
  container: runIfFn2(baseStyleContainer5, props),
  label: baseStyleLabel5
}));
function getSize4(size3) {
  const themeSize = size3 !== "100%" ? sizes_default[size3] : void 0;
  return definePartsStyle26({
    container: {
      [$size5.variable]: themeSize != null ? themeSize : size3,
      [$fs.variable]: `calc(${themeSize != null ? themeSize : size3} / 2.5)`
    },
    excessLabel: {
      [$size5.variable]: themeSize != null ? themeSize : size3,
      [$fs.variable]: `calc(${themeSize != null ? themeSize : size3} / 2.5)`
    }
  });
}
var sizes23 = {
  "2xs": getSize4(4),
  xs: getSize4(6),
  sm: getSize4(8),
  md: getSize4(12),
  lg: getSize4(16),
  xl: getSize4(24),
  "2xl": getSize4(32),
  full: getSize4("100%")
};
var avatarTheme = defineMultiStyleConfig26({
  baseStyle: baseStyle42,
  sizes: sizes23,
  defaultProps: {
    size: "md"
  }
});

// node_modules/@chakra-ui/theme/dist/chunk-P7SDT22G.mjs
var components = {
  Accordion: accordionTheme,
  Alert: alertTheme,
  Avatar: avatarTheme,
  Badge: badgeTheme,
  Breadcrumb: breadcrumbTheme,
  Button: buttonTheme,
  Checkbox: checkboxTheme,
  CloseButton: closeButtonTheme,
  Code: codeTheme,
  Container: containerTheme,
  Divider: dividerTheme,
  Drawer: drawerTheme,
  Editable: editableTheme,
  Form: formTheme,
  FormError: formErrorTheme,
  FormLabel: formLabelTheme,
  Heading: headingTheme,
  Input: inputTheme,
  Kbd: kbdTheme,
  Link: linkTheme,
  List: listTheme,
  Menu: menuTheme,
  Modal: modalTheme,
  NumberInput: numberInputTheme,
  PinInput: pinInputTheme,
  Popover: popoverTheme,
  Progress: progressTheme,
  Radio: radioTheme,
  Select: selectTheme,
  Skeleton: skeletonTheme,
  SkipLink: skipLinkTheme,
  Slider: sliderTheme,
  Spinner: spinnerTheme,
  Stat: statTheme,
  Switch: switchTheme,
  Table: tableTheme,
  Tabs: tabsTheme,
  Tag: tagTheme,
  Textarea: textareaTheme,
  Tooltip: tooltipTheme,
  Card: cardTheme,
  Stepper: stepperTheme
};

// node_modules/@chakra-ui/theme/dist/chunk-5GOSZLB7.mjs
var semanticTokens = {
  colors: {
    "chakra-body-text": { _light: "gray.800", _dark: "whiteAlpha.900" },
    "chakra-body-bg": { _light: "white", _dark: "gray.800" },
    "chakra-border-color": { _light: "gray.200", _dark: "whiteAlpha.300" },
    "chakra-inverse-text": { _light: "white", _dark: "gray.800" },
    "chakra-subtle-bg": { _light: "gray.100", _dark: "gray.700" },
    "chakra-subtle-text": { _light: "gray.600", _dark: "gray.400" },
    "chakra-placeholder-color": { _light: "gray.500", _dark: "whiteAlpha.400" }
  }
};

// node_modules/@chakra-ui/theme/dist/chunk-3F7U33P5.mjs
var styles = {
  global: {
    body: {
      fontFamily: "body",
      color: "chakra-body-text",
      bg: "chakra-body-bg",
      transitionProperty: "background-color",
      transitionDuration: "normal",
      lineHeight: "base"
    },
    "*::placeholder": {
      color: "chakra-placeholder-color"
    },
    "*, *::before, &::after": {
      borderColor: "chakra-border-color"
    }
  }
};

// node_modules/@chakra-ui/theme/dist/index.mjs
var direction = "ltr";
var config = {
  useSystemColorMode: false,
  initialColorMode: "light",
  cssVarPrefix: "chakra"
};
var theme = {
  semanticTokens,
  direction,
  ...foundations,
  components,
  styles,
  config
};
var baseTheme = {
  semanticTokens,
  direction,
  components: {},
  ...foundations,
  styles,
  config
};

// node_modules/@chakra-ui/theme-utils/dist/chunk-LIR5QAZY.mjs
var import_lodash5 = __toESM(require_lodash(), 1);
function isFunction3(value) {
  return typeof value === "function";
}
function pipe2(...fns) {
  return (v) => fns.reduce((a2, b2) => b2(a2), v);
}
var createExtendTheme = (theme22) => {
  return function extendTheme2(...extensions) {
    let overrides = [...extensions];
    let activeTheme = extensions[extensions.length - 1];
    if (isChakraTheme(activeTheme) && // this ensures backward compatibility
    // previously only `extendTheme(override, activeTheme?)` was allowed
    overrides.length > 1) {
      overrides = overrides.slice(0, overrides.length - 1);
    } else {
      activeTheme = theme22;
    }
    return pipe2(
      ...overrides.map(
        (extension) => (prevTheme) => isFunction3(extension) ? extension(prevTheme) : mergeThemeOverride(prevTheme, extension)
      )
    )(activeTheme);
  };
};
var extendTheme = createExtendTheme(theme);
var extendBaseTheme = createExtendTheme(baseTheme);
function mergeThemeOverride(...overrides) {
  return (0, import_lodash5.default)({}, ...overrides, mergeThemeCustomizer);
}
function mergeThemeCustomizer(source, override, key, object) {
  if ((isFunction3(source) || isFunction3(override)) && Object.prototype.hasOwnProperty.call(object, key)) {
    return (...args) => {
      const sourceValue = isFunction3(source) ? source(...args) : source;
      const overrideValue = isFunction3(override) ? override(...args) : override;
      return (0, import_lodash5.default)({}, sourceValue, overrideValue, mergeThemeCustomizer);
    };
  }
  return void 0;
}

// node_modules/@chakra-ui/utils/dist/chunk-YTQ3XZ3T.mjs
var import_lodash6 = __toESM(require_lodash(), 1);
function omit2(object, keys2) {
  const result = {};
  Object.keys(object).forEach((key) => {
    if (keys2.includes(key))
      return;
    result[key] = object[key];
  });
  return result;
}
function get2(obj, path, fallback, index3) {
  const key = typeof path === "string" ? path.split(".") : [path];
  for (index3 = 0; index3 < key.length; index3 += 1) {
    if (!obj)
      break;
    obj = obj[key[index3]];
  }
  return obj === void 0 ? fallback : obj;
}
var memoize3 = (fn2) => {
  const cache = /* @__PURE__ */ new WeakMap();
  const memoizedFn = (obj, path, fallback, index3) => {
    if (typeof obj === "undefined") {
      return fn2(obj, path, fallback);
    }
    if (!cache.has(obj)) {
      cache.set(obj, /* @__PURE__ */ new Map());
    }
    const map = cache.get(obj);
    if (map.has(path)) {
      return map.get(path);
    }
    const value = fn2(obj, path, fallback, index3);
    map.set(path, value);
    return value;
  };
  return memoizedFn;
};
var memoizedGet2 = memoize3(get2);
function objectFilter(object, fn2) {
  const result = {};
  Object.keys(object).forEach((key) => {
    const value = object[key];
    const shouldPass = fn2(value, key, object);
    if (shouldPass) {
      result[key] = value;
    }
  });
  return result;
}
var filterUndefined = (object) => objectFilter(object, (val) => val !== null && val !== void 0);

// node_modules/@chakra-ui/utils/dist/chunk-Y5FGD7DM.mjs
function isFunction4(value) {
  return typeof value === "function";
}

// node_modules/@chakra-ui/utils/dist/chunk-M3TFMUOL.mjs
function runIfFn3(valueOrFn, ...args) {
  return isFunction4(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}

// node_modules/@chakra-ui/system/dist/chunk-DMO4EI7P.mjs
var import_react10 = __toESM(require_react(), 1);
var import_react_fast_compare = __toESM(require_react_fast_compare(), 1);
"use client";
function useStyleConfigImpl(themeKey, props = {}) {
  var _a7;
  const { styleConfig: styleConfigProp, ...rest } = props;
  const { theme: theme3, colorMode } = useChakra();
  const themeStyleConfig = themeKey ? memoizedGet2(theme3, `components.${themeKey}`) : void 0;
  const styleConfig = styleConfigProp || themeStyleConfig;
  const mergedProps = (0, import_lodash6.default)(
    { theme: theme3, colorMode },
    (_a7 = styleConfig == null ? void 0 : styleConfig.defaultProps) != null ? _a7 : {},
    filterUndefined(omit2(rest, ["children"]))
  );
  const stylesRef = (0, import_react10.useRef)({});
  if (styleConfig) {
    const getStyles = resolveStyleConfig(styleConfig);
    const styles3 = getStyles(mergedProps);
    const isStyleEqual = (0, import_react_fast_compare.default)(stylesRef.current, styles3);
    if (!isStyleEqual) {
      stylesRef.current = styles3;
    }
  }
  return stylesRef.current;
}
function useStyleConfig(themeKey, props = {}) {
  return useStyleConfigImpl(themeKey, props);
}
function useMultiStyleConfig(themeKey, props = {}) {
  return useStyleConfigImpl(themeKey, props);
}

// node_modules/@chakra-ui/system/dist/chunk-FDQH4LQI.mjs
"use client";
var allPropNames = /* @__PURE__ */ new Set([
  ...propNames,
  "textStyle",
  "layerStyle",
  "apply",
  "noOfLines",
  "focusBorderColor",
  "errorBorderColor",
  "as",
  "__css",
  "css",
  "sx"
]);
var validHTMLProps = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function shouldForwardProp(prop) {
  return validHTMLProps.has(prop) || !allPropNames.has(prop);
}

// node_modules/@chakra-ui/object-utils/dist/chunk-OLTBUDV5.mjs
function assignAfter(target, ...sources) {
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  const result = { ...target };
  for (const nextSource of sources) {
    if (nextSource == null)
      continue;
    for (const nextKey in nextSource) {
      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey))
        continue;
      if (nextKey in result)
        delete result[nextKey];
      result[nextKey] = nextSource[nextKey];
    }
  }
  return result;
}

// node_modules/@chakra-ui/object-utils/dist/chunk-R3DH46PF.mjs
function compact(object) {
  const clone = Object.assign({}, object);
  for (let key in clone) {
    if (clone[key] === void 0)
      delete clone[key];
  }
  return clone;
}

// node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js
var React4 = __toESM(require_react());

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);

// node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var ILLEGAL_ESCAPE_SEQUENCE_ERROR2 = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var Insertion5 = function Insertion6(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var createStyled = function createStyled2(tag, options) {
  if (true) {
    if (tag === void 0) {
      throw new Error("You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.");
    }
  }
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles3 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles3.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles3.push.apply(styles3, args);
    } else {
      if (args[0][0] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR2);
      }
      styles3.push(args[0][0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        if (args[0][i] === void 0) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR2);
        }
        styles3.push(args[i], args[0][i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = React4.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles3.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (
          // $FlowFixMe
          finalShouldForwardProp(_key)
        ) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ React4.createElement(React4.Fragment, null, /* @__PURE__ */ React4.createElement(Insertion5, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ React4.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles3;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && true) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles3);
    };
    return Styled;
  };
};

// node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js
var import_react12 = __toESM(require_react());
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});

// node_modules/@chakra-ui/system/dist/chunk-5PL47M24.mjs
var import_react13 = __toESM(require_react(), 1);
"use client";
var _a6;
var emotion_styled = (_a6 = newStyled.default) != null ? _a6 : newStyled;
var toCSSObject = ({ baseStyle: baseStyle43 }) => (props) => {
  const { theme: theme3, css: cssProp, __css, sx, ...rest } = props;
  const styleProps2 = objectFilter(rest, (_, prop) => isStyleProp(prop));
  const finalBaseStyle = runIfFn3(baseStyle43, props);
  const finalStyles = assignAfter(
    {},
    __css,
    finalBaseStyle,
    filterUndefined(styleProps2),
    sx
  );
  const computedCSS = css3(finalStyles)(props.theme);
  return cssProp ? [computedCSS, cssProp] : computedCSS;
};
function styled(component, options) {
  const { baseStyle: baseStyle43, ...styledOptions } = options != null ? options : {};
  if (!styledOptions.shouldForwardProp) {
    styledOptions.shouldForwardProp = shouldForwardProp;
  }
  const styleObject = toCSSObject({ baseStyle: baseStyle43 });
  const Component2 = emotion_styled(
    component,
    styledOptions
  )(styleObject);
  const chakraComponent = import_react13.default.forwardRef(function ChakraComponent(props, ref) {
    const { colorMode, forced } = useColorMode();
    return import_react13.default.createElement(Component2, {
      ref,
      "data-theme": forced ? colorMode : void 0,
      ...props
    });
  });
  return chakraComponent;
}

// node_modules/@chakra-ui/system/dist/chunk-ZHQNHOQS.mjs
"use client";
function factory() {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(styled, {
    /**
     * @example
     * const Div = chakra("div")
     * const WithChakra = chakra(AnotherComponent)
     */
    apply(target, thisArg, argArray) {
      return styled(...argArray);
    },
    /**
     * @example
     * <chakra.div />
     */
    get(_, element) {
      if (!cache.has(element)) {
        cache.set(element, styled(element));
      }
      return cache.get(element);
    }
  });
}
var chakra = factory();

// node_modules/@chakra-ui/system/dist/chunk-ZJJGQIVY.mjs
var import_react14 = __toESM(require_react(), 1);
"use client";
function forwardRef3(component) {
  return (0, import_react14.forwardRef)(component);
}

// node_modules/@chakra-ui/react-utils/dist/chunk-ITIKTQWJ.mjs
var import_react15 = __toESM(require_react(), 1);
function createContext4(options = {}) {
  const {
    strict = true,
    errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
    name
  } = options;
  const Context = (0, import_react15.createContext)(void 0);
  Context.displayName = name;
  function useContext22() {
    var _a7;
    const context = (0, import_react15.useContext)(Context);
    if (!context && strict) {
      const error2 = new Error(errorMessage);
      error2.name = "ContextError";
      (_a7 = Error.captureStackTrace) == null ? void 0 : _a7.call(Error, error2, useContext22);
      throw error2;
    }
    return context;
  }
  return [
    Context.Provider,
    useContext22,
    Context
  ];
}

// node_modules/@chakra-ui/system/dist/chunk-MFVQSVQB.mjs
var import_react17 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
"use client";
function ThemeProvider3(props) {
  const { cssVarsRoot, theme: theme3, children } = props;
  const computedTheme = (0, import_react17.useMemo)(() => toCSSVar(theme3), [theme3]);
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(ThemeProvider, { theme: computedTheme, children: [
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(CSSVars, { root: cssVarsRoot }),
    children
  ] });
}
function CSSVars({ root = ":host, :root" }) {
  const selector = [root, `[data-theme]`].join(",");
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Global, { styles: (theme3) => ({ [selector]: theme3.__cssVars }) });
}
var [StylesProvider, useStyles] = createContext4({
  name: "StylesContext",
  errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
});
function GlobalStyle() {
  const { colorMode } = useColorMode();
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    Global,
    {
      styles: (theme3) => {
        const styleObjectOrFn = memoizedGet2(theme3, "styles.global");
        const globalStyles = runIfFn3(styleObjectOrFn, { theme: theme3, colorMode });
        if (!globalStyles)
          return void 0;
        const styles3 = css3(globalStyles)(theme3);
        return styles3;
      }
    }
  );
}

// node_modules/@chakra-ui/react-env/dist/chunk-VMD3UMGK.mjs
var import_react19 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
"use client";
var EnvironmentContext = (0, import_react19.createContext)({
  getDocument() {
    return document;
  },
  getWindow() {
    return window;
  }
});
EnvironmentContext.displayName = "EnvironmentContext";
function EnvironmentProvider(props) {
  const { children, environment: environmentProp, disabled } = props;
  const ref = (0, import_react19.useRef)(null);
  const context = (0, import_react19.useMemo)(() => {
    if (environmentProp)
      return environmentProp;
    return {
      getDocument: () => {
        var _a7, _b5;
        return (_b5 = (_a7 = ref.current) == null ? void 0 : _a7.ownerDocument) != null ? _b5 : document;
      },
      getWindow: () => {
        var _a7, _b5;
        return (_b5 = (_a7 = ref.current) == null ? void 0 : _a7.ownerDocument.defaultView) != null ? _b5 : window;
      }
    };
  }, [environmentProp]);
  const showSpan = !disabled || !environmentProp;
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(EnvironmentContext.Provider, { value: context, children: [
    children,
    showSpan && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { id: "__chakra_env", hidden: true, ref })
  ] });
}
EnvironmentProvider.displayName = "EnvironmentProvider";

// node_modules/@chakra-ui/react-env/dist/index.mjs
"use client";

// node_modules/@chakra-ui/provider/dist/chunk-3DDHO3UN.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
"use client";
var ChakraProvider = (props) => {
  const {
    children,
    colorModeManager,
    portalZIndex,
    resetScope,
    resetCSS = true,
    theme: theme3 = {},
    environment,
    cssVarsRoot,
    disableEnvironment,
    disableGlobalStyle
  } = props;
  const _children = /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    EnvironmentProvider,
    {
      environment,
      disabled: disableEnvironment,
      children
    }
  );
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ThemeProvider3, { theme: theme3, cssVarsRoot, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
    ColorModeProvider,
    {
      colorModeManager,
      options: theme3.config,
      children: [
        resetCSS ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CSSReset, { scope: resetScope }) : /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CSSPolyfill, {}),
        !disableGlobalStyle && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(GlobalStyle, {}),
        portalZIndex ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(PortalManager, { zIndex: portalZIndex, children: _children }) : _children
      ]
    }
  ) });
};

// node_modules/@chakra-ui/provider/dist/index.mjs
"use client";

// node_modules/@chakra-ui/toast/dist/chunk-LDADOVIM.mjs
"use client";
var findById = (arr, id2) => arr.find((toast) => toast.id === id2);
function findToast(toasts, id2) {
  const position3 = getToastPosition(toasts, id2);
  const index3 = position3 ? toasts[position3].findIndex((toast) => toast.id === id2) : -1;
  return {
    position: position3,
    index: index3
  };
}
function getToastPosition(toasts, id2) {
  for (const [position3, values] of Object.entries(toasts)) {
    if (findById(values, id2)) {
      return position3;
    }
  }
}
function getToastStyle(position3) {
  const isRighty = position3.includes("right");
  const isLefty = position3.includes("left");
  let alignItems = "center";
  if (isRighty)
    alignItems = "flex-end";
  if (isLefty)
    alignItems = "flex-start";
  return {
    display: "flex",
    flexDirection: "column",
    alignItems
  };
}
function getToastListStyle(position3) {
  const isTopOrBottom = position3 === "top" || position3 === "bottom";
  const margin = isTopOrBottom ? "0 auto" : void 0;
  const top2 = position3.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0;
  const bottom2 = position3.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0;
  const right2 = !position3.includes("left") ? "env(safe-area-inset-right, 0px)" : void 0;
  const left2 = !position3.includes("right") ? "env(safe-area-inset-left, 0px)" : void 0;
  return {
    position: "fixed",
    zIndex: "var(--toast-z-index, 5500)",
    pointerEvents: "none",
    display: "flex",
    flexDirection: "column",
    margin,
    top: top2,
    bottom: bottom2,
    right: right2,
    left: left2
  };
}

// node_modules/@chakra-ui/react-use-timeout/dist/index.mjs
var import_react21 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react-use-callback-ref/dist/index.mjs
var import_react20 = __toESM(require_react(), 1);
"use client";
function useCallbackRef(callback, deps = []) {
  const callbackRef = (0, import_react20.useRef)(callback);
  (0, import_react20.useEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, import_react20.useCallback)((...args) => {
    var _a7;
    return (_a7 = callbackRef.current) == null ? void 0 : _a7.call(callbackRef, ...args);
  }, deps);
}

// node_modules/@chakra-ui/react-use-timeout/dist/index.mjs
"use client";
function useTimeout(callback, delay) {
  const fn2 = useCallbackRef(callback);
  (0, import_react21.useEffect)(() => {
    if (delay == null)
      return void 0;
    let timeoutId2 = null;
    timeoutId2 = window.setTimeout(() => {
      fn2();
    }, delay);
    return () => {
      if (timeoutId2) {
        window.clearTimeout(timeoutId2);
      }
    };
  }, [delay, fn2]);
}

// node_modules/@chakra-ui/react-use-update-effect/dist/index.mjs
var import_react22 = __toESM(require_react(), 1);
"use client";
function useUpdateEffect(callback, deps) {
  const renderCycleRef = (0, import_react22.useRef)(false);
  const effectCycleRef = (0, import_react22.useRef)(false);
  (0, import_react22.useEffect)(() => {
    const mounted = renderCycleRef.current;
    const run = mounted && effectCycleRef.current;
    if (run) {
      return callback();
    }
    effectCycleRef.current = true;
  }, deps);
  (0, import_react22.useEffect)(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
}

// node_modules/framer-motion/dist/es/motion/index.mjs
var React7 = __toESM(require_react(), 1);
var import_react38 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/motion/features/use-features.mjs
var React6 = __toESM(require_react(), 1);
var import_react24 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/process.mjs
var defaultEnvironment = "production";
var env = typeof process === "undefined" || process.env === void 0 ? defaultEnvironment : "development";

// node_modules/framer-motion/dist/es/motion/features/definitions.mjs
var createDefinition = function(propNames2) {
  return {
    isEnabled: function(props) {
      return propNames2.some(function(name) {
        return !!props[name];
      });
    }
  };
};
var featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: createDefinition([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
function loadFeatures(features) {
  for (var key in features) {
    if (features[key] === null)
      continue;
    if (key === "projectionNodeConstructor") {
      featureDefinitions.projectionNodeConstructor = features[key];
    } else {
      featureDefinitions[key].Component = features[key];
    }
  }
}

// node_modules/hey-listen/dist/hey-listen.es.js
var warning = function() {
};
var invariant = function() {
};
if (true) {
  warning = function(check, message) {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant = function(check, message) {
    if (!check) {
      throw new Error(message);
    }
  };
}

// node_modules/framer-motion/dist/es/context/LazyContext.mjs
var import_react23 = __toESM(require_react(), 1);
var LazyContext = (0, import_react23.createContext)({ strict: false });

// node_modules/framer-motion/dist/es/motion/features/use-features.mjs
var featureNames = Object.keys(featureDefinitions);
var numFeatures = featureNames.length;
function useFeatures(props, visualElement2, preloadedFeatures) {
  var features = [];
  var lazyContext = (0, import_react24.useContext)(LazyContext);
  if (!visualElement2)
    return null;
  if (env !== "production" && preloadedFeatures && lazyContext.strict) {
    invariant(false, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");
  }
  for (var i = 0; i < numFeatures; i++) {
    var name_1 = featureNames[i];
    var _a7 = featureDefinitions[name_1], isEnabled = _a7.isEnabled, Component2 = _a7.Component;
    if (isEnabled(props) && Component2) {
      features.push(React6.createElement(Component2, __assign({ key: name_1 }, props, { visualElement: visualElement2 })));
    }
  }
  return features;
}

// node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
var import_react25 = __toESM(require_react(), 1);
var MotionConfigContext = (0, import_react25.createContext)({
  transformPagePoint: function(p) {
    return p;
  },
  isStatic: false,
  reducedMotion: "never"
});

// node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
var import_react26 = __toESM(require_react(), 1);
var MotionContext = (0, import_react26.createContext)({});
function useVisualElementContext() {
  return (0, import_react26.useContext)(MotionContext).visualElement;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
var import_react30 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/PresenceContext.mjs
var import_react27 = __toESM(require_react(), 1);
var PresenceContext = (0, import_react27.createContext)(null);

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var import_react28 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/is-browser.mjs
var isBrowser3 = typeof document !== "undefined";

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var useIsomorphicLayoutEffect = isBrowser3 ? import_react28.useLayoutEffect : import_react28.useEffect;

// node_modules/framer-motion/dist/es/utils/use-reduced-motion.mjs
var import_react29 = __toESM(require_react(), 1);
var prefersReducedMotion = { current: null };
var hasDetected = false;
function initPrefersReducedMotion() {
  hasDetected = true;
  if (!isBrowser3)
    return;
  if (window.matchMedia) {
    var motionMediaQuery_1 = window.matchMedia("(prefers-reduced-motion)");
    var setReducedMotionPreferences = function() {
      return prefersReducedMotion.current = motionMediaQuery_1.matches;
    };
    motionMediaQuery_1.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function useReducedMotion() {
  !hasDetected && initPrefersReducedMotion();
  var _a7 = __read((0, import_react29.useState)(prefersReducedMotion.current), 1), shouldReduceMotion = _a7[0];
  return shouldReduceMotion;
}
function useReducedMotionConfig() {
  var reducedMotionPreference = useReducedMotion();
  var reducedMotion = (0, import_react29.useContext)(MotionConfigContext).reducedMotion;
  if (reducedMotion === "never") {
    return false;
  } else if (reducedMotion === "always") {
    return true;
  } else {
    return reducedMotionPreference;
  }
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
function useVisualElement(Component2, visualState, props, createVisualElement) {
  var lazyContext = (0, import_react30.useContext)(LazyContext);
  var parent = useVisualElementContext();
  var presenceContext = (0, import_react30.useContext)(PresenceContext);
  var shouldReduceMotion = useReducedMotionConfig();
  var visualElementRef = (0, import_react30.useRef)(void 0);
  if (!createVisualElement)
    createVisualElement = lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component2, {
      visualState,
      parent,
      props,
      presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,
      blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,
      shouldReduceMotion
    });
  }
  var visualElement2 = visualElementRef.current;
  useIsomorphicLayoutEffect(function() {
    visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
  });
  (0, import_react30.useEffect)(function() {
    var _a7;
    (_a7 = visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.animationState) === null || _a7 === void 0 ? void 0 : _a7.animateChanges();
  });
  useIsomorphicLayoutEffect(function() {
    return function() {
      return visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.notifyUnmount();
    };
  }, []);
  return visualElement2;
}

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
var import_react31 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
function useMotionRef(visualState, visualElement2, externalRef) {
  return (0, import_react31.useCallback)(
    function(instance) {
      var _a7;
      instance && ((_a7 = visualState.mount) === null || _a7 === void 0 ? void 0 : _a7.call(visualState, instance));
      if (visualElement2) {
        instance ? visualElement2.mount(instance) : visualElement2.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement2]
  );
}

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
var import_react32 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/utils/variants.mjs
function isVariantLabels(v) {
  return Array.isArray(v);
}
function isVariantLabel(v) {
  return typeof v === "string" || isVariantLabels(v);
}
function getCurrent(visualElement2) {
  var current = {};
  visualElement2.forEachValue(function(value, key) {
    return current[key] = value.get();
  });
  return current;
}
function getVelocity(visualElement2) {
  var velocity = {};
  visualElement2.forEachValue(function(value, key) {
    return velocity[key] = value.getVelocity();
  });
  return velocity;
}
function resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {
  var _a7;
  if (currentValues === void 0) {
    currentValues = {};
  }
  if (currentVelocity === void 0) {
    currentVelocity = {};
  }
  if (typeof definition === "function") {
    definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = (_a7 = props.variants) === null || _a7 === void 0 ? void 0 : _a7[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
function resolveVariant(visualElement2, definition, custom) {
  var props = visualElement2.getProps();
  return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement2), getVelocity(visualElement2));
}
function checkIfControllingVariants(props) {
  var _a7;
  return typeof ((_a7 = props.animate) === null || _a7 === void 0 ? void 0 : _a7.start) === "function" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);
}
function checkIfVariantNode(props) {
  return Boolean(checkIfControllingVariants(props) || props.variants);
}

// node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
function getCurrentTreeVariants(props, context) {
  if (checkIfControllingVariants(props)) {
    var initial = props.initial, animate3 = props.animate;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate3) ? animate3 : void 0
    };
  }
  return props.inherit !== false ? context : {};
}

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
function useCreateMotionContext(props) {
  var _a7 = getCurrentTreeVariants(props, (0, import_react32.useContext)(MotionContext)), initial = _a7.initial, animate3 = _a7.animate;
  return (0, import_react32.useMemo)(function() {
    return { initial, animate: animate3 };
  }, [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate3)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}

// node_modules/framer-motion/dist/es/utils/use-constant.mjs
var import_react33 = __toESM(require_react(), 1);
function useConstant(init) {
  var ref = (0, import_react33.useRef)(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}

// node_modules/framer-motion/dist/es/projection/node/state.mjs
var globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};

// node_modules/framer-motion/dist/es/projection/node/id.mjs
var id = 1;
function useProjectionId() {
  return useConstant(function() {
    if (globalProjectionState.hasEverUpdated) {
      return id++;
    }
  });
}

// node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
var import_react34 = __toESM(require_react(), 1);
var LayoutGroupContext = (0, import_react34.createContext)({});

// node_modules/framer-motion/dist/es/motion/features/use-projection.mjs
var import_react36 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
var import_react35 = __toESM(require_react(), 1);
var SwitchLayoutGroupContext = (0, import_react35.createContext)({});

// node_modules/framer-motion/dist/es/motion/features/use-projection.mjs
function useProjection(projectionId, _a7, visualElement2, ProjectionNodeConstructor) {
  var _b5;
  var layoutId = _a7.layoutId, layout2 = _a7.layout, drag2 = _a7.drag, dragConstraints = _a7.dragConstraints, layoutScroll = _a7.layoutScroll;
  var initialPromotionConfig = (0, import_react36.useContext)(SwitchLayoutGroupContext);
  if (!ProjectionNodeConstructor || !visualElement2 || (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.projection)) {
    return;
  }
  visualElement2.projection = new ProjectionNodeConstructor(projectionId, visualElement2.getLatestValues(), (_b5 = visualElement2.parent) === null || _b5 === void 0 ? void 0 : _b5.projection);
  visualElement2.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement: visualElement2,
    scheduleRender: function() {
      return visualElement2.scheduleRender();
    },
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    layoutScroll
  });
}

// node_modules/framer-motion/dist/es/motion/utils/VisualElementHandler.mjs
var import_react37 = __toESM(require_react(), 1);
var VisualElementHandler = (
  /** @class */
  function(_super) {
    __extends(VisualElementHandler2, _super);
    function VisualElementHandler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VisualElementHandler2.prototype.getSnapshotBeforeUpdate = function() {
      this.updateProps();
      return null;
    };
    VisualElementHandler2.prototype.componentDidUpdate = function() {
    };
    VisualElementHandler2.prototype.updateProps = function() {
      var _a7 = this.props, visualElement2 = _a7.visualElement, props = _a7.props;
      if (visualElement2)
        visualElement2.setProps(props);
    };
    VisualElementHandler2.prototype.render = function() {
      return this.props.children;
    };
    return VisualElementHandler2;
  }(import_react37.default.Component)
);

// node_modules/framer-motion/dist/es/motion/index.mjs
function createMotionComponent(_a7) {
  var preloadedFeatures = _a7.preloadedFeatures, createVisualElement = _a7.createVisualElement, projectionNodeConstructor = _a7.projectionNodeConstructor, useRender = _a7.useRender, useVisualState = _a7.useVisualState, Component2 = _a7.Component;
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    var layoutId = useLayoutId(props);
    props = __assign(__assign({}, props), { layoutId });
    var config2 = (0, import_react38.useContext)(MotionConfigContext);
    var features = null;
    var context = useCreateMotionContext(props);
    var projectionId = config2.isStatic ? void 0 : useProjectionId();
    var visualState = useVisualState(props, config2.isStatic);
    if (!config2.isStatic && isBrowser3) {
      context.visualElement = useVisualElement(Component2, visualState, __assign(__assign({}, config2), props), createVisualElement);
      useProjection(projectionId, props, context.visualElement, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor);
      features = useFeatures(props, context.visualElement, preloadedFeatures);
    }
    return React7.createElement(
      VisualElementHandler,
      { visualElement: context.visualElement, props: __assign(__assign({}, config2), props) },
      features,
      React7.createElement(MotionContext.Provider, { value: context }, useRender(Component2, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config2.isStatic, context.visualElement))
    );
  }
  return (0, import_react38.forwardRef)(MotionComponent);
}
function useLayoutId(_a7) {
  var _b5;
  var layoutId = _a7.layoutId;
  var layoutGroupId = (_b5 = (0, import_react38.useContext)(LayoutGroupContext)) === null || _b5 === void 0 ? void 0 : _b5.id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}

// node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs
function createMotionProxy(createConfig) {
  function custom(Component2, customMotionComponentConfig) {
    if (customMotionComponentConfig === void 0) {
      customMotionComponentConfig = {};
    }
    return createMotionComponent(createConfig(Component2, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom;
  }
  var componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: function(_target, key) {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom(key));
      }
      return componentCache.get(key);
    }
  });
}

// node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "tspan",
  "use",
  "view"
];

// node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
function isSVGComponent(Component2) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component2 !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component2.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component2) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component2)
  ) {
    return true;
  }
  return false;
}

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
var import_react41 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/html/use-props.mjs
var import_react39 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
var scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}

// node_modules/framer-motion/dist/es/render/html/utils/transform.mjs
var transformAxes = ["", "X", "Y", "Z"];
var order = ["translate", "scale", "rotate", "skew"];
var transformProps = ["transformPerspective", "x", "y", "z"];
order.forEach(function(operationKey) {
  return transformAxes.forEach(function(axesKey) {
    return transformProps.push(operationKey + axesKey);
  });
});
function sortTransformProps(a2, b2) {
  return transformProps.indexOf(a2) - transformProps.indexOf(b2);
}
var transformPropSet = new Set(transformProps);
function isTransformProp(key) {
  return transformPropSet.has(key);
}
var transformOriginProps = /* @__PURE__ */ new Set(["originX", "originY", "originZ"]);
function isTransformOriginProp(key) {
  return transformOriginProps.has(key);
}

// node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
function isForcedMotionValue(key, _a7) {
  var layout2 = _a7.layout, layoutId = _a7.layoutId;
  return isTransformProp(key) || isTransformOriginProp(key) || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}

// node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs
var isMotionValue = function(value) {
  return Boolean(value !== null && typeof value === "object" && value.getVelocity);
};

// node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
function buildTransform(_a7, _b5, transformIsDefault, transformTemplate2) {
  var transform2 = _a7.transform, transformKeys2 = _a7.transformKeys;
  var _c14 = _b5.enableHardwareAcceleration, enableHardwareAcceleration = _c14 === void 0 ? true : _c14, _d3 = _b5.allowTransformNone, allowTransformNone = _d3 === void 0 ? true : _d3;
  var transformString = "";
  transformKeys2.sort(sortTransformProps);
  var transformHasZ = false;
  var numTransformKeys = transformKeys2.length;
  for (var i = 0; i < numTransformKeys; i++) {
    var key = transformKeys2[i];
    transformString += "".concat(translateAlias[key] || key, "(").concat(transform2[key], ") ");
    if (key === "z")
      transformHasZ = true;
  }
  if (!transformHasZ && enableHardwareAcceleration) {
    transformString += "translateZ(0)";
  } else {
    transformString = transformString.trim();
  }
  if (transformTemplate2) {
    transformString = transformTemplate2(transform2, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildTransformOrigin(_a7) {
  var _b5 = _a7.originX, originX = _b5 === void 0 ? "50%" : _b5, _c14 = _a7.originY, originY = _c14 === void 0 ? "50%" : _c14, _d3 = _a7.originZ, originZ = _d3 === void 0 ? 0 : _d3;
  return "".concat(originX, " ").concat(originY, " ").concat(originZ);
}

// node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs
function isCSSVariable(key) {
  return key.startsWith("--");
}

// node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs
var getValueAsType = function(value, type) {
  return type && typeof value === "number" ? type.transform(value) : value;
};

// node_modules/style-value-types/dist/es/utils.mjs
var clamp = (min2, max2) => (v) => Math.max(Math.min(v, max2), min2);
var sanitize = (v) => v % 1 ? Number(v.toFixed(5)) : v;
var floatRegex = /(-)?([\d]*\.?[\d])+/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
function isString(v) {
  return typeof v === "string";
}

// node_modules/style-value-types/dist/es/numbers/index.mjs
var number = {
  test: (v) => typeof v === "number",
  parse: parseFloat,
  transform: (v) => v
};
var alpha = Object.assign(Object.assign({}, number), { transform: clamp(0, 1) });
var scale = Object.assign(Object.assign({}, number), { default: 1 });

// node_modules/style-value-types/dist/es/numbers/units.mjs
var createUnitType = (unit) => ({
  test: (v) => isString(v) && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`
});
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px2 = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v) => percent.parse(v) / 100, transform: (v) => percent.transform(v * 100) });

// node_modules/style-value-types/dist/es/color/utils.mjs
var isColorString = (type, testProp) => (v) => {
  return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));
};
var splitColor = (aName, bName, cName) => (v) => {
  if (!isString(v))
    return v;
  const [a2, b2, c2, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};

// node_modules/style-value-types/dist/es/color/hsla.mjs
var hsla2 = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};

// node_modules/style-value-types/dist/es/color/rgba.mjs
var clampRgbUnit = clamp(0, 255);
var rgbUnit = Object.assign(Object.assign({}, number), { transform: (v) => Math.round(clampRgbUnit(v)) });
var rgba2 = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};

// node_modules/style-value-types/dist/es/color/hex.mjs
function parseHex(v) {
  let r2 = "";
  let g = "";
  let b2 = "";
  let a2 = "";
  if (v.length > 5) {
    r2 = v.substr(1, 2);
    g = v.substr(3, 2);
    b2 = v.substr(5, 2);
    a2 = v.substr(7, 2);
  } else {
    r2 = v.substr(1, 1);
    g = v.substr(2, 1);
    b2 = v.substr(3, 1);
    a2 = v.substr(4, 1);
    r2 += r2;
    g += g;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
var hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba2.transform
};

// node_modules/style-value-types/dist/es/color/index.mjs
var color2 = {
  test: (v) => rgba2.test(v) || hex.test(v) || hsla2.test(v),
  parse: (v) => {
    if (rgba2.test(v)) {
      return rgba2.parse(v);
    } else if (hsla2.test(v)) {
      return hsla2.parse(v);
    } else {
      return hex.parse(v);
    }
  },
  transform: (v) => {
    return isString(v) ? v : v.hasOwnProperty("red") ? rgba2.transform(v) : hsla2.transform(v);
  }
};

// node_modules/style-value-types/dist/es/complex/index.mjs
var colorToken = "${c}";
var numberToken = "${n}";
function test(v) {
  var _a7, _b5, _c14, _d3;
  return isNaN(v) && isString(v) && ((_b5 = (_a7 = v.match(floatRegex)) === null || _a7 === void 0 ? void 0 : _a7.length) !== null && _b5 !== void 0 ? _b5 : 0) + ((_d3 = (_c14 = v.match(colorRegex)) === null || _c14 === void 0 ? void 0 : _c14.length) !== null && _d3 !== void 0 ? _d3 : 0) > 0;
}
function analyse(v) {
  if (typeof v === "number")
    v = `${v}`;
  const values = [];
  let numColors = 0;
  const colors2 = v.match(colorRegex);
  if (colors2) {
    numColors = colors2.length;
    v = v.replace(colorRegex, colorToken);
    values.push(...colors2.map(color2.parse));
  }
  const numbers = v.match(floatRegex);
  if (numbers) {
    v = v.replace(floatRegex, numberToken);
    values.push(...numbers.map(number.parse));
  }
  return { values, numColors, tokenised: v };
}
function parse2(v) {
  return analyse(v).values;
}
function createTransformer(v) {
  const { values, numColors, tokenised } = analyse(v);
  const numValues = values.length;
  return (v2) => {
    let output = tokenised;
    for (let i = 0; i < numValues; i++) {
      output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color2.transform(v2[i]) : sanitize(v2[i]));
    }
    return output;
  };
}
var convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;
function getAnimatableNone(v) {
  const parsed = parse2(v);
  const transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
var complex = { test, parse: parse2, createTransformer, getAnimatableNone };

// node_modules/style-value-types/dist/es/complex/filter.mjs
var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  let [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
var functionRegex = /([a-z-]*)\(.*?\)/g;
var filter2 = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v) => {
  const functions = v.match(functionRegex);
  return functions ? functions.map(applyDefaultFilter).join(" ") : v;
} });

// node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs
var int = __assign(__assign({}, number), { transform: Math.round });

// node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs
var numberValueTypes = {
  // Border props
  borderWidth: px2,
  borderTopWidth: px2,
  borderRightWidth: px2,
  borderBottomWidth: px2,
  borderLeftWidth: px2,
  borderRadius: px2,
  radius: px2,
  borderTopLeftRadius: px2,
  borderTopRightRadius: px2,
  borderBottomRightRadius: px2,
  borderBottomLeftRadius: px2,
  // Positioning props
  width: px2,
  maxWidth: px2,
  height: px2,
  maxHeight: px2,
  size: px2,
  top: px2,
  right: px2,
  bottom: px2,
  left: px2,
  // Spacing props
  padding: px2,
  paddingTop: px2,
  paddingRight: px2,
  paddingBottom: px2,
  paddingLeft: px2,
  margin: px2,
  marginTop: px2,
  marginRight: px2,
  marginBottom: px2,
  marginLeft: px2,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px2,
  translateX: px2,
  translateY: px2,
  translateZ: px2,
  x: px2,
  y: px2,
  z: px2,
  perspective: px2,
  transformPerspective: px2,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px2,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

// node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
function buildHTMLStyles(state2, latestValues, options, transformTemplate2) {
  var _a7;
  var style = state2.style, vars2 = state2.vars, transform2 = state2.transform, transformKeys2 = state2.transformKeys, transformOrigin2 = state2.transformOrigin;
  transformKeys2.length = 0;
  var hasTransform2 = false;
  var hasTransformOrigin = false;
  var transformIsNone = true;
  for (var key in latestValues) {
    var value = latestValues[key];
    if (isCSSVariable(key)) {
      vars2[key] = value;
      continue;
    }
    var valueType = numberValueTypes[key];
    var valueAsType = getValueAsType(value, valueType);
    if (isTransformProp(key)) {
      hasTransform2 = true;
      transform2[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      if (value !== ((_a7 = valueType.default) !== null && _a7 !== void 0 ? _a7 : 0))
        transformIsNone = false;
    } else if (isTransformOriginProp(key)) {
      transformOrigin2[key] = valueAsType;
      hasTransformOrigin = true;
    } else {
      style[key] = valueAsType;
    }
  }
  if (hasTransform2) {
    style.transform = buildTransform(state2, options, transformIsNone, transformTemplate2);
  } else if (transformTemplate2) {
    style.transform = transformTemplate2({}, "");
  } else if (!latestValues.transform && style.transform) {
    style.transform = "none";
  }
  if (hasTransformOrigin) {
    style.transformOrigin = buildTransformOrigin(transformOrigin2);
  }
}

// node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
var createHtmlRenderState = function() {
  return {
    style: {},
    transform: {},
    transformKeys: [],
    transformOrigin: {},
    vars: {}
  };
};

// node_modules/framer-motion/dist/es/render/html/use-props.mjs
function copyRawValuesOnly(target, source, props) {
  for (var key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues(_a7, visualState, isStatic) {
  var transformTemplate2 = _a7.transformTemplate;
  return (0, import_react39.useMemo)(function() {
    var state2 = createHtmlRenderState();
    buildHTMLStyles(state2, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate2);
    var vars2 = state2.vars, style = state2.style;
    return __assign(__assign({}, vars2), style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  var styleProp = props.style || {};
  var style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  if (props.transformValues) {
    style = props.transformValues(style);
  }
  return style;
}
function useHTMLProps(props, visualState, isStatic) {
  var htmlProps = {};
  var style = useStyle(props, visualState, isStatic);
  if (Boolean(props.drag) && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : "pan-".concat(props.drag === "x" ? "y" : "x");
  }
  htmlProps.style = style;
  return htmlProps;
}

// node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
var validMotionProps = /* @__PURE__ */ new Set([
  "initial",
  "animate",
  "exit",
  "style",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "layout",
  "layoutId",
  "layoutDependency",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "drag",
  "dragControls",
  "dragListener",
  "dragConstraints",
  "dragDirectionLock",
  "dragSnapToOrigin",
  "_dragX",
  "_dragY",
  "dragElastic",
  "dragMomentum",
  "dragPropagation",
  "dragTransition",
  "whileDrag",
  "onPan",
  "onPanStart",
  "onPanEnd",
  "onPanSessionStart",
  "onTap",
  "onTapStart",
  "onTapCancel",
  "onHoverStart",
  "onHoverEnd",
  "whileFocus",
  "whileTap",
  "whileHover",
  "whileInView",
  "onViewportEnter",
  "onViewportLeave",
  "viewport",
  "layoutScroll"
]);
function isValidMotionProp(key) {
  return validMotionProps.has(key);
}

// node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
var shouldForward = function(key) {
  return !isValidMotionProp(key);
};
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = function(key) {
    return key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  };
}
try {
  loadExternalIsValidProp((init_is_prop_valid_browser_esm(), __toCommonJS(is_prop_valid_browser_esm_exports)).default);
} catch (_a7) {
}
function filterProps(props, isDom2, forwardMotionProps) {
  var filteredProps = {};
  for (var key in props) {
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom2 && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}

// node_modules/framer-motion/dist/es/render/svg/use-props.mjs
var import_react40 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs
function calcOrigin(origin, offset3, size3) {
  return typeof origin === "string" ? origin : px2.transform(offset3 + size3 * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return "".concat(pxOriginX, " ").concat(pxOriginY);
}

// node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing2, offset3, useDashCase) {
  if (spacing2 === void 0) {
    spacing2 = 1;
  }
  if (offset3 === void 0) {
    offset3 = 0;
  }
  if (useDashCase === void 0) {
    useDashCase = true;
  }
  attrs.pathLength = 1;
  var keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px2.transform(-offset3);
  var pathLength = px2.transform(length2);
  var pathSpacing = px2.transform(spacing2);
  attrs[keys2.array] = "".concat(pathLength, " ").concat(pathSpacing);
}

// node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
function buildSVGAttrs(state2, _a7, options, transformTemplate2) {
  var attrX = _a7.attrX, attrY = _a7.attrY, originX = _a7.originX, originY = _a7.originY, pathLength = _a7.pathLength, _b5 = _a7.pathSpacing, pathSpacing = _b5 === void 0 ? 1 : _b5, _c14 = _a7.pathOffset, pathOffset = _c14 === void 0 ? 0 : _c14, latest = __rest(_a7, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
  buildHTMLStyles(state2, latest, options, transformTemplate2);
  state2.attrs = state2.style;
  state2.style = {};
  var attrs = state2.attrs, style = state2.style, dimensions = state2.dimensions;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}

// node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
var createSvgRenderState = function() {
  return __assign(__assign({}, createHtmlRenderState()), { attrs: {} });
};

// node_modules/framer-motion/dist/es/render/svg/use-props.mjs
function useSVGProps(props, visualState) {
  var visualProps = (0, import_react40.useMemo)(function() {
    var state2 = createSvgRenderState();
    buildSVGAttrs(state2, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);
    return __assign(__assign({}, state2.attrs), { style: __assign({}, state2.style) });
  }, [visualState]);
  if (props.style) {
    var rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = __assign(__assign({}, rawStyles), visualProps.style);
  }
  return visualProps;
}

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
function createUseRender(forwardMotionProps) {
  if (forwardMotionProps === void 0) {
    forwardMotionProps = false;
  }
  var useRender = function(Component2, props, projectionId, ref, _a7, isStatic) {
    var latestValues = _a7.latestValues;
    var useVisualProps = isSVGComponent(Component2) ? useSVGProps : useHTMLProps;
    var visualProps = useVisualProps(props, latestValues, isStatic);
    var filteredProps = filterProps(props, typeof Component2 === "string", forwardMotionProps);
    var elementProps = __assign(__assign(__assign({}, filteredProps), visualProps), { ref });
    if (projectionId) {
      elementProps["data-projection-id"] = projectionId;
    }
    return (0, import_react41.createElement)(Component2, elementProps);
  };
  return useRender;
}

// node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = "$1-$2";
var camelToDash = function(str) {
  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};

// node_modules/framer-motion/dist/es/render/html/utils/render.mjs
function renderHTML(element, _a7, styleProp, projection) {
  var style = _a7.style, vars2 = _a7.vars;
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (var key in vars2) {
    element.style.setProperty(key, vars2[key]);
  }
}

// node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength"
]);

// node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (var key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}

// node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps(props) {
  var style = props.style;
  var newValues = {};
  for (var key in style) {
    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}

// node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps2(props) {
  var newValues = scrapeMotionValuesFromProps(props);
  for (var key in props) {
    if (isMotionValue(props[key])) {
      var targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
var import_react42 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
function isAnimationControls(v) {
  return typeof v === "object" && typeof v.start === "function";
}

// node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
var isKeyframesTarget = function(v) {
  return Array.isArray(v);
};

// node_modules/framer-motion/dist/es/utils/resolve-value.mjs
var isCustomValue = function(v) {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
var resolveFinalValueInKeyframes = function(v) {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};

// node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
function resolveMotionValue(value) {
  var unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
function makeState(_a7, props, context, presenceContext) {
  var scrapeMotionValuesFromProps3 = _a7.scrapeMotionValuesFromProps, createRenderState = _a7.createRenderState, onMount = _a7.onMount;
  var state2 = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onMount) {
    state2.mount = function(instance) {
      return onMount(props, instance, state2);
    };
  }
  return state2;
}
var makeUseVisualState = function(config2) {
  return function(props, isStatic) {
    var context = (0, import_react42.useContext)(MotionContext);
    var presenceContext = (0, import_react42.useContext)(PresenceContext);
    return isStatic ? makeState(config2, props, context, presenceContext) : useConstant(function() {
      return makeState(config2, props, context, presenceContext);
    });
  };
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  var values = {};
  var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;
  var motionValues = scrapeMotionValues(props);
  for (var key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  var initial = props.initial, animate3 = props.animate;
  var isControllingVariants = checkIfControllingVariants(props);
  var isVariantNode = checkIfVariantNode(props);
  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {
    initial !== null && initial !== void 0 ? initial : initial = context.initial;
    animate3 !== null && animate3 !== void 0 ? animate3 : animate3 = context.animate;
  }
  var initialAnimationIsBlocked = blockInitialAnimation || initial === false;
  var variantToSet = initialAnimationIsBlocked ? animate3 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    var list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list2.forEach(function(definition) {
      var resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      var transitionEnd = resolved.transitionEnd;
      resolved.transition;
      var target = __rest(resolved, ["transitionEnd", "transition"]);
      for (var key2 in target) {
        var valueTarget = target[key2];
        if (Array.isArray(valueTarget)) {
          var index3 = initialAnimationIsBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index3];
        }
        if (valueTarget !== null) {
          values[key2] = valueTarget;
        }
      }
      for (var key2 in transitionEnd)
        values[key2] = transitionEnd[key2];
    });
  }
  return values;
}

// node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState,
    onMount: function(props, instance, _a7) {
      var renderState = _a7.renderState, latestValues = _a7.latestValues;
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);
      renderSVG(instance, renderState);
    }
  })
};

// node_modules/framer-motion/dist/es/render/html/config-motion.mjs
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  })
};

// node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs
function createDomMotionConfig(Component2, _a7, preloadedFeatures, createVisualElement, projectionNodeConstructor) {
  var _b5 = _a7.forwardMotionProps, forwardMotionProps = _b5 === void 0 ? false : _b5;
  var baseConfig = isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig;
  return __assign(__assign({}, baseConfig), { preloadedFeatures, useRender: createUseRender(forwardMotionProps), createVisualElement, projectionNodeConstructor, Component: Component2 });
}

// node_modules/framer-motion/dist/es/render/utils/types.mjs
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["InView"] = "whileInView";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));

// node_modules/framer-motion/dist/es/events/use-dom-event.mjs
var import_react43 = __toESM(require_react(), 1);
function addDomEvent(target, eventName, handler, options) {
  if (options === void 0) {
    options = { passive: true };
  }
  target.addEventListener(eventName, handler, options);
  return function() {
    return target.removeEventListener(eventName, handler);
  };
}
function useDomEvent(ref, eventName, handler, options) {
  (0, import_react43.useEffect)(function() {
    var element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}

// node_modules/framer-motion/dist/es/gestures/use-focus-gesture.mjs
function useFocusGesture(_a7) {
  var whileFocus = _a7.whileFocus, visualElement2 = _a7.visualElement;
  var onFocus = function() {
    var _a8;
    (_a8 = visualElement2.animationState) === null || _a8 === void 0 ? void 0 : _a8.setActive(AnimationType.Focus, true);
  };
  var onBlur = function() {
    var _a8;
    (_a8 = visualElement2.animationState) === null || _a8 === void 0 ? void 0 : _a8.setActive(AnimationType.Focus, false);
  };
  useDomEvent(visualElement2, "focus", whileFocus ? onFocus : void 0);
  useDomEvent(visualElement2, "blur", whileFocus ? onBlur : void 0);
}

// node_modules/framer-motion/dist/es/gestures/utils/event-type.mjs
function isMouseEvent(event) {
  if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof MouseEvent;
}
function isTouchEvent(event) {
  var hasTouches = !!event.touches;
  return hasTouches;
}

// node_modules/framer-motion/dist/es/events/event-info.mjs
function filterPrimaryPointer(eventHandler) {
  return function(event) {
    var isMouseEvent2 = event instanceof MouseEvent;
    var isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
var defaultPagePoint = { pageX: 0, pageY: 0 };
function pointFromTouch(e, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  var primaryTouch = e.touches[0] || e.changedTouches[0];
  var point = primaryTouch || defaultPagePoint;
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function pointFromMouse(point, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function extractEventInfo(event, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
var wrapHandler = function(handler, shouldFilterPrimaryPointer) {
  if (shouldFilterPrimaryPointer === void 0) {
    shouldFilterPrimaryPointer = false;
  }
  var listener = function(event) {
    return handler(event, extractEventInfo(event));
  };
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
};

// node_modules/framer-motion/dist/es/events/utils.mjs
var supportsPointerEvents = function() {
  return isBrowser3 && window.onpointerdown === null;
};
var supportsTouchEvents = function() {
  return isBrowser3 && window.ontouchstart === null;
};
var supportsMouseEvents = function() {
  return isBrowser3 && window.onmousedown === null;
};

// node_modules/framer-motion/dist/es/events/use-pointer-event.mjs
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name) {
  if (supportsPointerEvents()) {
    return name;
  } else if (supportsTouchEvents()) {
    return touchEventNames[name];
  } else if (supportsMouseEvents()) {
    return mouseEventNames[name];
  }
  return name;
}
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options);
}
function usePointerEvent(ref, eventName, handler, options) {
  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === "pointerdown"), options);
}

// node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs
function createLock(name) {
  var lock = null;
  return function() {
    var openLock = function() {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  var lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    var openHorizontal_1 = globalHorizontalLock();
    var openVertical_1 = globalVerticalLock();
    if (openHorizontal_1 && openVertical_1) {
      lock = function() {
        openHorizontal_1();
        openVertical_1();
      };
    } else {
      if (openHorizontal_1)
        openHorizontal_1();
      if (openVertical_1)
        openVertical_1();
    }
  }
  return lock;
}
function isDragActive() {
  var openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}

// node_modules/framer-motion/dist/es/gestures/use-hover-gesture.mjs
function createHoverEvent(visualElement2, isActive, callback) {
  return function(event, info) {
    var _a7;
    if (!isMouseEvent(event) || isDragActive())
      return;
    (_a7 = visualElement2.animationState) === null || _a7 === void 0 ? void 0 : _a7.setActive(AnimationType.Hover, isActive);
    callback === null || callback === void 0 ? void 0 : callback(event, info);
  };
}
function useHoverGesture(_a7) {
  var onHoverStart = _a7.onHoverStart, onHoverEnd = _a7.onHoverEnd, whileHover = _a7.whileHover, visualElement2 = _a7.visualElement;
  usePointerEvent(visualElement2, "pointerenter", onHoverStart || whileHover ? createHoverEvent(visualElement2, true, onHoverStart) : void 0, { passive: !onHoverStart });
  usePointerEvent(visualElement2, "pointerleave", onHoverEnd || whileHover ? createHoverEvent(visualElement2, false, onHoverEnd) : void 0, { passive: !onHoverEnd });
}

// node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs
var import_react45 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs
var isNodeOrChild = function(parent, child) {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};

// node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs
var import_react44 = __toESM(require_react(), 1);
function useUnmountEffect(callback) {
  return (0, import_react44.useEffect)(function() {
    return function() {
      return callback();
    };
  }, []);
}

// node_modules/popmotion/dist/es/utils/clamp.mjs
var clamp2 = (min2, max2, v) => Math.min(Math.max(v, min2), max2);

// node_modules/popmotion/dist/es/animations/utils/find-spring.mjs
var safeMin = 1e-3;
var minDuration = 0.01;
var maxDuration = 10;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= maxDuration * 1e3, "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp2(minDamping, maxDamping, dampingRatio);
  duration = clamp2(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f = Math.exp(-delta);
      const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

// node_modules/popmotion/dist/es/animations/generators/spring.mjs
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys2) {
  return keys2.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring(_a7) {
  var { from: from2 = 0, to = 1, restSpeed = 2, restDelta } = _a7, options = __rest(_a7, ["from", "to", "restSpeed", "restDelta"]);
  const state2 = { done: false, value: from2 };
  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  let resolveSpring = zero;
  let resolveVelocity = zero;
  function createSpring() {
    const initialVelocity = velocity ? -(velocity / 1e3) : 0;
    const initialDelta = to - from2;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    if (restDelta === void 0) {
      restDelta = Math.min(Math.abs(to - from2) / 100, 0.4);
    }
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
      };
      resolveVelocity = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t2) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t2)) - envelope * (Math.cos(angularFreq * t2) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t2));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t2) => to - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        const freqForT = Math.min(dampedAngularFreq * t2, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        const currentVelocity = resolveVelocity(t2) * 1e3;
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state2.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state2.done = t2 >= duration;
      }
      state2.value = state2.done ? to : current;
      return state2;
    },
    flipTarget: () => {
      velocity = -velocity;
      [from2, to] = [to, from2];
      createSpring();
    }
  };
}
spring.needsInterpolation = (a2, b2) => typeof a2 === "string" || typeof b2 === "string";
var zero = (_t) => 0;

// node_modules/popmotion/dist/es/utils/progress.mjs
var progress = (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};

// node_modules/popmotion/dist/es/utils/mix.mjs
var mix2 = (from2, to, progress2) => -progress2 * from2 + progress2 * to + from2;

// node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs
function hueToRgb(p, q, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p + (q - p) * 6 * t2;
  if (t2 < 1 / 2)
    return q;
  if (t2 < 2 / 3)
    return p + (q - p) * (2 / 3 - t2) * 6;
  return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q;
    red = hueToRgb(p, q, hue + 1 / 3);
    green = hueToRgb(p, q, hue);
    blue = hueToRgb(p, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}

// node_modules/popmotion/dist/es/utils/mix-color.mjs
var mixLinearColor = (from2, to, v) => {
  const fromExpo = from2 * from2;
  const toExpo = to * to;
  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));
};
var colorTypes = [hex, rgba2, hsla2];
var getColorType = (v) => colorTypes.find((type) => type.test(v));
var notAnimatable = (color3) => `'${color3}' is not an animatable color. Use the equivalent color code instead.`;
var mixColor = (from2, to) => {
  let fromColorType = getColorType(from2);
  let toColorType = getColorType(to);
  invariant(!!fromColorType, notAnimatable(from2));
  invariant(!!toColorType, notAnimatable(to));
  let fromColor = fromColorType.parse(from2);
  let toColor = toColorType.parse(to);
  if (fromColorType === hsla2) {
    fromColor = hslaToRgba(fromColor);
    fromColorType = rgba2;
  }
  if (toColorType === hsla2) {
    toColor = hslaToRgba(toColor);
    toColorType = rgba2;
  }
  const blended = Object.assign({}, fromColor);
  return (v) => {
    for (const key in blended) {
      if (key !== "alpha") {
        blended[key] = mixLinearColor(fromColor[key], toColor[key], v);
      }
    }
    blended.alpha = mix2(fromColor.alpha, toColor.alpha, v);
    return fromColorType.transform(blended);
  };
};

// node_modules/popmotion/dist/es/utils/inc.mjs
var isNum = (v) => typeof v === "number";

// node_modules/popmotion/dist/es/utils/pipe.mjs
var combineFunctions = (a2, b2) => (v) => b2(a2(v));
var pipe4 = (...transformers) => transformers.reduce(combineFunctions);

// node_modules/popmotion/dist/es/utils/mix-complex.mjs
function getMixer(origin, target) {
  if (isNum(origin)) {
    return (v) => mix2(origin, target, v);
  } else if (color2.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
var mixArray = (from2, to) => {
  const output = [...from2];
  const numValues = output.length;
  const blendValue = from2.map((fromThis, i) => getMixer(fromThis, to[i]));
  return (v) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v);
    }
    return output;
  };
};
var mixObject = (origin, target) => {
  const output = Object.assign(Object.assign({}, origin), target);
  const blendValue = {};
  for (const key in output) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v);
    }
    return output;
  };
};
function analyse2(value) {
  const parsed = complex.parse(value);
  const numValues = parsed.length;
  let numNumbers = 0;
  let numRGB = 0;
  let numHSL = 0;
  for (let i = 0; i < numValues; i++) {
    if (numNumbers || typeof parsed[i] === "number") {
      numNumbers++;
    } else {
      if (parsed[i].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
var mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyse2(origin);
  const targetStats = analyse2(target);
  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe4(mixArray(originStats.parsed, targetStats.parsed), template);
  } else {
    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return (p) => `${p > 0 ? target : origin}`;
  }
};

// node_modules/popmotion/dist/es/utils/interpolate.mjs
var mixNumber = (from2, to) => (p) => mix2(from2, to, p);
function detectMixerFactory(v) {
  if (typeof v === "number") {
    return mixNumber;
  } else if (typeof v === "string") {
    if (color2.test(v)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v)) {
    return mixArray;
  } else if (typeof v === "object") {
    return mixObject;
  }
}
function createMixers(output, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i] : ease;
      mixer = pipe4(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate([from2, to], [mixer]) {
  return (v) => mixer(progress(from2, to, v));
}
function slowInterpolate(input, mixers) {
  const inputLength = input.length;
  const lastInputIndex = inputLength - 1;
  return (v) => {
    let mixerIndex = 0;
    let foundMixerIndex = false;
    if (v <= input[0]) {
      foundMixerIndex = true;
    } else if (v >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      let i = 1;
      for (; i < inputLength; i++) {
        if (input[i] > v || i === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i - 1;
    }
    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output = [].concat(output);
    input.reverse();
    output.reverse();
  }
  const mixers = createMixers(output, ease, mixer);
  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? (v) => interpolator(clamp2(input[0], input[inputLength - 1], v)) : interpolator;
}

// node_modules/popmotion/dist/es/easing/utils.mjs
var reverseEasing = (easing) => (p) => 1 - easing(1 - p);
var mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
var createExpoIn = (power) => (p) => Math.pow(p, power);
var createBackIn = (power) => (p) => p * p * ((power + 1) * p - power);
var createAnticipate = (power) => {
  const backEasing = createBackIn(power);
  return (p) => (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
};

// node_modules/popmotion/dist/es/easing/index.mjs
var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var BOUNCE_FIRST_THRESHOLD = 4 / 11;
var BOUNCE_SECOND_THRESHOLD = 8 / 11;
var BOUNCE_THIRD_THRESHOLD = 9 / 10;
var linear = (p) => p;
var easeIn = createExpoIn(2);
var easeOut = reverseEasing(easeIn);
var easeInOut = mirrorEasing(easeIn);
var circIn = (p) => 1 - Math.sin(Math.acos(p));
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circOut);
var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = reverseEasing(backIn);
var backInOut = mirrorEasing(backIn);
var anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
var ca = 4356 / 361;
var cb = 35442 / 1805;
var cc = 16061 / 1805;
var bounceOut = (p) => {
  if (p === 1 || p === 0)
    return p;
  const p2 = p * p;
  return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;
};
var bounceIn = reverseEasing(bounceOut);
var bounceInOut = (p) => p < 0.5 ? 0.5 * (1 - bounceOut(1 - p * 2)) : 0.5 * bounceOut(p * 2 - 1) + 0.5;

// node_modules/popmotion/dist/es/animations/generators/keyframes.mjs
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset3, duration) {
  return offset3.map((o) => o * duration);
}
function keyframes3({ from: from2 = 0, to = 1, ease, offset: offset3, duration = 300 }) {
  const state2 = { done: false, value: from2 };
  const values = Array.isArray(to) ? to : [from2, to];
  const times = convertOffsetToTimes(offset3 && offset3.length === values.length ? offset3 : defaultOffset(values), duration);
  function createInterpolator() {
    return interpolate(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: (t2) => {
      state2.value = interpolator(t2);
      state2.done = t2 >= duration;
      return state2;
    },
    flipTarget: () => {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}

// node_modules/popmotion/dist/es/animations/generators/decay.mjs
function decay({ velocity = 0, from: from2 = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {
  const state2 = { done: false, value: from2 };
  let amplitude = power * velocity;
  const ideal = from2 + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - from2;
  return {
    next: (t2) => {
      const delta = -amplitude * Math.exp(-t2 / timeConstant);
      state2.done = !(delta > restDelta || delta < -restDelta);
      state2.value = state2.done ? target : target + delta;
      return state2;
    },
    flipTarget: () => {
    }
  };
}

// node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs
var types = { keyframes: keyframes3, spring, decay };
function detectAnimationFromOptions(config2) {
  if (Array.isArray(config2.to)) {
    return keyframes3;
  } else if (types[config2.type]) {
    return types[config2.type];
  }
  const keys2 = new Set(Object.keys(config2));
  if (keys2.has("ease") || keys2.has("duration") && !keys2.has("dampingRatio")) {
    return keyframes3;
  } else if (keys2.has("dampingRatio") || keys2.has("stiffness") || keys2.has("mass") || keys2.has("damping") || keys2.has("restSpeed") || keys2.has("restDelta")) {
    return spring;
  }
  return keyframes3;
}

// node_modules/popmotion/node_modules/framesync/dist/es/on-next-frame.mjs
var defaultTimestep = 1 / 60 * 1e3;
var getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
var onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);

// node_modules/popmotion/node_modules/framesync/dist/es/create-render-step.mjs
function createRenderStep(runNextFrame3) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing3 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing3;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing3)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index3 = toRunNextFrame.indexOf(callback);
      if (index3 !== -1)
        toRunNextFrame.splice(index3, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing3) {
        flushNextFrame = true;
        return;
      }
      isProcessing3 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = toRun[i];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame3();
          }
        }
      }
      isProcessing3 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}

// node_modules/popmotion/node_modules/framesync/dist/es/index.mjs
var maxElapsed = 40;
var useDefaultElapsed = true;
var runNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
var steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
var sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
var cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
var flushSync = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
var processStep = (stepId) => steps[stepId].process(frame);
var processFrame = (timestamp) => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
var startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
var getFrameData = () => frame;
var es_default = sync;

// node_modules/popmotion/dist/es/animations/utils/elapsed.mjs
function loopElapsed(elapsed, duration, delay = 0) {
  return elapsed - duration - delay;
}
function reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;
}
function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
}

// node_modules/popmotion/dist/es/animations/index.mjs
var framesync = (update) => {
  const passTimestamp = ({ delta }) => update(delta);
  return {
    start: () => es_default.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
};
function animate(_a7) {
  var _b5, _c14;
  var { from: from2, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a7, options = __rest(_a7, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let { to } = options;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = options.duration;
  let latest;
  let isComplete = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = detectAnimationFromOptions(options);
  if ((_c14 = (_b5 = animator).needsInterpolation) === null || _c14 === void 0 ? void 0 : _c14.call(_b5, from2, to)) {
    interpolateFromNumber = interpolate([0, 100], [from2, to], {
      clamp: false
    });
    from2 = 0;
    to = 100;
  }
  const animation = animator(Object.assign(Object.assign({}, options), { from: from2, to }));
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete) {
      const state2 = animation.next(Math.max(0, elapsed));
      latest = state2.value;
      if (interpolateFromNumber)
        latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state2.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0)
        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}

// node_modules/popmotion/dist/es/utils/velocity-per-second.mjs
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}

// node_modules/popmotion/dist/es/animations/inertia.mjs
function inertia({ from: from2 = 0, velocity = 0, min: min2, max: max2, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {
  let currentAnimation;
  function isOutOfBounds(v) {
    return min2 !== void 0 && v < min2 || max2 !== void 0 && v > max2;
  }
  function boundaryNearest(v) {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
  }
  function startAnimation2(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate(Object.assign(Object.assign({}, options), {
      driver,
      onUpdate: (v) => {
        var _a7;
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);
        (_a7 = options.onUpdate) === null || _a7 === void 0 ? void 0 : _a7.call(options, v);
      },
      onComplete,
      onStop
    }));
  }
  function startSpring(options) {
    startAnimation2(Object.assign({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));
  }
  if (isOutOfBounds(from2)) {
    startSpring({ from: from2, velocity, to: boundaryNearest(from2) });
  } else {
    let target = power * velocity + from2;
    if (typeof modifyTarget !== "undefined")
      target = modifyTarget(target);
    const boundary = boundaryNearest(target);
    const heading = boundary === min2 ? -1 : 1;
    let prev2;
    let current;
    const checkBoundary = (v) => {
      prev2 = current;
      current = v;
      velocity = velocityPerSecond(v - prev2, getFrameData().delta);
      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {
        startSpring({ from: v, to: boundary, velocity });
      }
    };
    startAnimation2({
      type: "decay",
      from: from2,
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0
    });
  }
  return {
    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()
  };
}

// node_modules/popmotion/dist/es/utils/is-point.mjs
var isPoint = (point) => point.hasOwnProperty("x") && point.hasOwnProperty("y");

// node_modules/popmotion/dist/es/utils/is-point-3d.mjs
var isPoint3D = (point) => isPoint(point) && point.hasOwnProperty("z");

// node_modules/popmotion/dist/es/utils/distance.mjs
var distance1D = (a2, b2) => Math.abs(a2 - b2);
function distance2(a2, b2) {
  if (isNum(a2) && isNum(b2)) {
    return distance1D(a2, b2);
  } else if (isPoint(a2) && isPoint(b2)) {
    const xDelta = distance1D(a2.x, b2.x);
    const yDelta = distance1D(a2.y, b2.y);
    const zDelta = isPoint3D(a2) && isPoint3D(b2) ? distance1D(a2.z, b2.z) : 0;
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
}

// node_modules/popmotion/dist/es/easing/cubic-bezier.mjs
var a = (a1, a2) => 1 - 3 * a2 + 3 * a1;
var b = (a1, a2) => 3 * a2 - 6 * a1;
var c = (a1) => 3 * a1;
var calcBezier = (t2, a1, a2) => ((a(a1, a2) * t2 + b(a1, a2)) * t2 + c(a1)) * t2;
var getSlope = (t2, a1, a2) => 3 * a(a1, a2) * t2 * t2 + 2 * b(a1, a2) * t2 + c(a1);
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 10;
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
var newtonIterations = 8;
var newtonMinSlope = 1e-3;
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (let i = 0; i < newtonIterations; ++i) {
    const currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return linear;
  const sampleValues = new Float32Array(kSplineTableSize);
  for (let i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    let intervalStart = 0;
    let currentSample = 1;
    const lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    const guessForT = intervalStart + dist * kSampleStepSize;
    const initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= newtonMinSlope) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}

// node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs
function useTapGesture(_a7) {
  var onTap = _a7.onTap, onTapStart = _a7.onTapStart, onTapCancel = _a7.onTapCancel, whileTap = _a7.whileTap, visualElement2 = _a7.visualElement;
  var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
  var isPressing = (0, import_react45.useRef)(false);
  var cancelPointerEndListeners = (0, import_react45.useRef)(null);
  var eventOptions = {
    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)
  };
  function removePointerEndListener() {
    var _a8;
    (_a8 = cancelPointerEndListeners.current) === null || _a8 === void 0 ? void 0 : _a8.call(cancelPointerEndListeners);
    cancelPointerEndListeners.current = null;
  }
  function checkPointerEnd() {
    var _a8;
    removePointerEndListener();
    isPressing.current = false;
    (_a8 = visualElement2.animationState) === null || _a8 === void 0 ? void 0 : _a8.setActive(AnimationType.Tap, false);
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    if (!checkPointerEnd())
      return;
    !isNodeOrChild(visualElement2.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);
  }
  function onPointerCancel(event, info) {
    if (!checkPointerEnd())
      return;
    onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);
  }
  function onPointerDown(event, info) {
    var _a8;
    removePointerEndListener();
    if (isPressing.current)
      return;
    isPressing.current = true;
    cancelPointerEndListeners.current = pipe4(addPointerEvent(window, "pointerup", onPointerUp, eventOptions), addPointerEvent(window, "pointercancel", onPointerCancel, eventOptions));
    (_a8 = visualElement2.animationState) === null || _a8 === void 0 ? void 0 : _a8.setActive(AnimationType.Tap, true);
    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);
  }
  usePointerEvent(visualElement2, "pointerdown", hasPressListeners ? onPointerDown : void 0, eventOptions);
  useUnmountEffect(removePointerEndListener);
}

// node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs
var import_react46 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/warn-once.mjs
var warned = /* @__PURE__ */ new Set();
function warnOnce(condition, message, element) {
  if (condition || warned.has(message))
    return;
  console.warn(message);
  if (element)
    console.warn(element);
  warned.add(message);
}

// node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
var observerCallbacks = /* @__PURE__ */ new WeakMap();
var observers = /* @__PURE__ */ new WeakMap();
var fireObserverCallback = function(entry) {
  var _a7;
  (_a7 = observerCallbacks.get(entry.target)) === null || _a7 === void 0 ? void 0 : _a7(entry);
};
var fireAllObserverCallbacks = function(entries) {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver(_a7) {
  var root = _a7.root, options = __rest(_a7, ["root"]);
  var lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  var rootObservers = observers.get(lookupRoot);
  var key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __assign({ root }, options));
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  var rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return function() {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}

// node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs
function useViewport(_a7) {
  var visualElement2 = _a7.visualElement, whileInView = _a7.whileInView, onViewportEnter = _a7.onViewportEnter, onViewportLeave = _a7.onViewportLeave, _b5 = _a7.viewport, viewport2 = _b5 === void 0 ? {} : _b5;
  var state2 = (0, import_react46.useRef)({
    hasEnteredView: false,
    isInView: false
  });
  var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);
  if (viewport2.once && state2.current.hasEnteredView)
    shouldObserve = false;
  var useObserver = typeof IntersectionObserver === "undefined" ? useMissingIntersectionObserver : useIntersectionObserver;
  useObserver(shouldObserve, state2.current, visualElement2, viewport2);
}
var thresholdNames = {
  some: 0,
  all: 1
};
function useIntersectionObserver(shouldObserve, state2, visualElement2, _a7) {
  var root = _a7.root, rootMargin = _a7.margin, _b5 = _a7.amount, amount = _b5 === void 0 ? "some" : _b5, once2 = _a7.once;
  (0, import_react46.useEffect)(function() {
    if (!shouldObserve)
      return;
    var options = {
      root: root === null || root === void 0 ? void 0 : root.current,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    var intersectionCallback = function(entry) {
      var _a8;
      var isIntersecting = entry.isIntersecting;
      if (state2.isInView === isIntersecting)
        return;
      state2.isInView = isIntersecting;
      if (once2 && !isIntersecting && state2.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        state2.hasEnteredView = true;
      }
      (_a8 = visualElement2.animationState) === null || _a8 === void 0 ? void 0 : _a8.setActive(AnimationType.InView, isIntersecting);
      var props = visualElement2.getProps();
      var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;
      callback === null || callback === void 0 ? void 0 : callback(entry);
    };
    return observeIntersection(visualElement2.getInstance(), options, intersectionCallback);
  }, [shouldObserve, root, rootMargin, amount]);
}
function useMissingIntersectionObserver(shouldObserve, state2, visualElement2, _a7) {
  var _b5 = _a7.fallback, fallback = _b5 === void 0 ? true : _b5;
  (0, import_react46.useEffect)(function() {
    if (!shouldObserve || !fallback)
      return;
    if (env !== "production") {
      warnOnce(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount.");
    }
    requestAnimationFrame(function() {
      var _a8;
      state2.hasEnteredView = true;
      var onViewportEnter = visualElement2.getProps().onViewportEnter;
      onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);
      (_a8 = visualElement2.animationState) === null || _a8 === void 0 ? void 0 : _a8.setActive(AnimationType.InView, true);
    });
  }, [shouldObserve]);
}

// node_modules/framer-motion/dist/es/motion/utils/make-renderless-component.mjs
var makeRenderlessComponent = function(hook) {
  return function(props) {
    hook(props);
    return null;
  };
};

// node_modules/framer-motion/dist/es/motion/features/gestures.mjs
var gestureAnimations = {
  inView: makeRenderlessComponent(useViewport),
  tap: makeRenderlessComponent(useTapGesture),
  focus: makeRenderlessComponent(useFocusGesture),
  hover: makeRenderlessComponent(useHoverGesture)
};

// node_modules/framer-motion/dist/es/motion/features/animations.mjs
var import_react48 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
var import_react47 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-id.mjs
var counter = 0;
var incrementId = function() {
  return counter++;
};
var useId = function() {
  return useConstant(incrementId);
};

// node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
function usePresence() {
  var context = (0, import_react47.useContext)(PresenceContext);
  if (context === null)
    return [true, null];
  var isPresent2 = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;
  var id2 = useId();
  (0, import_react47.useEffect)(function() {
    return register(id2);
  }, []);
  var safeToRemove = function() {
    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id2);
  };
  return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
}
function useIsPresent() {
  return isPresent((0, import_react47.useContext)(PresenceContext));
}
function isPresent(context) {
  return context === null ? true : context.isPresent;
}

// node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
function shallowCompare(next2, prev2) {
  if (!Array.isArray(prev2))
    return false;
  var prevLength = prev2.length;
  if (prevLength !== next2.length)
    return false;
  for (var i = 0; i < prevLength; i++) {
    if (prev2[i] !== next2[i])
      return false;
  }
  return true;
}

// node_modules/framer-motion/dist/es/utils/time-conversion.mjs
var secondsToMilliseconds = function(seconds) {
  return seconds * 1e3;
};

// node_modules/framer-motion/dist/es/animation/utils/easing.mjs
var easingLookup = {
  linear,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
  bounceIn,
  bounceInOut,
  bounceOut
};
var easingDefinitionToFunction = function(definition) {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4, "Cubic bezier arrays must contain four numerical values.");
    var _a7 = __read(definition, 4), x1 = _a7[0], y1 = _a7[1], x2 = _a7[2], y2 = _a7[3];
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant(easingLookup[definition] !== void 0, "Invalid easing type '".concat(definition, "'"));
    return easingLookup[definition];
  }
  return definition;
};
var isEasingArray = function(ease) {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};

// node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs
var isAnimatable = function(key, value) {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  complex.test(value) && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};

// node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
var underDampedSpring = function() {
  return {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
};
var criticallyDampedSpring = function(to) {
  return {
    type: "spring",
    stiffness: 550,
    damping: to === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  };
};
var linearTween = function() {
  return {
    type: "keyframes",
    ease: "linear",
    duration: 0.3
  };
};
var keyframes4 = function(values) {
  return {
    type: "keyframes",
    duration: 0.8,
    values
  };
};
var defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
var getDefaultTransition = function(valueKey, to) {
  var transitionFactory;
  if (isKeyframesTarget(to)) {
    transitionFactory = keyframes4;
  } else {
    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
  }
  return __assign({ to }, transitionFactory(to));
};

// node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs
var defaultValueTypes = __assign(__assign({}, numberValueTypes), {
  // Color props
  color: color2,
  backgroundColor: color2,
  outlineColor: color2,
  fill: color2,
  stroke: color2,
  // Border props
  borderColor: color2,
  borderTopColor: color2,
  borderRightColor: color2,
  borderBottomColor: color2,
  borderLeftColor: color2,
  filter: filter2,
  WebkitFilter: filter2
});
var getDefaultValueType = function(key) {
  return defaultValueTypes[key];
};

// node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs
function getAnimatableNone2(key, value) {
  var _a7;
  var defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter2)
    defaultValueType = complex;
  return (_a7 = defaultValueType.getAnimatableNone) === null || _a7 === void 0 ? void 0 : _a7.call(defaultValueType, value);
}

// node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs
var instantAnimationState = {
  current: false
};

// node_modules/framer-motion/dist/es/animation/utils/transitions.mjs
function isTransitionDefined(_a7) {
  _a7.when;
  _a7.delay;
  _a7.delayChildren;
  _a7.staggerChildren;
  _a7.staggerDirection;
  _a7.repeat;
  _a7.repeatType;
  _a7.repeatDelay;
  _a7.from;
  var transition3 = __rest(_a7, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);
  return !!Object.keys(transition3).length;
}
var legacyRepeatWarning = false;
function convertTransitionToAnimationOptions(_a7) {
  var ease = _a7.ease, times = _a7.times, yoyo = _a7.yoyo, flip3 = _a7.flip, loop = _a7.loop, transition3 = __rest(_a7, ["ease", "times", "yoyo", "flip", "loop"]);
  var options = __assign({}, transition3);
  if (times)
    options["offset"] = times;
  if (transition3.duration)
    options["duration"] = secondsToMilliseconds(transition3.duration);
  if (transition3.repeatDelay)
    options.repeatDelay = secondsToMilliseconds(transition3.repeatDelay);
  if (ease) {
    options["ease"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  }
  if (transition3.type === "tween")
    options.type = "keyframes";
  if (yoyo || loop || flip3) {
    warning(!legacyRepeatWarning, "yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.");
    legacyRepeatWarning = true;
    if (yoyo) {
      options.repeatType = "reverse";
    } else if (loop) {
      options.repeatType = "loop";
    } else if (flip3) {
      options.repeatType = "mirror";
    }
    options.repeat = loop || yoyo || flip3 || transition3.repeat;
  }
  if (transition3.type !== "spring")
    options.type = "keyframes";
  return options;
}
function getDelayFromTransition(transition3, key) {
  var _a7, _b5;
  var valueTransition = getValueTransition(transition3, key) || {};
  return (_b5 = (_a7 = valueTransition.delay) !== null && _a7 !== void 0 ? _a7 : transition3.delay) !== null && _b5 !== void 0 ? _b5 : 0;
}
function hydrateKeyframes(options) {
  if (Array.isArray(options.to) && options.to[0] === null) {
    options.to = __spreadArray([], __read(options.to), false);
    options.to[0] = options.from;
  }
  return options;
}
function getPopmotionAnimationOptions(transition3, options, key) {
  var _a7;
  if (Array.isArray(options.to)) {
    (_a7 = transition3.duration) !== null && _a7 !== void 0 ? _a7 : transition3.duration = 0.8;
  }
  hydrateKeyframes(options);
  if (!isTransitionDefined(transition3)) {
    transition3 = __assign(__assign({}, transition3), getDefaultTransition(key, options.to));
  }
  return __assign(__assign({}, options), convertTransitionToAnimationOptions(transition3));
}
function getAnimation(key, value, target, transition3, onComplete) {
  var _a7;
  var valueTransition = getValueTransition(transition3, key);
  var origin = (_a7 = valueTransition.from) !== null && _a7 !== void 0 ? _a7 : value.get();
  var isTargetAnimatable = isAnimatable(key, target);
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    origin = getAnimatableNone2(key, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  var isOriginAnimatable = isAnimatable(key, origin);
  warning(isOriginAnimatable === isTargetAnimatable, "You are trying to animate ".concat(key, ' from "').concat(origin, '" to "').concat(target, '". ').concat(origin, " is not an animatable value - to enable this animation set ").concat(origin, " to a value animatable to ").concat(target, " via the `style` property."));
  function start2() {
    var options = {
      from: origin,
      to: target,
      velocity: value.getVelocity(),
      onComplete,
      onUpdate: function(v) {
        return value.set(v);
      }
    };
    return valueTransition.type === "inertia" || valueTransition.type === "decay" ? inertia(__assign(__assign({}, options), valueTransition)) : animate(__assign(__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function(v) {
      var _a8;
      options.onUpdate(v);
      (_a8 = valueTransition.onUpdate) === null || _a8 === void 0 ? void 0 : _a8.call(valueTransition, v);
    }, onComplete: function() {
      var _a8;
      options.onComplete();
      (_a8 = valueTransition.onComplete) === null || _a8 === void 0 ? void 0 : _a8.call(valueTransition);
    } }));
  }
  function set() {
    var _a8, _b5;
    var finalTarget = resolveFinalValueInKeyframes(target);
    value.set(finalTarget);
    onComplete();
    (_a8 = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onUpdate) === null || _a8 === void 0 ? void 0 : _a8.call(valueTransition, finalTarget);
    (_b5 = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _b5 === void 0 ? void 0 : _b5.call(valueTransition);
    return { stop: function() {
    } };
  }
  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start2;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone2("", potentialUnitType);
}
function getValueTransition(transition3, key) {
  return transition3[key] || transition3["default"] || transition3;
}
function startAnimation(key, value, target, transition3) {
  if (transition3 === void 0) {
    transition3 = {};
  }
  if (instantAnimationState.current) {
    transition3 = { type: false };
  }
  return value.start(function(onComplete) {
    var delayTimer;
    var controls;
    var animation = getAnimation(key, value, target, transition3, onComplete);
    var delay = getDelayFromTransition(transition3, key);
    var start2 = function() {
      return controls = animation();
    };
    if (delay) {
      delayTimer = window.setTimeout(start2, secondsToMilliseconds(delay));
    } else {
      start2();
    }
    return function() {
      clearTimeout(delayTimer);
      controls === null || controls === void 0 ? void 0 : controls.stop();
    };
  });
}

// node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs
var isNumericalString = function(v) {
  return /^\-?\d*\.?\d+$/.test(v);
};

// node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs
var isZeroValueString = function(v) {
  return /^0[^.\s]+$/.test(v);
};

// node_modules/framer-motion/node_modules/framesync/dist/es/on-next-frame.mjs
var defaultTimestep2 = 1 / 60 * 1e3;
var getCurrentTime2 = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
var onNextFrame2 = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime2()), defaultTimestep2);

// node_modules/framer-motion/node_modules/framesync/dist/es/create-render-step.mjs
function createRenderStep2(runNextFrame3) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing3 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing3;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing3)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index3 = toRunNextFrame.indexOf(callback);
      if (index3 !== -1)
        toRunNextFrame.splice(index3, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing3) {
        flushNextFrame = true;
        return;
      }
      isProcessing3 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = toRun[i];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame3();
          }
        }
      }
      isProcessing3 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}

// node_modules/framer-motion/node_modules/framesync/dist/es/index.mjs
var maxElapsed2 = 40;
var useDefaultElapsed2 = true;
var runNextFrame2 = false;
var isProcessing2 = false;
var frame2 = {
  delta: 0,
  timestamp: 0
};
var stepsOrder2 = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
var steps2 = stepsOrder2.reduce((acc, key) => {
  acc[key] = createRenderStep2(() => runNextFrame2 = true);
  return acc;
}, {});
var sync2 = stepsOrder2.reduce((acc, key) => {
  const step = steps2[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame2)
      startLoop2();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
var cancelSync2 = stepsOrder2.reduce((acc, key) => {
  acc[key] = steps2[key].cancel;
  return acc;
}, {});
var flushSync2 = stepsOrder2.reduce((acc, key) => {
  acc[key] = () => steps2[key].process(frame2);
  return acc;
}, {});
var processStep2 = (stepId) => steps2[stepId].process(frame2);
var processFrame2 = (timestamp) => {
  runNextFrame2 = false;
  frame2.delta = useDefaultElapsed2 ? defaultTimestep2 : Math.max(Math.min(timestamp - frame2.timestamp, maxElapsed2), 1);
  frame2.timestamp = timestamp;
  isProcessing2 = true;
  stepsOrder2.forEach(processStep2);
  isProcessing2 = false;
  if (runNextFrame2) {
    useDefaultElapsed2 = false;
    onNextFrame2(processFrame2);
  }
};
var startLoop2 = () => {
  runNextFrame2 = true;
  useDefaultElapsed2 = true;
  if (!isProcessing2)
    onNextFrame2(processFrame2);
};
var getFrameData2 = () => frame2;
var es_default2 = sync2;

// node_modules/framer-motion/dist/es/utils/array.mjs
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  var index3 = arr.indexOf(item);
  index3 > -1 && arr.splice(index3, 1);
}

// node_modules/framer-motion/dist/es/utils/subscription-manager.mjs
var SubscriptionManager = (
  /** @class */
  function() {
    function SubscriptionManager2() {
      this.subscriptions = [];
    }
    SubscriptionManager2.prototype.add = function(handler) {
      var _this = this;
      addUniqueItem(this.subscriptions, handler);
      return function() {
        return removeItem(_this.subscriptions, handler);
      };
    };
    SubscriptionManager2.prototype.notify = function(a2, b2, c2) {
      var numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a2, b2, c2);
      } else {
        for (var i = 0; i < numSubscriptions; i++) {
          var handler = this.subscriptions[i];
          handler && handler(a2, b2, c2);
        }
      }
    };
    SubscriptionManager2.prototype.getSize = function() {
      return this.subscriptions.length;
    };
    SubscriptionManager2.prototype.clear = function() {
      this.subscriptions.length = 0;
    };
    return SubscriptionManager2;
  }()
);

// node_modules/framer-motion/dist/es/value/index.mjs
var isFloat = function(value) {
  return !isNaN(parseFloat(value));
};
var MotionValue = (
  /** @class */
  function() {
    function MotionValue2(init) {
      var _this = this;
      this.version = "6.5.1";
      this.timeDelta = 0;
      this.lastUpdated = 0;
      this.updateSubscribers = new SubscriptionManager();
      this.velocityUpdateSubscribers = new SubscriptionManager();
      this.renderSubscribers = new SubscriptionManager();
      this.canTrackVelocity = false;
      this.updateAndNotify = function(v, render) {
        if (render === void 0) {
          render = true;
        }
        _this.prev = _this.current;
        _this.current = v;
        var _a7 = getFrameData2(), delta = _a7.delta, timestamp = _a7.timestamp;
        if (_this.lastUpdated !== timestamp) {
          _this.timeDelta = delta;
          _this.lastUpdated = timestamp;
          es_default2.postRender(_this.scheduleVelocityCheck);
        }
        if (_this.prev !== _this.current) {
          _this.updateSubscribers.notify(_this.current);
        }
        if (_this.velocityUpdateSubscribers.getSize()) {
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
        if (render) {
          _this.renderSubscribers.notify(_this.current);
        }
      };
      this.scheduleVelocityCheck = function() {
        return es_default2.postRender(_this.velocityCheck);
      };
      this.velocityCheck = function(_a7) {
        var timestamp = _a7.timestamp;
        if (timestamp !== _this.lastUpdated) {
          _this.prev = _this.current;
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
      };
      this.hasAnimated = false;
      this.prev = this.current = init;
      this.canTrackVelocity = isFloat(this.current);
    }
    MotionValue2.prototype.onChange = function(subscription) {
      return this.updateSubscribers.add(subscription);
    };
    MotionValue2.prototype.clearListeners = function() {
      this.updateSubscribers.clear();
    };
    MotionValue2.prototype.onRenderRequest = function(subscription) {
      subscription(this.get());
      return this.renderSubscribers.add(subscription);
    };
    MotionValue2.prototype.attach = function(passiveEffect) {
      this.passiveEffect = passiveEffect;
    };
    MotionValue2.prototype.set = function(v, render) {
      if (render === void 0) {
        render = true;
      }
      if (!render || !this.passiveEffect) {
        this.updateAndNotify(v, render);
      } else {
        this.passiveEffect(v, this.updateAndNotify);
      }
    };
    MotionValue2.prototype.get = function() {
      return this.current;
    };
    MotionValue2.prototype.getPrevious = function() {
      return this.prev;
    };
    MotionValue2.prototype.getVelocity = function() {
      return this.canTrackVelocity ? (
        // These casts could be avoided if parseFloat would be typed better
        velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      ) : 0;
    };
    MotionValue2.prototype.start = function(animation) {
      var _this = this;
      this.stop();
      return new Promise(function(resolve) {
        _this.hasAnimated = true;
        _this.stopAnimation = animation(resolve);
      }).then(function() {
        return _this.clearAnimation();
      });
    };
    MotionValue2.prototype.stop = function() {
      if (this.stopAnimation)
        this.stopAnimation();
      this.clearAnimation();
    };
    MotionValue2.prototype.isAnimating = function() {
      return !!this.stopAnimation;
    };
    MotionValue2.prototype.clearAnimation = function() {
      this.stopAnimation = null;
    };
    MotionValue2.prototype.destroy = function() {
      this.updateSubscribers.clear();
      this.renderSubscribers.clear();
      this.stop();
    };
    return MotionValue2;
  }()
);
function motionValue(init) {
  return new MotionValue(init);
}

// node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs
var testValueType = function(v) {
  return function(type) {
    return type.test(v);
  };
};

// node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs
var auto = {
  test: function(v) {
    return v === "auto";
  },
  parse: function(v) {
    return v;
  }
};

// node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs
var dimensionValueTypes = [number, px2, percent, degrees, vw, vh, auto];
var findDimensionValueType = function(v) {
  return dimensionValueTypes.find(testValueType(v));
};

// node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
var valueTypes = __spreadArray(__spreadArray([], __read(dimensionValueTypes), false), [color2, complex], false);
var findValueType = function(v) {
  return valueTypes.find(testValueType(v));
};

// node_modules/framer-motion/dist/es/render/utils/setters.mjs
function setMotionValue(visualElement2, key, value) {
  if (visualElement2.hasValue(key)) {
    visualElement2.getValue(key).set(value);
  } else {
    visualElement2.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement2, definition) {
  var resolved = resolveVariant(visualElement2, definition);
  var _a7 = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {}, _b5 = _a7.transitionEnd, transitionEnd = _b5 === void 0 ? {} : _b5;
  _a7.transition;
  var target = __rest(_a7, ["transitionEnd", "transition"]);
  target = __assign(__assign({}, target), transitionEnd);
  for (var key in target) {
    var value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement2, key, value);
  }
}
function checkTargetForNewValues(visualElement2, target, origin) {
  var _a7, _b5, _c14;
  var _d3;
  var newValueKeys = Object.keys(target).filter(function(key2) {
    return !visualElement2.hasValue(key2);
  });
  var numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (var i = 0; i < numNewValues; i++) {
    var key = newValueKeys[i];
    var targetValue = target[key];
    var value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b5 = (_a7 = origin[key]) !== null && _a7 !== void 0 ? _a7 : visualElement2.readValue(key)) !== null && _b5 !== void 0 ? _b5 : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone2(key, targetValue);
    }
    visualElement2.addValue(key, motionValue(value));
    (_c14 = (_d3 = origin)[key]) !== null && _c14 !== void 0 ? _c14 : _d3[key] = value;
    visualElement2.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition3) {
  if (!transition3)
    return;
  var valueTransition = transition3[key] || transition3["default"] || transition3;
  return valueTransition.from;
}
function getOrigin(target, transition3, visualElement2) {
  var _a7, _b5;
  var origin = {};
  for (var key in target) {
    origin[key] = (_a7 = getOriginFromTransition(key, transition3)) !== null && _a7 !== void 0 ? _a7 : (_b5 = visualElement2.getValue(key)) === null || _b5 === void 0 ? void 0 : _b5.get();
  }
  return origin;
}

// node_modules/framer-motion/dist/es/render/utils/animation.mjs
function animateVisualElement(visualElement2, definition, options) {
  if (options === void 0) {
    options = {};
  }
  visualElement2.notifyAnimationStart(definition);
  var animation;
  if (Array.isArray(definition)) {
    var animations2 = definition.map(function(variant) {
      return animateVariant(visualElement2, variant, options);
    });
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement2, definition, options);
  } else {
    var resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement2, definition, options.custom) : definition;
    animation = animateTarget(visualElement2, resolvedDefinition, options);
  }
  return animation.then(function() {
    return visualElement2.notifyAnimationComplete(definition);
  });
}
function animateVariant(visualElement2, variant, options) {
  var _a7;
  if (options === void 0) {
    options = {};
  }
  var resolved = resolveVariant(visualElement2, variant, options.custom);
  var _b5 = (resolved || {}).transition, transition3 = _b5 === void 0 ? visualElement2.getDefaultTransition() || {} : _b5;
  if (options.transitionOverride) {
    transition3 = options.transitionOverride;
  }
  var getAnimation2 = resolved ? function() {
    return animateTarget(visualElement2, resolved, options);
  } : function() {
    return Promise.resolve();
  };
  var getChildAnimations = ((_a7 = visualElement2.variantChildren) === null || _a7 === void 0 ? void 0 : _a7.size) ? function(forwardDelay) {
    if (forwardDelay === void 0) {
      forwardDelay = 0;
    }
    var _a8 = transition3.delayChildren, delayChildren = _a8 === void 0 ? 0 : _a8, staggerChildren = transition3.staggerChildren, staggerDirection = transition3.staggerDirection;
    return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : function() {
    return Promise.resolve();
  };
  var when = transition3.when;
  if (when) {
    var _c14 = __read(when === "beforeChildren" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2], 2), first = _c14[0], last = _c14[1];
    return first().then(last);
  } else {
    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);
  }
}
function animateTarget(visualElement2, definition, _a7) {
  var _b5;
  var _c14 = _a7 === void 0 ? {} : _a7, _d3 = _c14.delay, delay = _d3 === void 0 ? 0 : _d3, transitionOverride = _c14.transitionOverride, type = _c14.type;
  var _e3 = visualElement2.makeTargetAnimatable(definition), _f3 = _e3.transition, transition3 = _f3 === void 0 ? visualElement2.getDefaultTransition() : _f3, transitionEnd = _e3.transitionEnd, target = __rest(_e3, ["transition", "transitionEnd"]);
  if (transitionOverride)
    transition3 = transitionOverride;
  var animations2 = [];
  var animationTypeState = type && ((_b5 = visualElement2.animationState) === null || _b5 === void 0 ? void 0 : _b5.getState()[type]);
  for (var key in target) {
    var value = visualElement2.getValue(key);
    var valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    var valueTransition = __assign({ delay }, transition3);
    if (visualElement2.shouldReduceMotion && isTransformProp(key)) {
      valueTransition = __assign(__assign({}, valueTransition), { type: false, delay: 0 });
    }
    var animation = startAnimation(key, value, valueTarget, valueTransition);
    animations2.push(animation);
  }
  return Promise.all(animations2).then(function() {
    transitionEnd && setTarget(visualElement2, transitionEnd);
  });
}
function animateChildren(visualElement2, variant, delayChildren, staggerChildren, staggerDirection, options) {
  if (delayChildren === void 0) {
    delayChildren = 0;
  }
  if (staggerChildren === void 0) {
    staggerChildren = 0;
  }
  if (staggerDirection === void 0) {
    staggerDirection = 1;
  }
  var animations2 = [];
  var maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;
  var generateStaggerDuration = staggerDirection === 1 ? function(i) {
    if (i === void 0) {
      i = 0;
    }
    return i * staggerChildren;
  } : function(i) {
    if (i === void 0) {
      i = 0;
    }
    return maxStaggerDuration - i * staggerChildren;
  };
  Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach(function(child, i) {
    animations2.push(animateVariant(child, variant, __assign(__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function() {
      return child.notifyAnimationComplete(variant);
    }));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function shouldBlockAnimation(_a7, key) {
  var protectedKeys = _a7.protectedKeys, needsAnimating = _a7.needsAnimating;
  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}

// node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
var variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.InView,
  AnimationType.Focus,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Exit
];
var reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder), false).reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement2) {
  return function(animations2) {
    return Promise.all(animations2.map(function(_a7) {
      var animation = _a7.animation, options = _a7.options;
      return animateVisualElement(visualElement2, animation, options);
    }));
  };
}
function createAnimationState(visualElement2) {
  var animate3 = animateList(visualElement2);
  var state2 = createState();
  var allAnimatedKeys = {};
  var isInitialRender = true;
  var buildResolvedTypeValues = function(acc, definition) {
    var resolved = resolveVariant(visualElement2, definition);
    if (resolved) {
      resolved.transition;
      var transitionEnd = resolved.transitionEnd, target = __rest(resolved, ["transition", "transitionEnd"]);
      acc = __assign(__assign(__assign({}, acc), target), transitionEnd);
    }
    return acc;
  };
  function isAnimated(key) {
    return allAnimatedKeys[key] !== void 0;
  }
  function setAnimateFunction(makeAnimator) {
    animate3 = makeAnimator(visualElement2);
  }
  function animateChanges(options, changedActiveType) {
    var _a7;
    var props = visualElement2.getProps();
    var context = visualElement2.getVariantContext(true) || {};
    var animations2 = [];
    var removedKeys = /* @__PURE__ */ new Set();
    var encounteredKeys = {};
    var removedVariantIndex = Infinity;
    var _loop_1 = function(i2) {
      var type = reversePriorityOrder[i2];
      var typeState = state2[type];
      var prop = (_a7 = props[type]) !== null && _a7 !== void 0 ? _a7 : context[type];
      var propIsVariant = isVariantLabel(prop);
      var activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = __assign({}, encounteredKeys);
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        return "continue";
      }
      var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      var shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      var definitionList = Array.isArray(prop) ? prop : [prop];
      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      var _b5 = typeState.prevResolvedValues, prevResolvedValues = _b5 === void 0 ? {} : _b5;
      var allKeys2 = __assign(__assign({}, prevResolvedValues), resolvedValues);
      var markToAnimate = function(key2) {
        shouldAnimateType = true;
        removedKeys.delete(key2);
        typeState.needsAnimating[key2] = true;
      };
      for (var key in allKeys2) {
        var next2 = resolvedValues[key];
        var prev2 = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next2 !== prev2) {
          if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
            if (!shallowCompare(next2, prev2) || variantDidChange) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next2 !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next2 !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);
      }
      if (isInitialRender && visualElement2.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push.apply(animations2, __spreadArray([], __read(definitionList.map(function(animation) {
          return {
            animation,
            options: __assign({ type }, options)
          };
        })), false));
      }
    };
    for (var i = 0; i < numAnimationTypes; i++) {
      _loop_1(i);
    }
    allAnimatedKeys = __assign({}, encounteredKeys);
    if (removedKeys.size) {
      var fallbackAnimation_1 = {};
      removedKeys.forEach(function(key) {
        var fallbackTarget = visualElement2.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation_1[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation_1 });
    }
    var shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate3(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a7;
    if (state2[type].isActive === isActive)
      return Promise.resolve();
    (_a7 = visualElement2.variantChildren) === null || _a7 === void 0 ? void 0 : _a7.forEach(function(child) {
      var _a8;
      return (_a8 = child.animationState) === null || _a8 === void 0 ? void 0 : _a8.setActive(type, isActive);
    });
    state2[type].isActive = isActive;
    var animations2 = animateChanges(options, type);
    for (var key in state2) {
      state2[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    isAnimated,
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: function() {
      return state2;
    }
  };
}
function checkVariantsDidChange(prev2, next2) {
  if (typeof next2 === "string") {
    return next2 !== prev2;
  } else if (isVariantLabels(next2)) {
    return !shallowCompare(next2, prev2);
  }
  return false;
}
function createTypeState(isActive) {
  if (isActive === void 0) {
    isActive = false;
  }
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  var _a7;
  return _a7 = {}, _a7[AnimationType.Animate] = createTypeState(true), _a7[AnimationType.InView] = createTypeState(), _a7[AnimationType.Hover] = createTypeState(), _a7[AnimationType.Tap] = createTypeState(), _a7[AnimationType.Drag] = createTypeState(), _a7[AnimationType.Focus] = createTypeState(), _a7[AnimationType.Exit] = createTypeState(), _a7;
}

// node_modules/framer-motion/dist/es/motion/features/animations.mjs
var animations = {
  animation: makeRenderlessComponent(function(_a7) {
    var visualElement2 = _a7.visualElement, animate3 = _a7.animate;
    visualElement2.animationState || (visualElement2.animationState = createAnimationState(visualElement2));
    if (isAnimationControls(animate3)) {
      (0, import_react48.useEffect)(function() {
        return animate3.subscribe(visualElement2);
      }, [animate3]);
    }
  }),
  exit: makeRenderlessComponent(function(props) {
    var custom = props.custom, visualElement2 = props.visualElement;
    var _a7 = __read(usePresence(), 2), isPresent2 = _a7[0], safeToRemove = _a7[1];
    var presenceContext = (0, import_react48.useContext)(PresenceContext);
    (0, import_react48.useEffect)(function() {
      var _a8, _b5;
      visualElement2.isPresent = isPresent2;
      var animation = (_a8 = visualElement2.animationState) === null || _a8 === void 0 ? void 0 : _a8.setActive(AnimationType.Exit, !isPresent2, { custom: (_b5 = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b5 !== void 0 ? _b5 : custom });
      !isPresent2 && (animation === null || animation === void 0 ? void 0 : animation.then(safeToRemove));
    }, [isPresent2]);
  })
};

// node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs
var import_react49 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/gestures/PanSession.mjs
var PanSession = (
  /** @class */
  function() {
    function PanSession2(event, handlers, _a7) {
      var _this = this;
      var _b5 = _a7 === void 0 ? {} : _a7, transformPagePoint = _b5.transformPagePoint;
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.updatePoint = function() {
        if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))
          return;
        var info2 = getPanInfo(_this.lastMoveEventInfo, _this.history);
        var isPanStarted = _this.startEvent !== null;
        var isDistancePastThreshold = distance2(info2.offset, { x: 0, y: 0 }) >= 3;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        var point2 = info2.point;
        var timestamp2 = getFrameData2().timestamp;
        _this.history.push(__assign(__assign({}, point2), { timestamp: timestamp2 }));
        var _a8 = _this.handlers, onStart = _a8.onStart, onMove = _a8.onMove;
        if (!isPanStarted) {
          onStart && onStart(_this.lastMoveEvent, info2);
          _this.startEvent = _this.lastMoveEvent;
        }
        onMove && onMove(_this.lastMoveEvent, info2);
      };
      this.handlePointerMove = function(event2, info2) {
        _this.lastMoveEvent = event2;
        _this.lastMoveEventInfo = transformPoint(info2, _this.transformPagePoint);
        if (isMouseEvent(event2) && event2.buttons === 0) {
          _this.handlePointerUp(event2, info2);
          return;
        }
        es_default2.update(_this.updatePoint, true);
      };
      this.handlePointerUp = function(event2, info2) {
        _this.end();
        var _a8 = _this.handlers, onEnd = _a8.onEnd, onSessionEnd = _a8.onSessionEnd;
        var panInfo = getPanInfo(transformPoint(info2, _this.transformPagePoint), _this.history);
        if (_this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (isTouchEvent(event) && event.touches.length > 1)
        return;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      var info = extractEventInfo(event);
      var initialInfo = transformPoint(info, this.transformPagePoint);
      var point = initialInfo.point;
      var timestamp = getFrameData2().timestamp;
      this.history = [__assign(__assign({}, point), { timestamp })];
      var onSessionStart = handlers.onSessionStart;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe4(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
    }
    PanSession2.prototype.updateHandlers = function(handlers) {
      this.handlers = handlers;
    };
    PanSession2.prototype.end = function() {
      this.removeListeners && this.removeListeners();
      cancelSync2.update(this.updatePoint);
    };
    return PanSession2;
  }()
);
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo(_a7, history) {
  var point = _a7.point;
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity2(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity2(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  var i = history.length - 1;
  var timestampedPoint = null;
  var lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time === 0) {
    return { x: 0, y: 0 };
  }
  var currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  if (target === void 0) {
    target = 0;
  }
  if (maxDistance === void 0) {
    maxDistance = 0.01;
  }
  return distance2(value, target) < maxDistance;
}
function calcAxisDelta(delta, source, target, origin) {
  if (origin === void 0) {
    origin = 0.5;
  }
  delta.origin = origin;
  delta.originPoint = mix2(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix2(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);
  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}

// node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
function applyConstraints(point, _a7, elastic) {
  var min2 = _a7.min, max2 = _a7.max;
  if (min2 !== void 0 && point < min2) {
    point = elastic ? mix2(min2, point, elastic.min) : Math.max(point, min2);
  } else if (max2 !== void 0 && point > max2) {
    point = elastic ? mix2(max2, point, elastic.max) : Math.min(point, max2);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, _a7) {
  var top2 = _a7.top, left2 = _a7.left, bottom2 = _a7.bottom, right2 = _a7.right;
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left2, right2),
    y: calcRelativeAxisConstraints(layoutBox.y, top2, bottom2)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  var _a7;
  var min2 = constraintsAxis.min - layoutAxis.min;
  var max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    _a7 = __read([max2, min2], 2), min2 = _a7[0], max2 = _a7[1];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin2(source, target) {
  var origin = 0.5;
  var sourceLength = calcLength(source);
  var targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp2(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  var relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic) {
  if (dragElastic === void 0) {
    dragElastic = defaultElastic;
  }
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  var _a7;
  return typeof dragElastic === "number" ? dragElastic : (_a7 = dragElastic[label]) !== null && _a7 !== void 0 ? _a7 : 0;
}

// node_modules/framer-motion/dist/es/projection/geometry/models.mjs
var createAxisDelta = function() {
  return {
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  };
};
var createDelta = function() {
  return {
    x: createAxisDelta(),
    y: createAxisDelta()
  };
};
var createAxis = function() {
  return { min: 0, max: 0 };
};
var createBox = function() {
  return {
    x: createAxis(),
    y: createAxis()
  };
};

// node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}

// node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
function convertBoundingBoxToBox(_a7) {
  var top2 = _a7.top, left2 = _a7.left, right2 = _a7.right, bottom2 = _a7.bottom;
  return {
    x: { min: left2, max: right2 },
    y: { min: top2, max: bottom2 }
  };
}
function convertBoxToBoundingBox(_a7) {
  var x = _a7.x, y = _a7.y;
  return { top: y.min, right: x.max, bottom: y.max, left: x.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  var topLeft = transformPoint2({ x: point.left, y: point.top });
  var bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}

// node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale(_a7) {
  var scale2 = _a7.scale, scaleX = _a7.scaleX, scaleY = _a7.scaleY;
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || hasTranslate(values.x) || hasTranslate(values.y) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function hasTranslate(value) {
  return value && value !== "0%";
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
function scalePoint(point, scale2, originPoint) {
  var distanceFromOrigin = point - originPoint;
  var scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate, scale2, originPoint, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, _a7) {
  var x = _a7.x, y = _a7.y;
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {
  var _a7, _b5;
  if (isSharedTransition === void 0) {
    isSharedTransition = false;
  }
  var treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  var node2;
  var delta;
  for (var i = 0; i < treeLength; i++) {
    node2 = treePath[i];
    delta = node2.projectionDelta;
    if (((_b5 = (_a7 = node2.instance) === null || _a7 === void 0 ? void 0 : _a7.style) === null || _b5 === void 0 ? void 0 : _b5.display) === "contents")
      continue;
    if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
      transformBox(box, { x: -node2.scroll.x, y: -node2.scroll.y });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node2.latestValues)) {
      transformBox(box, node2.latestValues);
    }
  }
}
function translateAxis(axis, distance3) {
  axis.min = axis.min + distance3;
  axis.max = axis.max + distance3;
}
function transformAxis(axis, transforms2, _a7) {
  var _b5 = __read(_a7, 3), key = _b5[0], scaleKey = _b5[1], originKey = _b5[2];
  var axisOrigin = transforms2[originKey] !== void 0 ? transforms2[originKey] : 0.5;
  var originPoint = mix2(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms2[key], transforms2[scaleKey], originPoint, transforms2.scale);
}
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function transformBox(box, transform2) {
  transformAxis(box.x, transform2, xKeys);
  transformAxis(box.y, transform2, yKeys);
}

// node_modules/framer-motion/dist/es/projection/utils/measure.mjs
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  var viewportBox = measureViewportBox(element, transformPagePoint);
  var scroll2 = rootProjectionNode2.scroll;
  if (scroll2) {
    translateAxis(viewportBox.x, scroll2.x);
    translateAxis(viewportBox.y, scroll2.y);
  }
  return viewportBox;
}

// node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
var elementDragControls = /* @__PURE__ */ new WeakMap();
var VisualElementDragControls = (
  /** @class */
  function() {
    function VisualElementDragControls2(visualElement2) {
      this.openGlobalLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.visualElement = visualElement2;
    }
    VisualElementDragControls2.prototype.start = function(originEvent, _a7) {
      var _this = this;
      var _b5 = _a7 === void 0 ? {} : _a7, _c14 = _b5.snapToCursor, snapToCursor = _c14 === void 0 ? false : _c14;
      if (this.visualElement.isPresent === false)
        return;
      var onSessionStart = function(event) {
        _this.stopAnimation();
        if (snapToCursor) {
          _this.snapToCursor(extractEventInfo(event, "page").point);
        }
      };
      var onStart = function(event, info) {
        var _a8;
        var _b6 = _this.getProps(), drag2 = _b6.drag, dragPropagation = _b6.dragPropagation, onDragStart = _b6.onDragStart;
        if (drag2 && !dragPropagation) {
          if (_this.openGlobalLock)
            _this.openGlobalLock();
          _this.openGlobalLock = getGlobalLock(drag2);
          if (!_this.openGlobalLock)
            return;
        }
        _this.isDragging = true;
        _this.currentDirection = null;
        _this.resolveConstraints();
        if (_this.visualElement.projection) {
          _this.visualElement.projection.isAnimationBlocked = true;
          _this.visualElement.projection.target = void 0;
        }
        eachAxis(function(axis) {
          var _a9, _b7;
          var current = _this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            var measuredAxis = (_b7 = (_a9 = _this.visualElement.projection) === null || _a9 === void 0 ? void 0 : _a9.layout) === null || _b7 === void 0 ? void 0 : _b7.actual[axis];
            if (measuredAxis) {
              var length_1 = calcLength(measuredAxis);
              current = length_1 * (parseFloat(current) / 100);
            }
          }
          _this.originPoint[axis] = current;
        });
        onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);
        (_a8 = _this.visualElement.animationState) === null || _a8 === void 0 ? void 0 : _a8.setActive(AnimationType.Drag, true);
      };
      var onMove = function(event, info) {
        var _a8 = _this.getProps(), dragPropagation = _a8.dragPropagation, dragDirectionLock = _a8.dragDirectionLock, onDirectionLock = _a8.onDirectionLock, onDrag = _a8.onDrag;
        if (!dragPropagation && !_this.openGlobalLock)
          return;
        var offset3 = info.offset;
        if (dragDirectionLock && _this.currentDirection === null) {
          _this.currentDirection = getCurrentDirection(offset3);
          if (_this.currentDirection !== null) {
            onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(_this.currentDirection);
          }
          return;
        }
        _this.updateAxis("x", info.point, offset3);
        _this.updateAxis("y", info.point, offset3);
        _this.visualElement.syncRender();
        onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);
      };
      var onSessionEnd = function(event, info) {
        return _this.stop(event, info);
      };
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd
      }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
    };
    VisualElementDragControls2.prototype.stop = function(event, info) {
      var isDragging = this.isDragging;
      this.cancel();
      if (!isDragging)
        return;
      var velocity = info.velocity;
      this.startAnimation(velocity);
      var onDragEnd = this.getProps().onDragEnd;
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
    };
    VisualElementDragControls2.prototype.cancel = function() {
      var _a7, _b5;
      this.isDragging = false;
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = false;
      }
      (_a7 = this.panSession) === null || _a7 === void 0 ? void 0 : _a7.end();
      this.panSession = void 0;
      var dragPropagation = this.getProps().dragPropagation;
      if (!dragPropagation && this.openGlobalLock) {
        this.openGlobalLock();
        this.openGlobalLock = null;
      }
      (_b5 = this.visualElement.animationState) === null || _b5 === void 0 ? void 0 : _b5.setActive(AnimationType.Drag, false);
    };
    VisualElementDragControls2.prototype.updateAxis = function(axis, _point, offset3) {
      var drag2 = this.getProps().drag;
      if (!offset3 || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      var axisValue = this.getAxisMotionValue(axis);
      var next2 = this.originPoint[axis] + offset3[axis];
      if (this.constraints && this.constraints[axis]) {
        next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next2);
    };
    VisualElementDragControls2.prototype.resolveConstraints = function() {
      var _this = this;
      var _a7 = this.getProps(), dragConstraints = _a7.dragConstraints, dragElastic = _a7.dragElastic;
      var layout2 = (this.visualElement.projection || {}).layout;
      var prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout2) {
          this.constraints = calcRelativeConstraints(layout2.actual, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
        eachAxis(function(axis) {
          if (_this.getAxisMotionValue(axis)) {
            _this.constraints[axis] = rebaseAxisConstraints(layout2.actual[axis], _this.constraints[axis]);
          }
        });
      }
    };
    VisualElementDragControls2.prototype.resolveRefConstraints = function() {
      var _a7 = this.getProps(), constraints = _a7.dragConstraints, onMeasureDragConstraints = _a7.onMeasureDragConstraints;
      if (!constraints || !isRefObject(constraints))
        return false;
      var constraintsElement = constraints.current;
      invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
      var projection = this.visualElement.projection;
      if (!projection || !projection.layout)
        return false;
      var constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      var measuredConstraints = calcViewportConstraints(projection.layout.actual, constraintsBox);
      if (onMeasureDragConstraints) {
        var userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    };
    VisualElementDragControls2.prototype.startAnimation = function(velocity) {
      var _this = this;
      var _a7 = this.getProps(), drag2 = _a7.drag, dragMomentum = _a7.dragMomentum, dragElastic = _a7.dragElastic, dragTransition = _a7.dragTransition, dragSnapToOrigin = _a7.dragSnapToOrigin, onDragTransitionEnd = _a7.onDragTransitionEnd;
      var constraints = this.constraints || {};
      var momentumAnimations = eachAxis(function(axis) {
        var _a8;
        if (!shouldDrag(axis, drag2, _this.currentDirection)) {
          return;
        }
        var transition3 = (_a8 = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a8 !== void 0 ? _a8 : {};
        if (dragSnapToOrigin)
          transition3 = { min: 0, max: 0 };
        var bounceStiffness = dragElastic ? 200 : 1e6;
        var bounceDamping = dragElastic ? 40 : 1e7;
        var inertia2 = __assign(__assign({ type: "inertia", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness, bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition3);
        return _this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    };
    VisualElementDragControls2.prototype.startAxisValueAnimation = function(axis, transition3) {
      var axisValue = this.getAxisMotionValue(axis);
      return startAnimation(axis, axisValue, 0, transition3);
    };
    VisualElementDragControls2.prototype.stopAnimation = function() {
      var _this = this;
      eachAxis(function(axis) {
        return _this.getAxisMotionValue(axis).stop();
      });
    };
    VisualElementDragControls2.prototype.getAxisMotionValue = function(axis) {
      var _a7, _b5;
      var dragKey = "_drag" + axis.toUpperCase();
      var externalMotionValue = this.visualElement.getProps()[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b5 = (_a7 = this.visualElement.getProps().initial) === null || _a7 === void 0 ? void 0 : _a7[axis]) !== null && _b5 !== void 0 ? _b5 : 0);
    };
    VisualElementDragControls2.prototype.snapToCursor = function(point) {
      var _this = this;
      eachAxis(function(axis) {
        var drag2 = _this.getProps().drag;
        if (!shouldDrag(axis, drag2, _this.currentDirection))
          return;
        var projection = _this.visualElement.projection;
        var axisValue = _this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          var _a7 = projection.layout.actual[axis], min2 = _a7.min, max2 = _a7.max;
          axisValue.set(point[axis] - mix2(min2, max2, 0.5));
        }
      });
    };
    VisualElementDragControls2.prototype.scalePositionWithinConstraints = function() {
      var _this = this;
      var _a7;
      var _b5 = this.getProps(), drag2 = _b5.drag, dragConstraints = _b5.dragConstraints;
      var projection = this.visualElement.projection;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      var boxProgress = { x: 0, y: 0 };
      eachAxis(function(axis) {
        var axisValue = _this.getAxisMotionValue(axis);
        if (axisValue) {
          var latest = axisValue.get();
          boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, _this.constraints[axis]);
        }
      });
      var transformTemplate2 = this.visualElement.getProps().transformTemplate;
      this.visualElement.getInstance().style.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
      (_a7 = projection.root) === null || _a7 === void 0 ? void 0 : _a7.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis(function(axis) {
        if (!shouldDrag(axis, drag2, null))
          return;
        var axisValue = _this.getAxisMotionValue(axis);
        var _a8 = _this.constraints[axis], min2 = _a8.min, max2 = _a8.max;
        axisValue.set(mix2(min2, max2, boxProgress[axis]));
      });
    };
    VisualElementDragControls2.prototype.addListeners = function() {
      var _this = this;
      var _a7;
      elementDragControls.set(this.visualElement, this);
      var element = this.visualElement.getInstance();
      var stopPointerListener = addPointerEvent(element, "pointerdown", function(event) {
        var _a8 = _this.getProps(), drag2 = _a8.drag, _b5 = _a8.dragListener, dragListener = _b5 === void 0 ? true : _b5;
        drag2 && dragListener && _this.start(event);
      });
      var measureDragConstraints = function() {
        var dragConstraints = _this.getProps().dragConstraints;
        if (isRefObject(dragConstraints)) {
          _this.constraints = _this.resolveRefConstraints();
        }
      };
      var projection = this.visualElement.projection;
      var stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        (_a7 = projection.root) === null || _a7 === void 0 ? void 0 : _a7.updateScroll();
        projection.updateLayout();
      }
      measureDragConstraints();
      var stopResizeListener = addDomEvent(window, "resize", function() {
        return _this.scalePositionWithinConstraints();
      });
      projection.addEventListener("didUpdate", function(_a8) {
        var delta = _a8.delta, hasLayoutChanged = _a8.hasLayoutChanged;
        if (_this.isDragging && hasLayoutChanged) {
          eachAxis(function(axis) {
            var motionValue2 = _this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            _this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          _this.visualElement.syncRender();
        }
      });
      return function() {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
      };
    };
    VisualElementDragControls2.prototype.getProps = function() {
      var props = this.visualElement.getProps();
      var _a7 = props.drag, drag2 = _a7 === void 0 ? false : _a7, _b5 = props.dragDirectionLock, dragDirectionLock = _b5 === void 0 ? false : _b5, _c14 = props.dragPropagation, dragPropagation = _c14 === void 0 ? false : _c14, _d3 = props.dragConstraints, dragConstraints = _d3 === void 0 ? false : _d3, _e3 = props.dragElastic, dragElastic = _e3 === void 0 ? defaultElastic : _e3, _f3 = props.dragMomentum, dragMomentum = _f3 === void 0 ? true : _f3;
      return __assign(__assign({}, props), { drag: drag2, dragDirectionLock, dragPropagation, dragConstraints, dragElastic, dragMomentum });
    };
    return VisualElementDragControls2;
  }()
);
function shouldDrag(direction2, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction2) && (currentDirection === null || currentDirection === direction2);
}
function getCurrentDirection(offset3, lockThreshold) {
  if (lockThreshold === void 0) {
    lockThreshold = 10;
  }
  var direction2 = null;
  if (Math.abs(offset3.y) > lockThreshold) {
    direction2 = "y";
  } else if (Math.abs(offset3.x) > lockThreshold) {
    direction2 = "x";
  }
  return direction2;
}

// node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs
function useDrag(props) {
  var groupDragControls = props.dragControls, visualElement2 = props.visualElement;
  var dragControls = useConstant(function() {
    return new VisualElementDragControls(visualElement2);
  });
  (0, import_react49.useEffect)(function() {
    return groupDragControls && groupDragControls.subscribe(dragControls);
  }, [dragControls, groupDragControls]);
  (0, import_react49.useEffect)(function() {
    return dragControls.addListeners();
  }, [dragControls]);
}

// node_modules/framer-motion/dist/es/gestures/use-pan-gesture.mjs
var import_react50 = __toESM(require_react(), 1);
function usePanGesture(_a7) {
  var onPan = _a7.onPan, onPanStart = _a7.onPanStart, onPanEnd = _a7.onPanEnd, onPanSessionStart = _a7.onPanSessionStart, visualElement2 = _a7.visualElement;
  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  var panSession = (0, import_react50.useRef)(null);
  var transformPagePoint = (0, import_react50.useContext)(MotionConfigContext).transformPagePoint;
  var handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: function(event, info) {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  (0, import_react50.useEffect)(function() {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, {
      transformPagePoint
    });
  }
  usePointerEvent(visualElement2, "pointerdown", hasPanEvents && onPointerDown);
  useUnmountEffect(function() {
    return panSession.current && panSession.current.end();
  });
}

// node_modules/framer-motion/dist/es/motion/features/drag.mjs
var drag = {
  pan: makeRenderlessComponent(usePanGesture),
  drag: makeRenderlessComponent(useDrag)
};

// node_modules/framer-motion/dist/es/render/utils/lifecycles.mjs
var names = [
  "LayoutMeasure",
  "BeforeLayoutMeasure",
  "LayoutUpdate",
  "ViewportBoxUpdate",
  "Update",
  "Render",
  "AnimationComplete",
  "LayoutAnimationComplete",
  "AnimationStart",
  "LayoutAnimationStart",
  "SetAxisTarget",
  "Unmount"
];
function createLifecycles() {
  var managers = names.map(function() {
    return new SubscriptionManager();
  });
  var propSubscriptions = {};
  var lifecycles = {
    clearAllListeners: function() {
      return managers.forEach(function(manager) {
        return manager.clear();
      });
    },
    updatePropListeners: function(props) {
      names.forEach(function(name) {
        var _a7;
        var on = "on" + name;
        var propListener = props[on];
        (_a7 = propSubscriptions[name]) === null || _a7 === void 0 ? void 0 : _a7.call(propSubscriptions);
        if (propListener) {
          propSubscriptions[name] = lifecycles[on](propListener);
        }
      });
    }
  };
  managers.forEach(function(manager, i) {
    lifecycles["on" + names[i]] = function(handler) {
      return manager.add(handler);
    };
    lifecycles["notify" + names[i]] = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return manager.notify.apply(manager, __spreadArray([], __read(args), false));
    };
  });
  return lifecycles;
}

// node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
function updateMotionValuesFromProps(element, next2, prev2) {
  var _a7;
  for (var key in next2) {
    var nextValue = next2[key];
    var prevValue = prev2[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (true) {
        warnOnce(nextValue.version === "6.5.1", "Attempting to mix Framer Motion versions ".concat(nextValue.version, " with 6.5.1 may not work as expected."));
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        var existingValue = element.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        element.addValue(key, motionValue((_a7 = element.getStaticValue(key)) !== null && _a7 !== void 0 ? _a7 : nextValue));
      }
    }
  }
  for (var key in prev2) {
    if (next2[key] === void 0)
      element.removeValue(key);
  }
  return next2;
}

// node_modules/framer-motion/dist/es/render/index.mjs
var visualElement = function(_a7) {
  var _b5 = _a7.treeType, treeType = _b5 === void 0 ? "" : _b5, build = _a7.build, getBaseTarget = _a7.getBaseTarget, makeTargetAnimatable = _a7.makeTargetAnimatable, measureViewportBox2 = _a7.measureViewportBox, renderInstance = _a7.render, readValueFromInstance = _a7.readValueFromInstance, removeValueFromRenderState = _a7.removeValueFromRenderState, sortNodePosition = _a7.sortNodePosition, scrapeMotionValuesFromProps3 = _a7.scrapeMotionValuesFromProps;
  return function(_a8, options) {
    var parent = _a8.parent, props = _a8.props, presenceId = _a8.presenceId, blockInitialAnimation = _a8.blockInitialAnimation, visualState = _a8.visualState, shouldReduceMotion = _a8.shouldReduceMotion;
    if (options === void 0) {
      options = {};
    }
    var isMounted = false;
    var latestValues = visualState.latestValues, renderState = visualState.renderState;
    var instance;
    var lifecycles = createLifecycles();
    var values = /* @__PURE__ */ new Map();
    var valueSubscriptions = /* @__PURE__ */ new Map();
    var prevMotionValues = {};
    var baseTarget = __assign({}, latestValues);
    var removeFromVariantTree;
    function render() {
      if (!instance || !isMounted)
        return;
      triggerBuild();
      renderInstance(instance, renderState, props.style, element.projection);
    }
    function triggerBuild() {
      build(element, renderState, latestValues, options, props);
    }
    function update() {
      lifecycles.notifyUpdate(latestValues);
    }
    function bindToMotionValue(key2, value2) {
      var removeOnChange = value2.onChange(function(latestValue) {
        latestValues[key2] = latestValue;
        props.onUpdate && es_default2.update(update, false, true);
      });
      var removeOnRenderRequest = value2.onRenderRequest(element.scheduleRender);
      valueSubscriptions.set(key2, function() {
        removeOnChange();
        removeOnRenderRequest();
      });
    }
    var initialMotionValues = scrapeMotionValuesFromProps3(props);
    for (var key in initialMotionValues) {
      var value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
    var isControllingVariants = checkIfControllingVariants(props);
    var isVariantNode = checkIfVariantNode(props);
    var element = __assign(__assign({
      treeType,
      /**
       * This is a mirror of the internal instance prop, which keeps
       * VisualElement type-compatible with React's RefObject.
       */
      current: null,
      /**
       * The depth of this visual element within the visual element tree.
       */
      depth: parent ? parent.depth + 1 : 0,
      parent,
      children: /* @__PURE__ */ new Set(),
      /**
       *
       */
      presenceId,
      shouldReduceMotion,
      /**
       * If this component is part of the variant tree, it should track
       * any children that are also part of the tree. This is essentially
       * a shadow tree to simplify logic around how to stagger over children.
       */
      variantChildren: isVariantNode ? /* @__PURE__ */ new Set() : void 0,
      /**
       * Whether this instance is visible. This can be changed imperatively
       * by the projection tree, is analogous to CSS's visibility in that
       * hidden elements should take up layout, and needs enacting by the configured
       * render function.
       */
      isVisible: void 0,
      /**
       * Normally, if a component is controlled by a parent's variants, it can
       * rely on that ancestor to trigger animations further down the tree.
       * However, if a component is created after its parent is mounted, the parent
       * won't trigger that mount animation so the child needs to.
       *
       * TODO: This might be better replaced with a method isParentMounted
       */
      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
      /**
       * This can be set by AnimatePresence to force components that mount
       * at the same time as it to mount as if they have initial={false} set.
       */
      blockInitialAnimation,
      /**
       * Determine whether this component has mounted yet. This is mostly used
       * by variant children to determine whether they need to trigger their
       * own animations on mount.
       */
      isMounted: function() {
        return Boolean(instance);
      },
      mount: function(newInstance) {
        isMounted = true;
        instance = element.current = newInstance;
        if (element.projection) {
          element.projection.mount(newInstance);
        }
        if (isVariantNode && parent && !isControllingVariants) {
          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);
        }
        values.forEach(function(value2, key2) {
          return bindToMotionValue(key2, value2);
        });
        parent === null || parent === void 0 ? void 0 : parent.children.add(element);
        element.setProps(props);
      },
      /**
       *
       */
      unmount: function() {
        var _a9;
        (_a9 = element.projection) === null || _a9 === void 0 ? void 0 : _a9.unmount();
        cancelSync2.update(update);
        cancelSync2.render(render);
        valueSubscriptions.forEach(function(remove) {
          return remove();
        });
        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);
        lifecycles.clearAllListeners();
        instance = void 0;
        isMounted = false;
      },
      /**
       * Add a child visual element to our set of children.
       */
      addVariantChild: function(child) {
        var _a9;
        var closestVariantNode = element.getClosestVariantNode();
        if (closestVariantNode) {
          (_a9 = closestVariantNode.variantChildren) === null || _a9 === void 0 ? void 0 : _a9.add(child);
          return function() {
            return closestVariantNode.variantChildren.delete(child);
          };
        }
      },
      sortNodePosition: function(other) {
        if (!sortNodePosition || treeType !== other.treeType)
          return 0;
        return sortNodePosition(element.getInstance(), other.getInstance());
      },
      /**
       * Returns the closest variant node in the tree starting from
       * this visual element.
       */
      getClosestVariantNode: function() {
        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();
      },
      /**
       * Expose the latest layoutId prop.
       */
      getLayoutId: function() {
        return props.layoutId;
      },
      /**
       * Returns the current instance.
       */
      getInstance: function() {
        return instance;
      },
      /**
       * Get/set the latest static values.
       */
      getStaticValue: function(key2) {
        return latestValues[key2];
      },
      setStaticValue: function(key2, value2) {
        return latestValues[key2] = value2;
      },
      /**
       * Returns the latest motion value state. Currently only used to take
       * a snapshot of the visual element - perhaps this can return the whole
       * visual state
       */
      getLatestValues: function() {
        return latestValues;
      },
      /**
       * Set the visiblity of the visual element. If it's changed, schedule
       * a render to reflect these changes.
       */
      setVisibility: function(visibility) {
        if (element.isVisible === visibility)
          return;
        element.isVisible = visibility;
        element.scheduleRender();
      },
      /**
       * Make a target animatable by Popmotion. For instance, if we're
       * trying to animate width from 100px to 100vw we need to measure 100vw
       * in pixels to determine what we really need to animate to. This is also
       * pluggable to support Framer's custom value types like Color,
       * and CSS variables.
       */
      makeTargetAnimatable: function(target, canMutate) {
        if (canMutate === void 0) {
          canMutate = true;
        }
        return makeTargetAnimatable(element, target, props, canMutate);
      },
      /**
       * Measure the current viewport box with or without transforms.
       * Only measures axis-aligned boxes, rotate and skew must be manually
       * removed with a re-render to work.
       */
      measureViewportBox: function() {
        return measureViewportBox2(instance, props);
      },
      // Motion values ========================
      /**
       * Add a motion value and bind it to this visual element.
       */
      addValue: function(key2, value2) {
        if (element.hasValue(key2))
          element.removeValue(key2);
        values.set(key2, value2);
        latestValues[key2] = value2.get();
        bindToMotionValue(key2, value2);
      },
      /**
       * Remove a motion value and unbind any active subscriptions.
       */
      removeValue: function(key2) {
        var _a9;
        values.delete(key2);
        (_a9 = valueSubscriptions.get(key2)) === null || _a9 === void 0 ? void 0 : _a9();
        valueSubscriptions.delete(key2);
        delete latestValues[key2];
        removeValueFromRenderState(key2, renderState);
      },
      /**
       * Check whether we have a motion value for this key
       */
      hasValue: function(key2) {
        return values.has(key2);
      },
      /**
       * Get a motion value for this key. If called with a default
       * value, we'll create one if none exists.
       */
      getValue: function(key2, defaultValue) {
        var value2 = values.get(key2);
        if (value2 === void 0 && defaultValue !== void 0) {
          value2 = motionValue(defaultValue);
          element.addValue(key2, value2);
        }
        return value2;
      },
      /**
       * Iterate over our motion values.
       */
      forEachValue: function(callback) {
        return values.forEach(callback);
      },
      /**
       * If we're trying to animate to a previously unencountered value,
       * we need to check for it in our state and as a last resort read it
       * directly from the instance (which might have performance implications).
       */
      readValue: function(key2) {
        var _a9;
        return (_a9 = latestValues[key2]) !== null && _a9 !== void 0 ? _a9 : readValueFromInstance(instance, key2, options);
      },
      /**
       * Set the base target to later animate back to. This is currently
       * only hydrated on creation and when we first read a value.
       */
      setBaseTarget: function(key2, value2) {
        baseTarget[key2] = value2;
      },
      /**
       * Find the base target for a value thats been removed from all animation
       * props.
       */
      getBaseTarget: function(key2) {
        if (getBaseTarget) {
          var target = getBaseTarget(props, key2);
          if (target !== void 0 && !isMotionValue(target))
            return target;
        }
        return baseTarget[key2];
      }
    }, lifecycles), {
      /**
       * Build the renderer state based on the latest visual state.
       */
      build: function() {
        triggerBuild();
        return renderState;
      },
      /**
       * Schedule a render on the next animation frame.
       */
      scheduleRender: function() {
        es_default2.render(render, false, true);
      },
      /**
       * Synchronously fire render. It's prefered that we batch renders but
       * in many circumstances, like layout measurement, we need to run this
       * synchronously. However in those instances other measures should be taken
       * to batch reads/writes.
       */
      syncRender: render,
      /**
       * Update the provided props. Ensure any newly-added motion values are
       * added to our map, old ones removed, and listeners updated.
       */
      setProps: function(newProps) {
        if (newProps.transformTemplate || props.transformTemplate) {
          element.scheduleRender();
        }
        props = newProps;
        lifecycles.updatePropListeners(newProps);
        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps3(props), prevMotionValues);
      },
      getProps: function() {
        return props;
      },
      // Variants ==============================
      /**
       * Returns the variant definition with a given name.
       */
      getVariant: function(name) {
        var _a9;
        return (_a9 = props.variants) === null || _a9 === void 0 ? void 0 : _a9[name];
      },
      /**
       * Returns the defined default transition on this component.
       */
      getDefaultTransition: function() {
        return props.transition;
      },
      getTransformPagePoint: function() {
        return props.transformPagePoint;
      },
      /**
       * Used by child variant nodes to get the closest ancestor variant props.
       */
      getVariantContext: function(startAtParent) {
        if (startAtParent === void 0) {
          startAtParent = false;
        }
        if (startAtParent)
          return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
        if (!isControllingVariants) {
          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
          if (props.initial !== void 0) {
            context_1.initial = props.initial;
          }
          return context_1;
        }
        var context = {};
        for (var i = 0; i < numVariantProps; i++) {
          var name_1 = variantProps[i];
          var prop = props[name_1];
          if (isVariantLabel(prop) || prop === false) {
            context[name_1] = prop;
          }
        }
        return context;
      }
    });
    return element;
  };
};
var variantProps = __spreadArray(["initial"], __read(variantPriorityOrder), false);
var numVariantProps = variantProps.length;

// node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs
function isCSSVariable2(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  var match2 = cssVariableRegex.exec(current);
  if (!match2)
    return [,];
  var _a7 = __read(match2, 3), token2 = _a7[1], fallback = _a7[2];
  return [token2, fallback];
}
var maxDepth = 4;
function getVariableValue(current, element, depth) {
  if (depth === void 0) {
    depth = 1;
  }
  invariant(depth <= maxDepth, 'Max CSS variable fallback depth detected in property "'.concat(current, '". This may indicate a circular fallback dependency.'));
  var _a7 = __read(parseCSSVariable(current), 2), token2 = _a7[0], fallback = _a7[1];
  if (!token2)
    return;
  var resolved = window.getComputedStyle(element).getPropertyValue(token2);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable2(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement2, _a7, transitionEnd) {
  var _b5;
  var target = __rest(_a7, []);
  var element = visualElement2.getInstance();
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = __assign({}, transitionEnd);
  }
  visualElement2.forEachValue(function(value) {
    var current2 = value.get();
    if (!isCSSVariable2(current2))
      return;
    var resolved2 = getVariableValue(current2, element);
    if (resolved2)
      value.set(resolved2);
  });
  for (var key in target) {
    var current = target[key];
    if (!isCSSVariable2(current))
      continue;
    var resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (transitionEnd)
      (_b5 = transitionEnd[key]) !== null && _b5 !== void 0 ? _b5 : transitionEnd[key] = current;
  }
  return { target, transitionEnd };
}

// node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
var isPositionalKey = function(key) {
  return positionalKeys.has(key);
};
var hasPositionalKey = function(target) {
  return Object.keys(target).some(isPositionalKey);
};
var setAndResetVelocity = function(value, to) {
  value.set(to, false);
  value.set(to);
};
var isNumOrPxType = function(v) {
  return v === number || v === px2;
};
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
var getPosFromMatrix = function(matrix, pos) {
  return parseFloat(matrix.split(", ")[pos]);
};
var getTranslateFromMatrix = function(pos2, pos3) {
  return function(_bbox, _a7) {
    var transform2 = _a7.transform;
    if (transform2 === "none" || !transform2)
      return 0;
    var matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      var matrix = transform2.match(/^matrix\((.+)\)$/);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
};
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformProps.filter(function(key) {
  return !transformKeys.has(key);
});
function removeNonTranslationalTransform(visualElement2) {
  var removedTransforms = [];
  nonTranslationalTransformKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement2.syncRender();
  return removedTransforms;
}
var positionalValues = {
  // Dimensions
  width: function(_a7, _b5) {
    var x = _a7.x;
    var _c14 = _b5.paddingLeft, paddingLeft = _c14 === void 0 ? "0" : _c14, _d3 = _b5.paddingRight, paddingRight = _d3 === void 0 ? "0" : _d3;
    return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);
  },
  height: function(_a7, _b5) {
    var y = _a7.y;
    var _c14 = _b5.paddingTop, paddingTop = _c14 === void 0 ? "0" : _c14, _d3 = _b5.paddingBottom, paddingBottom = _d3 === void 0 ? "0" : _d3;
    return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);
  },
  top: function(_bbox, _a7) {
    var top2 = _a7.top;
    return parseFloat(top2);
  },
  left: function(_bbox, _a7) {
    var left2 = _a7.left;
    return parseFloat(left2);
  },
  bottom: function(_a7, _b5) {
    var y = _a7.y;
    var top2 = _b5.top;
    return parseFloat(top2) + (y.max - y.min);
  },
  right: function(_a7, _b5) {
    var x = _a7.x;
    var left2 = _b5.left;
    return parseFloat(left2) + (x.max - x.min);
  },
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
var convertChangedValueTypes = function(target, visualElement2, changedKeys) {
  var originBbox = visualElement2.measureViewportBox();
  var element = visualElement2.getInstance();
  var elementComputedStyle = getComputedStyle(element);
  var display = elementComputedStyle.display;
  var origin = {};
  if (display === "none") {
    visualElement2.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach(function(key) {
    origin[key] = positionalValues[key](originBbox, elementComputedStyle);
  });
  visualElement2.syncRender();
  var targetBbox = visualElement2.measureViewportBox();
  changedKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    setAndResetVelocity(value, origin[key]);
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
var checkAndConvertChangedValueTypes = function(visualElement2, target, origin, transitionEnd) {
  if (origin === void 0) {
    origin = {};
  }
  if (transitionEnd === void 0) {
    transitionEnd = {};
  }
  target = __assign({}, target);
  transitionEnd = __assign({}, transitionEnd);
  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  var removedTransformValues = [];
  var hasAttemptedToRemoveTransformValues = false;
  var changedValueTypeKeys = [];
  targetPositionalKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (!visualElement2.hasValue(key))
      return;
    var from2 = origin[key];
    var fromType = findDimensionValueType(from2);
    var to = target[key];
    var toType;
    if (isKeyframesTarget(to)) {
      var numKeyframes = to.length;
      var fromIndex = to[0] === null ? 1 : 0;
      from2 = to[fromIndex];
      fromType = findDimensionValueType(from2);
      for (var i = fromIndex; i < numKeyframes; i++) {
        if (!toType) {
          toType = findDimensionValueType(to[i]);
          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
        } else {
          invariant(findDimensionValueType(to[i]) === toType, "All keyframes must be of the same type");
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        var current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px2) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from2 === 0 || to === 0)) {
        if (from2 === 0) {
          value.set(toType.transform(from2));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement2);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        setAndResetVelocity(value, to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    var scrollY_1 = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    var convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(function(_a7) {
        var _b5 = __read(_a7, 2), key = _b5[0], value = _b5[1];
        visualElement2.getValue(key).set(value);
      });
    }
    visualElement2.syncRender();
    if (scrollY_1 !== null)
      window.scrollTo({ top: scrollY_1 });
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement2, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin, transitionEnd) : { target, transitionEnd };
}

// node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs
var parseDomVariant = function(visualElement2, target, origin, transitionEnd) {
  var resolved = resolveCSSVariables(visualElement2, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement2, target, origin, transitionEnd);
};

// node_modules/framer-motion/dist/es/render/html/visual-element.mjs
function getComputedStyle3(element) {
  return window.getComputedStyle(element);
}
var htmlConfig = {
  treeType: "dom",
  readValueFromInstance: function(domElement, key) {
    if (isTransformProp(key)) {
      var defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      var computedStyle = getComputedStyle3(domElement);
      return (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
    }
  },
  sortNodePosition: function(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  },
  getBaseTarget: function(props, key) {
    var _a7;
    return (_a7 = props.style) === null || _a7 === void 0 ? void 0 : _a7[key];
  },
  measureViewportBox: function(element, _a7) {
    var transformPagePoint = _a7.transformPagePoint;
    return measureViewportBox(element, transformPagePoint);
  },
  /**
   * Reset the transform on the current Element. This is called as part
   * of a batched process across the entire layout tree. To remove this write
   * cycle it'd be interesting to see if it's possible to "undo" all the current
   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms
   * works
   */
  resetTransform: function(element, domElement, props) {
    var transformTemplate2 = props.transformTemplate;
    domElement.style.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
    element.scheduleRender();
  },
  restoreTransform: function(instance, mutableState) {
    instance.style.transform = mutableState.style.transform;
  },
  removeValueFromRenderState: function(key, _a7) {
    var vars2 = _a7.vars, style = _a7.style;
    delete vars2[key];
    delete style[key];
  },
  /**
   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`
   * can be animated by Motion.
   */
  makeTargetAnimatable: function(element, _a7, _b5, isMounted) {
    var transformValues = _b5.transformValues;
    if (isMounted === void 0) {
      isMounted = true;
    }
    var transition3 = _a7.transition, transitionEnd = _a7.transitionEnd, target = __rest(_a7, ["transition", "transitionEnd"]);
    var origin = getOrigin(target, transition3 || {}, element);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(element, target, origin);
      var parsed = parseDomVariant(element, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return __assign({ transition: transition3, transitionEnd }, target);
  },
  scrapeMotionValuesFromProps,
  build: function(element, renderState, latestValues, options, props) {
    if (element.isVisible !== void 0) {
      renderState.style.visibility = element.isVisible ? "visible" : "hidden";
    }
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  },
  render: renderHTML
};
var htmlVisualElement = visualElement(htmlConfig);

// node_modules/framer-motion/dist/es/render/svg/visual-element.mjs
var svgVisualElement = visualElement(__assign(__assign({}, htmlConfig), { getBaseTarget: function(props, key) {
  return props[key];
}, readValueFromInstance: function(domElement, key) {
  var _a7;
  if (isTransformProp(key)) {
    return ((_a7 = getDefaultValueType(key)) === null || _a7 === void 0 ? void 0 : _a7.default) || 0;
  }
  key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
  return domElement.getAttribute(key);
}, scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, build: function(_element, renderState, latestValues, options, props) {
  buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);
}, render: renderSVG }));

// node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
var createDomVisualElement = function(Component2, options) {
  return isSVGComponent(Component2) ? svgVisualElement(options, { enableHardwareAcceleration: false }) : htmlVisualElement(options, { enableHardwareAcceleration: true });
};

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var import_react51 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
var correctBorderRadius = {
  correct: function(latest, node2) {
    if (!node2.target)
      return latest;
    if (typeof latest === "string") {
      if (px2.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    var x = pixelsToPercent(latest, node2.target.x);
    var y = pixelsToPercent(latest, node2.target.y);
    return "".concat(x, "% ").concat(y, "%");
  }
};

// node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
var varToken = "_$css";
var correctBoxShadow = {
  correct: function(latest, _a7) {
    var treeScale = _a7.treeScale, projectionDelta = _a7.projectionDelta;
    var original = latest;
    var containsCSSVariables = latest.includes("var(");
    var cssVariables = [];
    if (containsCSSVariables) {
      latest = latest.replace(cssVariableRegex, function(match2) {
        cssVariables.push(match2);
        return varToken;
      });
    }
    var shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    var template = complex.createTransformer(latest);
    var offset3 = typeof shadow[0] !== "number" ? 1 : 0;
    var xScale = projectionDelta.x.scale * treeScale.x;
    var yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset3] /= xScale;
    shadow[1 + offset3] /= yScale;
    var averageScale = mix2(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset3] === "number")
      shadow[2 + offset3] /= averageScale;
    if (typeof shadow[3 + offset3] === "number")
      shadow[3 + offset3] /= averageScale;
    var output = template(shadow);
    if (containsCSSVariables) {
      var i_1 = 0;
      output = output.replace(varToken, function() {
        var cssVariable = cssVariables[i_1];
        i_1++;
        return cssVariable;
      });
    }
    return output;
  }
};

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var MeasureLayoutWithContext = (
  /** @class */
  function(_super) {
    __extends(MeasureLayoutWithContext2, _super);
    function MeasureLayoutWithContext2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MeasureLayoutWithContext2.prototype.componentDidMount = function() {
      var _this = this;
      var _a7 = this.props, visualElement2 = _a7.visualElement, layoutGroup = _a7.layoutGroup, switchLayoutGroup = _a7.switchLayoutGroup, layoutId = _a7.layoutId;
      var projection = visualElement2.projection;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
          layoutGroup.group.add(projection);
        if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {
          switchLayoutGroup.register(projection);
        }
        projection.root.didUpdate();
        projection.addEventListener("animationComplete", function() {
          _this.safeToRemove();
        });
        projection.setOptions(__assign(__assign({}, projection.options), { onExitComplete: function() {
          return _this.safeToRemove();
        } }));
      }
      globalProjectionState.hasEverUpdated = true;
    };
    MeasureLayoutWithContext2.prototype.getSnapshotBeforeUpdate = function(prevProps) {
      var _this = this;
      var _a7 = this.props, layoutDependency = _a7.layoutDependency, visualElement2 = _a7.visualElement, drag2 = _a7.drag, isPresent2 = _a7.isPresent;
      var projection = visualElement2.projection;
      if (!projection)
        return null;
      projection.isPresent = isPresent2;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent2) {
        if (isPresent2) {
          projection.promote();
        } else if (!projection.relegate()) {
          es_default2.postRender(function() {
            var _a8;
            if (!((_a8 = projection.getStack()) === null || _a8 === void 0 ? void 0 : _a8.members.length)) {
              _this.safeToRemove();
            }
          });
        }
      }
      return null;
    };
    MeasureLayoutWithContext2.prototype.componentDidUpdate = function() {
      var projection = this.props.visualElement.projection;
      if (projection) {
        projection.root.didUpdate();
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      }
    };
    MeasureLayoutWithContext2.prototype.componentWillUnmount = function() {
      var _a7 = this.props, visualElement2 = _a7.visualElement, layoutGroup = _a7.layoutGroup, promoteContext = _a7.switchLayoutGroup;
      var projection = visualElement2.projection;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    };
    MeasureLayoutWithContext2.prototype.safeToRemove = function() {
      var safeToRemove = this.props.safeToRemove;
      safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();
    };
    MeasureLayoutWithContext2.prototype.render = function() {
      return null;
    };
    return MeasureLayoutWithContext2;
  }(import_react51.default.Component)
);
function MeasureLayout(props) {
  var _a7 = __read(usePresence(), 2), isPresent2 = _a7[0], safeToRemove = _a7[1];
  var layoutGroup = (0, import_react51.useContext)(LayoutGroupContext);
  return import_react51.default.createElement(MeasureLayoutWithContext, __assign({}, props, { layoutGroup, switchLayoutGroup: (0, import_react51.useContext)(SwitchLayoutGroupContext), isPresent: isPresent2, safeToRemove }));
}
var defaultScaleCorrectors = {
  borderRadius: __assign(__assign({}, correctBorderRadius), { applyTo: [
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ] }),
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};

// node_modules/framer-motion/dist/es/motion/features/layout/index.mjs
var layoutFeatures = {
  measureLayout: MeasureLayout
};

// node_modules/framer-motion/dist/es/animation/animate.mjs
function animate2(from2, to, transition3) {
  if (transition3 === void 0) {
    transition3 = {};
  }
  var value = isMotionValue(from2) ? from2 : motionValue(from2);
  startAnimation("", value, to, transition3);
  return {
    stop: function() {
      return value.stop();
    },
    isAnimating: function() {
      return value.isAnimating();
    }
  };
}

// node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
var borders2 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders2.length;
var asNumber = function(value) {
  return typeof value === "string" ? parseFloat(value) : value;
};
var isPx = function(value) {
  return typeof value === "number" || px2.test(value);
};
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  var _a7, _b5, _c14, _d3;
  if (shouldCrossfadeOpacity) {
    target.opacity = mix2(
      0,
      // (follow?.opacity as number) ?? 0,
      // TODO Reinstate this if only child
      (_a7 = lead.opacity) !== null && _a7 !== void 0 ? _a7 : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mix2((_b5 = follow.opacity) !== null && _b5 !== void 0 ? _b5 : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mix2((_c14 = follow.opacity) !== null && _c14 !== void 0 ? _c14 : 1, (_d3 = lead.opacity) !== null && _d3 !== void 0 ? _d3 : 1, progress2);
  }
  for (var i = 0; i < numBorders; i++) {
    var borderLabel = "border".concat(borders2[i], "Radius");
    var followRadius = getRadius(follow, borderLabel);
    var leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    var canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix2(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix2(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  var _a7;
  return (_a7 = values[radiusName]) !== null && _a7 !== void 0 ? _a7 : values.borderRadius;
}
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, linear);
function compress(min2, max2, easing) {
  return function(p) {
    if (p < min2)
      return 0;
    if (p > max2)
      return 1;
    return easing(progress(min2, max2, p));
  };
}

// node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate, scale2, origin, boxScale, originAxis, sourceAxis) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  if (origin === void 0) {
    origin = 0.5;
  }
  if (originAxis === void 0) {
    originAxis = axis;
  }
  if (sourceAxis === void 0) {
    sourceAxis = axis;
  }
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    var relativeProgress = mix2(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  var originPoint = mix2(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms2, _a7, origin, sourceAxis) {
  var _b5 = __read(_a7, 3), key = _b5[0], scaleKey = _b5[1], originKey = _b5[2];
  removeAxisDelta(axis, transforms2[key], transforms2[scaleKey], transforms2[originKey], transforms2.scale, origin, sourceAxis);
}
var xKeys2 = ["x", "scaleX", "originX"];
var yKeys2 = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms2, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms2, xKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);
  removeAxisTransforms(box.y, transforms2, yKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);
}

// node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a2, b2) {
  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;
}

// node_modules/framer-motion/dist/es/projection/shared/stack.mjs
var NodeStack = (
  /** @class */
  function() {
    function NodeStack2() {
      this.members = [];
    }
    NodeStack2.prototype.add = function(node2) {
      addUniqueItem(this.members, node2);
      node2.scheduleRender();
    };
    NodeStack2.prototype.remove = function(node2) {
      removeItem(this.members, node2);
      if (node2 === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node2 === this.lead) {
        var prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    };
    NodeStack2.prototype.relegate = function(node2) {
      var indexOfNode = this.members.findIndex(function(member2) {
        return node2 === member2;
      });
      if (indexOfNode === 0)
        return false;
      var prevLead;
      for (var i = indexOfNode; i >= 0; i--) {
        var member = this.members[i];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    };
    NodeStack2.prototype.promote = function(node2, preserveFollowOpacity) {
      var _a7;
      var prevLead = this.lead;
      if (node2 === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node2;
      node2.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node2.scheduleRender();
        node2.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node2.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node2.snapshot = prevLead.snapshot;
          node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
          node2.snapshot.isShared = true;
        }
        if ((_a7 = node2.root) === null || _a7 === void 0 ? void 0 : _a7.isUpdating) {
          node2.isLayoutDirty = true;
        }
        var crossfade = node2.options.crossfade;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    };
    NodeStack2.prototype.exitAnimationComplete = function() {
      this.members.forEach(function(node2) {
        var _a7, _b5, _c14, _d3, _e3;
        (_b5 = (_a7 = node2.options).onExitComplete) === null || _b5 === void 0 ? void 0 : _b5.call(_a7);
        (_e3 = (_c14 = node2.resumingFrom) === null || _c14 === void 0 ? void 0 : (_d3 = _c14.options).onExitComplete) === null || _e3 === void 0 ? void 0 : _e3.call(_d3);
      });
    };
    NodeStack2.prototype.scheduleRender = function() {
      this.members.forEach(function(node2) {
        node2.instance && node2.scheduleRender(false);
      });
    };
    NodeStack2.prototype.removeLeadSnapshot = function() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    };
    return NodeStack2;
  }()
);

// node_modules/framer-motion/dist/es/projection/styles/transform.mjs
var identityProjection = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";
function buildProjectionTransform(delta, treeScale, latestTransform) {
  var xTranslate = delta.x.translate / treeScale.x;
  var yTranslate = delta.y.translate / treeScale.y;
  var transform2 = "translate3d(".concat(xTranslate, "px, ").concat(yTranslate, "px, 0) ");
  transform2 += "scale(".concat(1 / treeScale.x, ", ").concat(1 / treeScale.y, ") ");
  if (latestTransform) {
    var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;
    if (rotate)
      transform2 += "rotate(".concat(rotate, "deg) ");
    if (rotateX)
      transform2 += "rotateX(".concat(rotateX, "deg) ");
    if (rotateY)
      transform2 += "rotateY(".concat(rotateY, "deg) ");
  }
  var elementScaleX = delta.x.scale * treeScale.x;
  var elementScaleY = delta.y.scale * treeScale.y;
  transform2 += "scale(".concat(elementScaleX, ", ").concat(elementScaleY, ")");
  return transform2 === identityProjection ? "none" : transform2;
}

// node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
var compareByDepth = function(a2, b2) {
  return a2.depth - b2.depth;
};

// node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
var FlatTree = (
  /** @class */
  function() {
    function FlatTree2() {
      this.children = [];
      this.isDirty = false;
    }
    FlatTree2.prototype.add = function(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.remove = function(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.forEach = function(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    };
    return FlatTree2;
  }()
);

// node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
var animationTarget = 1e3;
function createProjectionNode(_a7) {
  var attachResizeListener = _a7.attachResizeListener, defaultParent = _a7.defaultParent, measureScroll = _a7.measureScroll, checkIsScrollRoot = _a7.checkIsScrollRoot, resetTransform = _a7.resetTransform;
  return (
    /** @class */
    function() {
      function ProjectionNode(id2, latestValues, parent) {
        var _this = this;
        if (latestValues === void 0) {
          latestValues = {};
        }
        if (parent === void 0) {
          parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent();
        }
        this.children = /* @__PURE__ */ new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.potentialNodes = /* @__PURE__ */ new Map();
        this.checkUpdateFailed = function() {
          if (_this.isUpdating) {
            _this.isUpdating = false;
            _this.clearAllSnapshots();
          }
        };
        this.updateProjection = function() {
          _this.nodes.forEach(resolveTargetDelta);
          _this.nodes.forEach(calcProjection);
        };
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = /* @__PURE__ */ new Map();
        this.id = id2;
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? __spreadArray(__spreadArray([], __read(parent.path), false), [parent], false) : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        id2 && this.root.registerPotentialNode(id2, this);
        for (var i = 0; i < this.path.length; i++) {
          this.path[i].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      ProjectionNode.prototype.addEventListener = function(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      };
      ProjectionNode.prototype.notifyListeners = function(name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify.apply(subscriptionManager, __spreadArray([], __read(args), false));
      };
      ProjectionNode.prototype.hasListeners = function(name) {
        return this.eventHandlers.has(name);
      };
      ProjectionNode.prototype.registerPotentialNode = function(id2, node2) {
        this.potentialNodes.set(id2, node2);
      };
      ProjectionNode.prototype.mount = function(instance, isLayoutDirty) {
        var _this = this;
        var _a8;
        if (isLayoutDirty === void 0) {
          isLayoutDirty = false;
        }
        if (this.instance)
          return;
        this.isSVG = instance instanceof SVGElement && instance.tagName !== "svg";
        this.instance = instance;
        var _b5 = this.options, layoutId = _b5.layoutId, layout2 = _b5.layout, visualElement2 = _b5.visualElement;
        if (visualElement2 && !visualElement2.getInstance()) {
          visualElement2.mount(instance);
        }
        this.root.nodes.add(this);
        (_a8 = this.parent) === null || _a8 === void 0 ? void 0 : _a8.children.add(this);
        this.id && this.root.potentialNodes.delete(this.id);
        if (isLayoutDirty && (layout2 || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          var unblockTimeout_1;
          var resizeUnblockUpdate_1 = function() {
            return _this.root.updateBlockedByResize = false;
          };
          attachResizeListener(instance, function() {
            _this.root.updateBlockedByResize = true;
            clearTimeout(unblockTimeout_1);
            unblockTimeout_1 = window.setTimeout(resizeUnblockUpdate_1, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              _this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement2 && (layoutId || layout2)) {
          this.addEventListener("didUpdate", function(_a9) {
            var _b6, _c14, _d3, _e3, _f3;
            var delta = _a9.delta, hasLayoutChanged = _a9.hasLayoutChanged, hasRelativeTargetChanged = _a9.hasRelativeTargetChanged, newLayout = _a9.layout;
            if (_this.isTreeAnimationBlocked()) {
              _this.target = void 0;
              _this.relativeTarget = void 0;
              return;
            }
            var layoutTransition = (_c14 = (_b6 = _this.options.transition) !== null && _b6 !== void 0 ? _b6 : visualElement2.getDefaultTransition()) !== null && _c14 !== void 0 ? _c14 : defaultLayoutTransition;
            var _g3 = visualElement2.getProps(), onLayoutAnimationStart = _g3.onLayoutAnimationStart, onLayoutAnimationComplete = _g3.onLayoutAnimationComplete;
            var targetChanged = !_this.targetLayout || !boxEquals(_this.targetLayout, newLayout) || hasRelativeTargetChanged;
            var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
            if (((_d3 = _this.resumeFrom) === null || _d3 === void 0 ? void 0 : _d3.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !_this.currentAnimation)) {
              if (_this.resumeFrom) {
                _this.resumingFrom = _this.resumeFrom;
                _this.resumingFrom.resumingFrom = void 0;
              }
              _this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
              var animationOptions = __assign(__assign({}, getValueTransition(layoutTransition, "layout")), { onPlay: onLayoutAnimationStart, onComplete: onLayoutAnimationComplete });
              if (visualElement2.shouldReduceMotion) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              _this.startAnimation(animationOptions);
            } else {
              if (!hasLayoutChanged && _this.animationProgress === 0) {
                _this.finishAnimation();
              }
              _this.isLead() && ((_f3 = (_e3 = _this.options).onExitComplete) === null || _f3 === void 0 ? void 0 : _f3.call(_e3));
            }
            _this.targetLayout = newLayout;
          });
        }
      };
      ProjectionNode.prototype.unmount = function() {
        var _a8, _b5;
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        (_a8 = this.getStack()) === null || _a8 === void 0 ? void 0 : _a8.remove(this);
        (_b5 = this.parent) === null || _b5 === void 0 ? void 0 : _b5.children.delete(this);
        this.instance = void 0;
        cancelSync2.preRender(this.updateProjection);
      };
      ProjectionNode.prototype.blockUpdate = function() {
        this.updateManuallyBlocked = true;
      };
      ProjectionNode.prototype.unblockUpdate = function() {
        this.updateManuallyBlocked = false;
      };
      ProjectionNode.prototype.isUpdateBlocked = function() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      };
      ProjectionNode.prototype.isTreeAnimationBlocked = function() {
        var _a8;
        return this.isAnimationBlocked || ((_a8 = this.parent) === null || _a8 === void 0 ? void 0 : _a8.isTreeAnimationBlocked()) || false;
      };
      ProjectionNode.prototype.startUpdate = function() {
        var _a8;
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        (_a8 = this.nodes) === null || _a8 === void 0 ? void 0 : _a8.forEach(resetRotation);
      };
      ProjectionNode.prototype.willUpdate = function(shouldNotifyListeners) {
        var _a8, _b5, _c14;
        if (shouldNotifyListeners === void 0) {
          shouldNotifyListeners = true;
        }
        if (this.root.isUpdateBlocked()) {
          (_b5 = (_a8 = this.options).onExitComplete) === null || _b5 === void 0 ? void 0 : _b5.call(_a8);
          return;
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (var i = 0; i < this.path.length; i++) {
          var node2 = this.path[i];
          node2.shouldResetTransform = true;
          node2.updateScroll();
        }
        var _d3 = this.options, layoutId = _d3.layoutId, layout2 = _d3.layout;
        if (layoutId === void 0 && !layout2)
          return;
        var transformTemplate2 = (_c14 = this.options.visualElement) === null || _c14 === void 0 ? void 0 : _c14.getProps().transformTemplate;
        this.prevTransformTemplateValue = transformTemplate2 === null || transformTemplate2 === void 0 ? void 0 : transformTemplate2(this.latestValues, "");
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      };
      ProjectionNode.prototype.didUpdate = function() {
        var updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (!this.isUpdating)
          return;
        this.isUpdating = false;
        if (this.potentialNodes.size) {
          this.potentialNodes.forEach(mountNodeEarly);
          this.potentialNodes.clear();
        }
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
        this.clearAllSnapshots();
        flushSync2.update();
        flushSync2.preRender();
        flushSync2.render();
      };
      ProjectionNode.prototype.clearAllSnapshots = function() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      };
      ProjectionNode.prototype.scheduleUpdateProjection = function() {
        es_default2.preRender(this.updateProjection, false, true);
      };
      ProjectionNode.prototype.scheduleCheckAfterUnmount = function() {
        var _this = this;
        es_default2.postRender(function() {
          if (_this.isLayoutDirty) {
            _this.root.didUpdate();
          } else {
            _this.root.checkUpdateFailed();
          }
        });
      };
      ProjectionNode.prototype.updateSnapshot = function() {
        if (this.snapshot || !this.instance)
          return;
        var measured = this.measure();
        var layout2 = this.removeTransform(this.removeElementScroll(measured));
        roundBox(layout2);
        this.snapshot = {
          measured,
          layout: layout2,
          latestValues: {}
        };
      };
      ProjectionNode.prototype.updateLayout = function() {
        var _a8;
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (var i = 0; i < this.path.length; i++) {
            var node2 = this.path[i];
            node2.updateScroll();
          }
        }
        var measured = this.measure();
        roundBox(measured);
        var prevLayout = this.layout;
        this.layout = {
          measured,
          actual: this.removeElementScroll(measured)
        };
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.actual);
        (_a8 = this.options.visualElement) === null || _a8 === void 0 ? void 0 : _a8.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);
      };
      ProjectionNode.prototype.updateScroll = function() {
        if (this.options.layoutScroll && this.instance) {
          this.isScrollRoot = checkIsScrollRoot(this.instance);
          this.scroll = measureScroll(this.instance);
        }
      };
      ProjectionNode.prototype.resetTransform = function() {
        var _a8;
        if (!resetTransform)
          return;
        var isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
        var hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        var transformTemplate2 = (_a8 = this.options.visualElement) === null || _a8 === void 0 ? void 0 : _a8.getProps().transformTemplate;
        var transformTemplateValue = transformTemplate2 === null || transformTemplate2 === void 0 ? void 0 : transformTemplate2(this.latestValues, "");
        var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      };
      ProjectionNode.prototype.measure = function() {
        var visualElement2 = this.options.visualElement;
        if (!visualElement2)
          return createBox();
        var box = visualElement2.measureViewportBox();
        var scroll2 = this.root.scroll;
        if (scroll2) {
          translateAxis(box.x, scroll2.x);
          translateAxis(box.y, scroll2.y);
        }
        return box;
      };
      ProjectionNode.prototype.removeElementScroll = function(box) {
        var boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        for (var i = 0; i < this.path.length; i++) {
          var node2 = this.path[i];
          var scroll_1 = node2.scroll, options = node2.options, isScrollRoot = node2.isScrollRoot;
          if (node2 !== this.root && scroll_1 && options.layoutScroll) {
            if (isScrollRoot) {
              copyBoxInto(boxWithoutScroll, box);
              var rootScroll = this.root.scroll;
              if (rootScroll) {
                translateAxis(boxWithoutScroll.x, -rootScroll.x);
                translateAxis(boxWithoutScroll.y, -rootScroll.y);
              }
            }
            translateAxis(boxWithoutScroll.x, scroll_1.x);
            translateAxis(boxWithoutScroll.y, scroll_1.y);
          }
        }
        return boxWithoutScroll;
      };
      ProjectionNode.prototype.applyTransform = function(box, transformOnly) {
        if (transformOnly === void 0) {
          transformOnly = false;
        }
        var withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (var i = 0; i < this.path.length; i++) {
          var node2 = this.path[i];
          if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
            transformBox(withTransforms, {
              x: -node2.scroll.x,
              y: -node2.scroll.y
            });
          }
          if (!hasTransform(node2.latestValues))
            continue;
          transformBox(withTransforms, node2.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      };
      ProjectionNode.prototype.removeTransform = function(box) {
        var _a8;
        var boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (var i = 0; i < this.path.length; i++) {
          var node2 = this.path[i];
          if (!node2.instance)
            continue;
          if (!hasTransform(node2.latestValues))
            continue;
          hasScale(node2.latestValues) && node2.updateSnapshot();
          var sourceBox = createBox();
          var nodeBox = node2.measure();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node2.latestValues, (_a8 = node2.snapshot) === null || _a8 === void 0 ? void 0 : _a8.layout, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      };
      ProjectionNode.prototype.setTargetDelta = function(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
      };
      ProjectionNode.prototype.setOptions = function(options) {
        var _a8;
        this.options = __assign(__assign(__assign({}, this.options), options), { crossfade: (_a8 = options.crossfade) !== null && _a8 !== void 0 ? _a8 : true });
      };
      ProjectionNode.prototype.clearMeasurements = function() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      };
      ProjectionNode.prototype.resolveTargetDelta = function() {
        var _a8;
        var _b5 = this.options, layout2 = _b5.layout, layoutId = _b5.layoutId;
        if (!this.layout || !(layout2 || layoutId))
          return;
        if (!this.targetDelta && !this.relativeTarget) {
          this.relativeParent = this.getClosestProjectingParent();
          if (this.relativeParent && this.relativeParent.layout) {
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && ((_a8 = this.relativeParent) === null || _a8 === void 0 ? void 0 : _a8.target)) {
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.actual);
          } else {
            copyBoxInto(this.target, this.layout.actual);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.actual);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          this.relativeParent = this.getClosestProjectingParent();
          if (this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target) {
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          }
        }
      };
      ProjectionNode.prototype.getClosestProjectingParent = function() {
        if (!this.parent || hasTransform(this.parent.latestValues))
          return void 0;
        if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      };
      ProjectionNode.prototype.calcProjection = function() {
        var _a8;
        var _b5 = this.options, layout2 = _b5.layout, layoutId = _b5.layoutId;
        this.isTreeAnimating = Boolean(((_a8 = this.parent) === null || _a8 === void 0 ? void 0 : _a8.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout2 || layoutId))
          return;
        var lead = this.getLead();
        copyBoxInto(this.layoutCorrected, this.layout.actual);
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);
        var target = lead.target;
        if (!target)
          return;
        if (!this.projectionDelta) {
          this.projectionDelta = createDelta();
          this.projectionDeltaWithTransform = createDelta();
        }
        var prevTreeScaleX = this.treeScale.x;
        var prevTreeScaleY = this.treeScale.y;
        var prevProjectionTransform = this.projectionTransform;
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
        if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
      };
      ProjectionNode.prototype.hide = function() {
        this.isVisible = false;
      };
      ProjectionNode.prototype.show = function() {
        this.isVisible = true;
      };
      ProjectionNode.prototype.scheduleRender = function(notifyAll) {
        var _a8, _b5, _c14;
        if (notifyAll === void 0) {
          notifyAll = true;
        }
        (_b5 = (_a8 = this.options).scheduleRender) === null || _b5 === void 0 ? void 0 : _b5.call(_a8);
        notifyAll && ((_c14 = this.getStack()) === null || _c14 === void 0 ? void 0 : _c14.scheduleRender());
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      };
      ProjectionNode.prototype.setAnimationOrigin = function(delta, hasOnlyRelativeTargetChanged) {
        var _this = this;
        var _a8;
        if (hasOnlyRelativeTargetChanged === void 0) {
          hasOnlyRelativeTargetChanged = false;
        }
        var snapshot = this.snapshot;
        var snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};
        var mixedValues = __assign({}, this.latestValues);
        var targetDelta = createDelta();
        this.relativeTarget = this.relativeTargetOrigin = void 0;
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        var relativeLayout = createBox();
        var isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;
        var isOnlyMember = (((_a8 = this.getStack()) === null || _a8 === void 0 ? void 0 : _a8.members.length) || 0) <= 1;
        var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        this.mixTargetDelta = function(latest) {
          var _a9;
          var progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          _this.setTargetDelta(targetDelta);
          if (_this.relativeTarget && _this.relativeTargetOrigin && _this.layout && ((_a9 = _this.relativeParent) === null || _a9 === void 0 ? void 0 : _a9.layout)) {
            calcRelativePosition(relativeLayout, _this.layout.actual, _this.relativeParent.layout.actual);
            mixBox(_this.relativeTarget, _this.relativeTargetOrigin, relativeLayout, progress2);
          }
          if (isSharedLayoutAnimation) {
            _this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, _this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          _this.root.scheduleUpdateProjection();
          _this.scheduleRender();
          _this.animationProgress = progress2;
        };
        this.mixTargetDelta(0);
      };
      ProjectionNode.prototype.startAnimation = function(options) {
        var _this = this;
        var _a8, _b5;
        this.notifyListeners("animationStart");
        (_a8 = this.currentAnimation) === null || _a8 === void 0 ? void 0 : _a8.stop();
        if (this.resumingFrom) {
          (_b5 = this.resumingFrom.currentAnimation) === null || _b5 === void 0 ? void 0 : _b5.stop();
        }
        if (this.pendingAnimation) {
          cancelSync2.update(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = es_default2.update(function() {
          globalProjectionState.hasAnimatedSinceResize = true;
          _this.currentAnimation = animate2(0, animationTarget, __assign(__assign({}, options), { onUpdate: function(latest) {
            var _a9;
            _this.mixTargetDelta(latest);
            (_a9 = options.onUpdate) === null || _a9 === void 0 ? void 0 : _a9.call(options, latest);
          }, onComplete: function() {
            var _a9;
            (_a9 = options.onComplete) === null || _a9 === void 0 ? void 0 : _a9.call(options);
            _this.completeAnimation();
          } }));
          if (_this.resumingFrom) {
            _this.resumingFrom.currentAnimation = _this.currentAnimation;
          }
          _this.pendingAnimation = void 0;
        });
      };
      ProjectionNode.prototype.completeAnimation = function() {
        var _a8;
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        (_a8 = this.getStack()) === null || _a8 === void 0 ? void 0 : _a8.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      };
      ProjectionNode.prototype.finishAnimation = function() {
        var _a8;
        if (this.currentAnimation) {
          (_a8 = this.mixTargetDelta) === null || _a8 === void 0 ? void 0 : _a8.call(this, animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      };
      ProjectionNode.prototype.applyTransformsToTarget = function() {
        var _a8 = this.getLead(), targetWithTransforms = _a8.targetWithTransforms, target = _a8.target, layout2 = _a8.layout, latestValues = _a8.latestValues;
        if (!targetWithTransforms || !target || !layout2)
          return;
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      };
      ProjectionNode.prototype.registerSharedNode = function(layoutId, node2) {
        var _a8, _b5, _c14;
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        var stack = this.sharedNodes.get(layoutId);
        stack.add(node2);
        node2.promote({
          transition: (_a8 = node2.options.initialPromotionConfig) === null || _a8 === void 0 ? void 0 : _a8.transition,
          preserveFollowOpacity: (_c14 = (_b5 = node2.options.initialPromotionConfig) === null || _b5 === void 0 ? void 0 : _b5.shouldPreserveFollowOpacity) === null || _c14 === void 0 ? void 0 : _c14.call(_b5, node2)
        });
      };
      ProjectionNode.prototype.isLead = function() {
        var stack = this.getStack();
        return stack ? stack.lead === this : true;
      };
      ProjectionNode.prototype.getLead = function() {
        var _a8;
        var layoutId = this.options.layoutId;
        return layoutId ? ((_a8 = this.getStack()) === null || _a8 === void 0 ? void 0 : _a8.lead) || this : this;
      };
      ProjectionNode.prototype.getPrevLead = function() {
        var _a8;
        var layoutId = this.options.layoutId;
        return layoutId ? (_a8 = this.getStack()) === null || _a8 === void 0 ? void 0 : _a8.prevLead : void 0;
      };
      ProjectionNode.prototype.getStack = function() {
        var layoutId = this.options.layoutId;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      };
      ProjectionNode.prototype.promote = function(_a8) {
        var _b5 = _a8 === void 0 ? {} : _a8, needsReset = _b5.needsReset, transition3 = _b5.transition, preserveFollowOpacity = _b5.preserveFollowOpacity;
        var stack = this.getStack();
        if (stack)
          stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition3)
          this.setOptions({ transition: transition3 });
      };
      ProjectionNode.prototype.relegate = function() {
        var stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      };
      ProjectionNode.prototype.resetRotation = function() {
        var visualElement2 = this.options.visualElement;
        if (!visualElement2)
          return;
        var hasRotate = false;
        var resetValues = {};
        for (var i = 0; i < transformAxes.length; i++) {
          var axis = transformAxes[i];
          var key = "rotate" + axis;
          if (!visualElement2.getStaticValue(key)) {
            continue;
          }
          hasRotate = true;
          resetValues[key] = visualElement2.getStaticValue(key);
          visualElement2.setStaticValue(key, 0);
        }
        if (!hasRotate)
          return;
        visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
        for (var key in resetValues) {
          visualElement2.setStaticValue(key, resetValues[key]);
        }
        visualElement2.scheduleRender();
      };
      ProjectionNode.prototype.getProjectionStyles = function(styleProp) {
        var _a8, _b5, _c14, _d3, _e3, _f3;
        if (styleProp === void 0) {
          styleProp = {};
        }
        var styles3 = {};
        if (!this.instance || this.isSVG)
          return styles3;
        if (!this.isVisible) {
          return { visibility: "hidden" };
        } else {
          styles3.visibility = "";
        }
        var transformTemplate2 = (_a8 = this.options.visualElement) === null || _a8 === void 0 ? void 0 : _a8.getProps().transformTemplate;
        if (this.needsReset) {
          this.needsReset = false;
          styles3.opacity = "";
          styles3.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
          styles3.transform = transformTemplate2 ? transformTemplate2(this.latestValues, "") : "none";
          return styles3;
        }
        var lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          var emptyStyles = {};
          if (this.options.layoutId) {
            emptyStyles.opacity = (_b5 = this.latestValues.opacity) !== null && _b5 !== void 0 ? _b5 : 1;
            emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            emptyStyles.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
            this.hasProjected = false;
          }
          return emptyStyles;
        }
        var valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        styles3.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate2) {
          styles3.transform = transformTemplate2(valuesToRender, styles3.transform);
        }
        var _g3 = this.projectionDelta, x = _g3.x, y = _g3.y;
        styles3.transformOrigin = "".concat(x.origin * 100, "% ").concat(y.origin * 100, "% 0");
        if (lead.animationValues) {
          styles3.opacity = lead === this ? (_d3 = (_c14 = valuesToRender.opacity) !== null && _c14 !== void 0 ? _c14 : this.latestValues.opacity) !== null && _d3 !== void 0 ? _d3 : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          styles3.opacity = lead === this ? (_e3 = valuesToRender.opacity) !== null && _e3 !== void 0 ? _e3 : "" : (_f3 = valuesToRender.opacityExit) !== null && _f3 !== void 0 ? _f3 : 0;
        }
        for (var key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          var _h3 = scaleCorrectors[key], correct = _h3.correct, applyTo = _h3.applyTo;
          var corrected = correct(valuesToRender[key], lead);
          if (applyTo) {
            var num = applyTo.length;
            for (var i = 0; i < num; i++) {
              styles3[applyTo[i]] = corrected;
            }
          } else {
            styles3[key] = corrected;
          }
        }
        if (this.options.layoutId) {
          styles3.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
        }
        return styles3;
      };
      ProjectionNode.prototype.clearSnapshot = function() {
        this.resumeFrom = this.snapshot = void 0;
      };
      ProjectionNode.prototype.resetTree = function() {
        this.root.nodes.forEach(function(node2) {
          var _a8;
          return (_a8 = node2.currentAnimation) === null || _a8 === void 0 ? void 0 : _a8.stop();
        });
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      };
      return ProjectionNode;
    }()
  );
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  var _a7, _b5, _c14, _d3;
  var snapshot = (_b5 = (_a7 = node2.resumeFrom) === null || _a7 === void 0 ? void 0 : _a7.snapshot) !== null && _b5 !== void 0 ? _b5 : node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
    var _e3 = node2.layout, layout_1 = _e3.actual, measuredLayout = _e3.measured;
    if (node2.options.animationType === "size") {
      eachAxis(function(axis) {
        var axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];
        var length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout_1[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (node2.options.animationType === "position") {
      eachAxis(function(axis) {
        var axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];
        var length2 = calcLength(layout_1[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    }
    var layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout_1, snapshot.layout);
    var visualDelta = createDelta();
    if (snapshot.isShared) {
      calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot.measured);
    } else {
      calcBoxDelta(visualDelta, layout_1, snapshot.layout);
    }
    var hasLayoutChanged = !isDeltaZero(layoutDelta);
    var hasRelativeTargetChanged = false;
    if (!node2.resumeFrom) {
      node2.relativeParent = node2.getClosestProjectingParent();
      if (node2.relativeParent && !node2.relativeParent.resumeFrom) {
        var _f3 = node2.relativeParent, parentSnapshot = _f3.snapshot, parentLayout = _f3.layout;
        if (parentSnapshot && parentLayout) {
          var relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layout, parentSnapshot.layout);
          var relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout_1, parentLayout.actual);
          if (!boxEquals(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout_1,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node2.isLead()) {
    (_d3 = (_c14 = node2.options).onExitComplete) === null || _d3 === void 0 ? void 0 : _d3.call(_c14);
  }
  node2.options.transition = void 0;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function resetTransformStyle(node2) {
  var visualElement2 = node2.options.visualElement;
  if (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.getProps().onBeforeLayoutMeasure) {
    visualElement2.notifyBeforeLayoutMeasure();
  }
  node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation();
  node2.targetDelta = node2.relativeTarget = node2.target = void 0;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetRotation(node2) {
  node2.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
  output.translate = mix2(delta.translate, 0, p);
  output.scale = mix2(delta.scale, 1, p);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from2, to, p) {
  output.min = mix2(from2.min, to.min, p);
  output.max = mix2(from2.max, to.max, p);
}
function mixBox(output, from2, to, p) {
  mixAxis(output.x, from2.x, to.x, p);
  mixAxis(output.y, from2.y, to.y, p);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function mountNodeEarly(node2, id2) {
  var searchNode = node2.root;
  for (var i = node2.path.length - 1; i >= 0; i--) {
    if (Boolean(node2.path[i].instance)) {
      searchNode = node2.path[i];
      break;
    }
  }
  var searchElement = searchNode && searchNode !== node2.root ? searchNode.instance : document;
  var element = searchElement.querySelector('[data-projection-id="'.concat(id2, '"]'));
  if (element)
    node2.mount(element, true);
}
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}

// node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
var DocumentProjectionNode = createProjectionNode({
  attachResizeListener: function(ref, notify) {
    return addDomEvent(ref, "resize", notify);
  },
  measureScroll: function() {
    return {
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    };
  },
  checkIsScrollRoot: function() {
    return true;
  }
});

// node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
var rootProjectionNode = {
  current: void 0
};
var HTMLProjectionNode = createProjectionNode({
  measureScroll: function(instance) {
    return {
      x: instance.scrollLeft,
      y: instance.scrollTop
    };
  },
  defaultParent: function() {
    if (!rootProjectionNode.current) {
      var documentNode = new DocumentProjectionNode(0, {});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: function(instance, value) {
    instance.style.transform = value !== null && value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: function(instance) {
    return Boolean(window.getComputedStyle(instance).position === "fixed");
  }
});

// node_modules/framer-motion/dist/es/render/dom/motion.mjs
var featureBundle = __assign(__assign(__assign(__assign({}, animations), gestureAnimations), drag), layoutFeatures);
var motion = /* @__PURE__ */ createMotionProxy(function(Component2, config2) {
  return createDomMotionConfig(Component2, config2, featureBundle, createDomVisualElement, HTMLProjectionNode);
});

// node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var React9 = __toESM(require_react(), 1);
var import_react55 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-force-update.mjs
var import_react53 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs
var import_react52 = __toESM(require_react(), 1);
function useIsMounted() {
  var isMounted = (0, import_react52.useRef)(false);
  useIsomorphicLayoutEffect(function() {
    isMounted.current = true;
    return function() {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}

// node_modules/framer-motion/dist/es/utils/use-force-update.mjs
function useForceUpdate() {
  var isMounted = useIsMounted();
  var _a7 = __read((0, import_react53.useState)(0), 2), forcedRenderCount = _a7[0], setForcedRenderCount = _a7[1];
  var forceRender = (0, import_react53.useCallback)(function() {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  var deferredForceRender = (0, import_react53.useCallback)(function() {
    return es_default2.postRender(forceRender);
  }, [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}

// node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
var React8 = __toESM(require_react(), 1);
var import_react54 = __toESM(require_react(), 1);
var PresenceChild = function(_a7) {
  var children = _a7.children, initial = _a7.initial, isPresent2 = _a7.isPresent, onExitComplete = _a7.onExitComplete, custom = _a7.custom, presenceAffectsLayout = _a7.presenceAffectsLayout;
  var presenceChildren = useConstant(newChildrenMap);
  var id2 = useId();
  var context = (0, import_react54.useMemo)(
    function() {
      return {
        id: id2,
        initial,
        isPresent: isPresent2,
        custom,
        onExitComplete: function(childId) {
          var e_1, _a8;
          presenceChildren.set(childId, true);
          try {
            for (var _b5 = __values(presenceChildren.values()), _c14 = _b5.next(); !_c14.done; _c14 = _b5.next()) {
              var isComplete = _c14.value;
              if (!isComplete)
                return;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c14 && !_c14.done && (_a8 = _b5.return))
                _a8.call(_b5);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete();
        },
        register: function(childId) {
          presenceChildren.set(childId, false);
          return function() {
            return presenceChildren.delete(childId);
          };
        }
      };
    },
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent2]
  );
  (0, import_react54.useMemo)(function() {
    presenceChildren.forEach(function(_, key) {
      return presenceChildren.set(key, false);
    });
  }, [isPresent2]);
  React8.useEffect(function() {
    !isPresent2 && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());
  }, [isPresent2]);
  return React8.createElement(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}

// node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var getChildKey = function(child) {
  return child.key || "";
};
function updateChildLookup(children, allChildren) {
  children.forEach(function(child) {
    var key = getChildKey(child);
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  var filtered = [];
  import_react55.Children.forEach(children, function(child) {
    if ((0, import_react55.isValidElement)(child))
      filtered.push(child);
  });
  return filtered;
}
var AnimatePresence = function(_a7) {
  var children = _a7.children, custom = _a7.custom, _b5 = _a7.initial, initial = _b5 === void 0 ? true : _b5, onExitComplete = _a7.onExitComplete, exitBeforeEnter = _a7.exitBeforeEnter, _c14 = _a7.presenceAffectsLayout, presenceAffectsLayout = _c14 === void 0 ? true : _c14;
  var _d3 = __read(useForceUpdate(), 1), forceRender = _d3[0];
  var forceRenderLayoutGroup = (0, import_react55.useContext)(LayoutGroupContext).forceRender;
  if (forceRenderLayoutGroup)
    forceRender = forceRenderLayoutGroup;
  var isMounted = useIsMounted();
  var filteredChildren = onlyElements(children);
  var childrenToRender = filteredChildren;
  var exiting = /* @__PURE__ */ new Set();
  var presentChildren = (0, import_react55.useRef)(childrenToRender);
  var allChildren = (0, import_react55.useRef)(/* @__PURE__ */ new Map()).current;
  var isInitialRender = (0, import_react55.useRef)(true);
  useIsomorphicLayoutEffect(function() {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect(function() {
    isInitialRender.current = true;
    allChildren.clear();
    exiting.clear();
  });
  if (isInitialRender.current) {
    return React9.createElement(React9.Fragment, null, childrenToRender.map(function(child) {
      return React9.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout }, child);
    }));
  }
  childrenToRender = __spreadArray([], __read(childrenToRender), false);
  var presentKeys = presentChildren.current.map(getChildKey);
  var targetKeys = filteredChildren.map(getChildKey);
  var numPresent = presentKeys.length;
  for (var i = 0; i < numPresent; i++) {
    var key = presentKeys[i];
    if (targetKeys.indexOf(key) === -1) {
      exiting.add(key);
    }
  }
  if (exitBeforeEnter && exiting.size) {
    childrenToRender = [];
  }
  exiting.forEach(function(key2) {
    if (targetKeys.indexOf(key2) !== -1)
      return;
    var child = allChildren.get(key2);
    if (!child)
      return;
    var insertionIndex = presentKeys.indexOf(key2);
    var onExit = function() {
      allChildren.delete(key2);
      exiting.delete(key2);
      var removeIndex = presentChildren.current.findIndex(function(presentChild) {
        return presentChild.key === key2;
      });
      presentChildren.current.splice(removeIndex, 1);
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        if (isMounted.current === false)
          return;
        forceRender();
        onExitComplete && onExitComplete();
      }
    };
    childrenToRender.splice(insertionIndex, 0, React9.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout }, child));
  });
  childrenToRender = childrenToRender.map(function(child) {
    var key2 = child.key;
    return exiting.has(key2) ? child : React9.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout }, child);
  });
  if (env !== "production" && exitBeforeEnter && childrenToRender.length > 1) {
    console.warn("You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.");
  }
  return React9.createElement(React9.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function(child) {
    return (0, import_react55.cloneElement)(child);
  }));
};

// node_modules/@chakra-ui/toast/dist/chunk-VXESY33O.mjs
var import_react56 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
"use client";
var toastMotionVariants = {
  initial: (props) => {
    const { position: position3 } = props;
    const dir = ["top", "bottom"].includes(position3) ? "y" : "x";
    let factor = ["top-right", "bottom-right"].includes(position3) ? 1 : -1;
    if (position3 === "bottom")
      factor = 1;
    return {
      opacity: 0,
      [dir]: factor * 24
    };
  },
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.85,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
var ToastComponent = (0, import_react56.memo)((props) => {
  const {
    id: id2,
    message,
    onCloseComplete,
    onRequestRemove,
    requestClose = false,
    position: position3 = "bottom",
    duration = 5e3,
    containerStyle,
    motionVariants: motionVariants2 = toastMotionVariants,
    toastSpacing = "0.5rem"
  } = props;
  const [delay, setDelay] = (0, import_react56.useState)(duration);
  const isPresent2 = useIsPresent();
  useUpdateEffect(() => {
    if (!isPresent2) {
      onCloseComplete == null ? void 0 : onCloseComplete();
    }
  }, [isPresent2]);
  useUpdateEffect(() => {
    setDelay(duration);
  }, [duration]);
  const onMouseEnter = () => setDelay(null);
  const onMouseLeave = () => setDelay(duration);
  const close = () => {
    if (isPresent2)
      onRequestRemove();
  };
  (0, import_react56.useEffect)(() => {
    if (isPresent2 && requestClose) {
      onRequestRemove();
    }
  }, [isPresent2, requestClose, onRequestRemove]);
  useTimeout(close, delay);
  const containerStyles = (0, import_react56.useMemo)(
    () => ({
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: toastSpacing,
      ...containerStyle
    }),
    [containerStyle, toastSpacing]
  );
  const toastStyle = (0, import_react56.useMemo)(() => getToastStyle(position3), [position3]);
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    motion.div,
    {
      layout: true,
      className: "chakra-toast",
      variants: motionVariants2,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      onHoverStart: onMouseEnter,
      onHoverEnd: onMouseLeave,
      custom: { position: position3 },
      style: toastStyle,
      children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
        chakra.div,
        {
          role: "status",
          "aria-atomic": "true",
          className: "chakra-toast__inner",
          __css: containerStyles,
          children: runIfFn(message, { id: id2, onClose: close })
        }
      )
    }
  );
});
ToastComponent.displayName = "ToastComponent";

// node_modules/@chakra-ui/icon/dist/chunk-2GBDXOMA.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
"use client";
var fallbackIcon = {
  path: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      "path",
      {
        strokeLinecap: "round",
        fill: "none",
        d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      "path",
      {
        fill: "currentColor",
        strokeLinecap: "round",
        d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" })
  ] }),
  viewBox: "0 0 24 24"
};
var Icon = forwardRef3((props, ref) => {
  const {
    as: element,
    viewBox,
    color: color3 = "currentColor",
    focusable = false,
    children,
    className,
    __css,
    ...rest
  } = props;
  const _className = cx("chakra-icon", className);
  const customStyles = useStyleConfig("Icon", props);
  const styles3 = {
    w: "1em",
    h: "1em",
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: 0,
    color: color3,
    ...__css,
    ...customStyles
  };
  const shared = {
    ref,
    focusable,
    className: _className,
    __css: styles3
  };
  const _viewBox = viewBox != null ? viewBox : fallbackIcon.viewBox;
  if (element && typeof element !== "string") {
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(chakra.svg, { as: element, ...shared, ...rest });
  }
  const _path = children != null ? children : fallbackIcon.path;
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(chakra.svg, { verticalAlign: "middle", viewBox: _viewBox, ...shared, ...rest, children: _path });
});
Icon.displayName = "Icon";

// node_modules/@chakra-ui/icon/dist/index.mjs
"use client";

// node_modules/@chakra-ui/alert/dist/chunk-NEDBTDT2.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
"use client";
function CheckIcon(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
    }
  ) });
}
function InfoIcon(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
    }
  ) });
}
function WarningIcon(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
    }
  ) });
}

// node_modules/@chakra-ui/spinner/dist/chunk-5PH6ULNP.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
"use client";
var spin = keyframes({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
var Spinner = forwardRef3((props, ref) => {
  const styles3 = useStyleConfig("Spinner", props);
  const {
    label = "Loading...",
    thickness = "2px",
    speed = "0.45s",
    emptyColor = "transparent",
    className,
    ...rest
  } = omitThemingProps(props);
  const _className = cx("chakra-spinner", className);
  const spinnerStyles = {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderRadius: "99999px",
    borderWidth: thickness,
    borderBottomColor: emptyColor,
    borderLeftColor: emptyColor,
    animation: `${spin} ${speed} linear infinite`,
    ...styles3
  };
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
    chakra.div,
    {
      ref,
      __css: spinnerStyles,
      className: _className,
      ...rest,
      children: label && /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(chakra.span, { srOnly: true, children: label })
    }
  );
});
Spinner.displayName = "Spinner";

// node_modules/@chakra-ui/spinner/dist/index.mjs
"use client";

// node_modules/@chakra-ui/alert/dist/chunk-XCES3W5V.mjs
"use client";
var [AlertProvider, useAlertContext] = createContext2({
  name: "AlertContext",
  hookName: "useAlertContext",
  providerName: "<Alert />"
});
var [AlertStylesProvider, useAlertStyles] = createContext2({
  name: `AlertStylesContext`,
  hookName: `useAlertStyles`,
  providerName: "<Alert />"
});
var STATUSES = {
  info: { icon: InfoIcon, colorScheme: "blue" },
  warning: { icon: WarningIcon, colorScheme: "orange" },
  success: { icon: CheckIcon, colorScheme: "green" },
  error: { icon: WarningIcon, colorScheme: "red" },
  loading: { icon: Spinner, colorScheme: "blue" }
};
function getStatusColorScheme(status) {
  return STATUSES[status].colorScheme;
}
function getStatusIcon(status) {
  return STATUSES[status].icon;
}

// node_modules/@chakra-ui/alert/dist/chunk-CUKBNH6U.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
"use client";
var AlertDescription = forwardRef3(
  function AlertDescription2(props, ref) {
    const styles3 = useAlertStyles();
    const { status } = useAlertContext();
    const descriptionStyles = {
      display: "inline",
      ...styles3.description
    };
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      chakra.div,
      {
        ref,
        "data-status": status,
        ...props,
        className: cx("chakra-alert__desc", props.className),
        __css: descriptionStyles
      }
    );
  }
);
AlertDescription.displayName = "AlertDescription";

// node_modules/@chakra-ui/alert/dist/chunk-ALC6QPCI.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
"use client";
function AlertIcon(props) {
  const { status } = useAlertContext();
  const BaseIcon = getStatusIcon(status);
  const styles3 = useAlertStyles();
  const css4 = status === "loading" ? styles3.spinner : styles3.icon;
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
    chakra.span,
    {
      display: "inherit",
      "data-status": status,
      ...props,
      className: cx("chakra-alert__icon", props.className),
      __css: css4,
      children: props.children || /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(BaseIcon, { h: "100%", w: "100%" })
    }
  );
}
AlertIcon.displayName = "AlertIcon";

// node_modules/@chakra-ui/alert/dist/chunk-QURMB2UJ.mjs
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
"use client";
var AlertTitle = forwardRef3(
  function AlertTitle2(props, ref) {
    const styles3 = useAlertStyles();
    const { status } = useAlertContext();
    return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
      chakra.div,
      {
        ref,
        "data-status": status,
        ...props,
        className: cx("chakra-alert__title", props.className),
        __css: styles3.title
      }
    );
  }
);
AlertTitle.displayName = "AlertTitle";

// node_modules/@chakra-ui/alert/dist/chunk-3KCBMPN5.mjs
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
"use client";
var Alert = forwardRef3(function Alert2(props, ref) {
  var _a7;
  const { status = "info", addRole = true, ...rest } = omitThemingProps(props);
  const colorScheme = (_a7 = props.colorScheme) != null ? _a7 : getStatusColorScheme(status);
  const styles3 = useMultiStyleConfig("Alert", { ...props, colorScheme });
  const alertStyles = {
    width: "100%",
    display: "flex",
    alignItems: "center",
    position: "relative",
    overflow: "hidden",
    ...styles3.container
  };
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(AlertProvider, { value: { status }, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(AlertStylesProvider, { value: styles3, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
    chakra.div,
    {
      "data-status": status,
      role: addRole ? "alert" : void 0,
      ref,
      ...rest,
      className: cx("chakra-alert", props.className),
      __css: alertStyles
    }
  ) }) });
});
Alert.displayName = "Alert";

// node_modules/@chakra-ui/alert/dist/index.mjs
"use client";

// node_modules/@chakra-ui/close-button/dist/chunk-37N6GCLA.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
"use client";
function CloseIcon(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Icon, { focusable: "false", "aria-hidden": true, ...props, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
    }
  ) });
}
var CloseButton = forwardRef3(
  function CloseButton2(props, ref) {
    const styles3 = useStyleConfig("CloseButton", props);
    const { children, isDisabled: isDisabled2, __css, ...rest } = omitThemingProps(props);
    const baseStyle43 = {
      outline: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0
    };
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
      chakra.button,
      {
        type: "button",
        "aria-label": "Close",
        ref,
        disabled: isDisabled2,
        __css: {
          ...baseStyle43,
          ...styles3,
          ...__css
        },
        ...rest,
        children: children || /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(CloseIcon, { width: "1em", height: "1em" })
      }
    );
  }
);
CloseButton.displayName = "CloseButton";

// node_modules/@chakra-ui/close-button/dist/index.mjs
"use client";

// node_modules/@chakra-ui/toast/dist/chunk-HYCJNCPE.mjs
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
"use client";
var initialState = {
  top: [],
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  bottom: [],
  "bottom-right": []
};
var toastStore = createStore(initialState);
function createStore(initialState2) {
  let state2 = initialState2;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (setStateFn) => {
    state2 = setStateFn(state2);
    listeners.forEach((l) => l());
  };
  return {
    getState: () => state2,
    subscribe: (listener) => {
      listeners.add(listener);
      return () => {
        setState(() => initialState2);
        listeners.delete(listener);
      };
    },
    /**
     * Delete a toast record at its position
     */
    removeToast: (id2, position3) => {
      setState((prevState) => ({
        ...prevState,
        // id may be string or number
        // eslint-disable-next-line eqeqeq
        [position3]: prevState[position3].filter((toast) => toast.id != id2)
      }));
    },
    notify: (message, options) => {
      const toast = createToast(message, options);
      const { position: position3, id: id2 } = toast;
      setState((prevToasts) => {
        var _a7, _b5;
        const isTop = position3.includes("top");
        const toasts = isTop ? [toast, ...(_a7 = prevToasts[position3]) != null ? _a7 : []] : [...(_b5 = prevToasts[position3]) != null ? _b5 : [], toast];
        return {
          ...prevToasts,
          [position3]: toasts
        };
      });
      return id2;
    },
    update: (id2, options) => {
      if (!id2)
        return;
      setState((prevState) => {
        const nextState = { ...prevState };
        const { position: position3, index: index3 } = findToast(nextState, id2);
        if (position3 && index3 !== -1) {
          nextState[position3][index3] = {
            ...nextState[position3][index3],
            ...options,
            message: createRenderToast(options)
          };
        }
        return nextState;
      });
    },
    closeAll: ({ positions } = {}) => {
      setState((prev2) => {
        const allPositions = [
          "bottom",
          "bottom-right",
          "bottom-left",
          "top",
          "top-left",
          "top-right"
        ];
        const positionsToClose = positions != null ? positions : allPositions;
        return positionsToClose.reduce(
          (acc, position3) => {
            acc[position3] = prev2[position3].map((toast) => ({
              ...toast,
              requestClose: true
            }));
            return acc;
          },
          { ...prev2 }
        );
      });
    },
    close: (id2) => {
      setState((prevState) => {
        const position3 = getToastPosition(prevState, id2);
        if (!position3)
          return prevState;
        return {
          ...prevState,
          [position3]: prevState[position3].map((toast) => {
            if (toast.id == id2) {
              return {
                ...toast,
                requestClose: true
              };
            }
            return toast;
          })
        };
      });
    },
    isActive: (id2) => Boolean(findToast(toastStore.getState(), id2).position)
  };
}
var counter2 = 0;
function createToast(message, options = {}) {
  var _a7, _b5;
  counter2 += 1;
  const id2 = (_a7 = options.id) != null ? _a7 : counter2;
  const position3 = (_b5 = options.position) != null ? _b5 : "bottom";
  return {
    id: id2,
    message,
    position: position3,
    duration: options.duration,
    onCloseComplete: options.onCloseComplete,
    onRequestRemove: () => toastStore.removeToast(String(id2), position3),
    status: options.status,
    requestClose: false,
    containerStyle: options.containerStyle
  };
}
var Toast = (props) => {
  const {
    status,
    variant = "solid",
    id: id2,
    title,
    isClosable,
    onClose,
    description,
    colorScheme,
    icon
  } = props;
  const ids = id2 ? {
    root: `toast-${id2}`,
    title: `toast-${id2}-title`,
    description: `toast-${id2}-description`
  } : void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(
    Alert,
    {
      addRole: false,
      status,
      variant,
      id: ids == null ? void 0 : ids.root,
      alignItems: "start",
      borderRadius: "md",
      boxShadow: "lg",
      paddingEnd: 8,
      textAlign: "start",
      width: "auto",
      colorScheme,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(AlertIcon, { children: icon }),
        /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(chakra.div, { flex: "1", maxWidth: "100%", children: [
          title && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(AlertTitle, { id: ids == null ? void 0 : ids.title, children: title }),
          description && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(AlertDescription, { id: ids == null ? void 0 : ids.description, display: "block", children: description })
        ] }),
        isClosable && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          CloseButton,
          {
            size: "sm",
            onClick: onClose,
            position: "absolute",
            insetEnd: 1,
            top: 1
          }
        )
      ]
    }
  );
};
function createRenderToast(options = {}) {
  const { render, toastComponent: ToastComponent2 = Toast } = options;
  const renderToast = (props) => {
    if (typeof render === "function") {
      return render({ ...props, ...options });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(ToastComponent2, { ...props, ...options });
  };
  return renderToast;
}

// node_modules/@chakra-ui/toast/dist/chunk-3Y4YXCR2.mjs
var import_react57 = __toESM(require_react(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
"use client";
var [ToastOptionProvider, useToastOptionContext] = createContext2({
  name: `ToastOptionsContext`,
  strict: false
});
var ToastProvider = (props) => {
  const state2 = (0, import_react57.useSyncExternalStore)(
    toastStore.subscribe,
    toastStore.getState,
    toastStore.getState
  );
  const {
    motionVariants: motionVariants2,
    component: Component2 = ToastComponent,
    portalProps
  } = props;
  const stateKeys = Object.keys(state2);
  const toastList = stateKeys.map((position3) => {
    const toasts = state2[position3];
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      "div",
      {
        role: "region",
        "aria-live": "polite",
        "aria-label": `Notifications-${position3}`,
        id: `chakra-toast-manager-${position3}`,
        style: getToastListStyle(position3),
        children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(AnimatePresence, { initial: false, children: toasts.map((toast) => /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          Component2,
          {
            motionVariants: motionVariants2,
            ...toast
          },
          toast.id
        )) })
      },
      position3
    );
  });
  return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Portal, { ...portalProps, children: toastList });
};

// node_modules/@chakra-ui/toast/dist/index.mjs
"use client";

// node_modules/@chakra-ui/react/dist/chunk-QAITB7GG.mjs
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
"use client";
var createChakraProvider = (providerTheme) => {
  return function ChakraProvider22({
    children,
    theme: theme3 = providerTheme,
    toastOptions,
    ...restProps
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(ChakraProvider, { theme: theme3, ...restProps, children: [
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ToastOptionProvider, { value: toastOptions == null ? void 0 : toastOptions.defaultOptions, children }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ToastProvider, { ...toastOptions })
    ] });
  };
};
var ChakraProvider2 = createChakraProvider(theme);
var ChakraBaseProvider = createChakraProvider(baseTheme);

// node_modules/@chakra-ui/descendant/dist/chunk-3A5YOZDU.mjs
var import_react58 = __toESM(require_react(), 1);
"use client";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function sortNodes(nodes) {
  return nodes.sort((a2, b2) => {
    const compare = a2.compareDocumentPosition(b2);
    if (compare & Node.DOCUMENT_POSITION_FOLLOWING || compare & Node.DOCUMENT_POSITION_CONTAINED_BY) {
      return -1;
    }
    if (compare & Node.DOCUMENT_POSITION_PRECEDING || compare & Node.DOCUMENT_POSITION_CONTAINS) {
      return 1;
    }
    if (compare & Node.DOCUMENT_POSITION_DISCONNECTED || compare & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) {
      throw Error("Cannot sort the given nodes.");
    } else {
      return 0;
    }
  });
}
var isElement2 = (el) => typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
function getNextIndex2(current, max2, loop) {
  let next2 = current + 1;
  if (loop && next2 >= max2)
    next2 = 0;
  return next2;
}
function getPrevIndex(current, max2, loop) {
  let next2 = current - 1;
  if (loop && next2 < 0)
    next2 = max2;
  return next2;
}
var useSafeLayoutEffect2 = typeof window !== "undefined" ? import_react58.useLayoutEffect : import_react58.useEffect;
var cast = (value) => value;

// node_modules/@chakra-ui/descendant/dist/chunk-FT3H4P66.mjs
"use client";
var DescendantsManager = class {
  constructor() {
    __publicField(this, "descendants", /* @__PURE__ */ new Map());
    __publicField(this, "register", (nodeOrOptions) => {
      if (nodeOrOptions == null)
        return;
      if (isElement2(nodeOrOptions)) {
        return this.registerNode(nodeOrOptions);
      }
      return (node2) => {
        this.registerNode(node2, nodeOrOptions);
      };
    });
    __publicField(this, "unregister", (node2) => {
      this.descendants.delete(node2);
      const sorted = sortNodes(Array.from(this.descendants.keys()));
      this.assignIndex(sorted);
    });
    __publicField(this, "destroy", () => {
      this.descendants.clear();
    });
    __publicField(this, "assignIndex", (descendants) => {
      this.descendants.forEach((descendant) => {
        const index3 = descendants.indexOf(descendant.node);
        descendant.index = index3;
        descendant.node.dataset["index"] = descendant.index.toString();
      });
    });
    __publicField(this, "count", () => this.descendants.size);
    __publicField(this, "enabledCount", () => this.enabledValues().length);
    __publicField(this, "values", () => {
      const values = Array.from(this.descendants.values());
      return values.sort((a2, b2) => a2.index - b2.index);
    });
    __publicField(this, "enabledValues", () => {
      return this.values().filter((descendant) => !descendant.disabled);
    });
    __publicField(this, "item", (index3) => {
      if (this.count() === 0)
        return void 0;
      return this.values()[index3];
    });
    __publicField(this, "enabledItem", (index3) => {
      if (this.enabledCount() === 0)
        return void 0;
      return this.enabledValues()[index3];
    });
    __publicField(this, "first", () => this.item(0));
    __publicField(this, "firstEnabled", () => this.enabledItem(0));
    __publicField(this, "last", () => this.item(this.descendants.size - 1));
    __publicField(this, "lastEnabled", () => {
      const lastIndex = this.enabledValues().length - 1;
      return this.enabledItem(lastIndex);
    });
    __publicField(this, "indexOf", (node2) => {
      var _a7, _b5;
      if (!node2)
        return -1;
      return (_b5 = (_a7 = this.descendants.get(node2)) == null ? void 0 : _a7.index) != null ? _b5 : -1;
    });
    __publicField(this, "enabledIndexOf", (node2) => {
      if (node2 == null)
        return -1;
      return this.enabledValues().findIndex((i) => i.node.isSameNode(node2));
    });
    __publicField(this, "next", (index3, loop = true) => {
      const next2 = getNextIndex2(index3, this.count(), loop);
      return this.item(next2);
    });
    __publicField(this, "nextEnabled", (index3, loop = true) => {
      const item = this.item(index3);
      if (!item)
        return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const nextEnabledIndex = getNextIndex2(
        enabledIndex,
        this.enabledCount(),
        loop
      );
      return this.enabledItem(nextEnabledIndex);
    });
    __publicField(this, "prev", (index3, loop = true) => {
      const prev2 = getPrevIndex(index3, this.count() - 1, loop);
      return this.item(prev2);
    });
    __publicField(this, "prevEnabled", (index3, loop = true) => {
      const item = this.item(index3);
      if (!item)
        return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const prevEnabledIndex = getPrevIndex(
        enabledIndex,
        this.enabledCount() - 1,
        loop
      );
      return this.enabledItem(prevEnabledIndex);
    });
    __publicField(this, "registerNode", (node2, options) => {
      if (!node2 || this.descendants.has(node2))
        return;
      const keys2 = Array.from(this.descendants.keys()).concat(node2);
      const sorted = sortNodes(keys2);
      if (options == null ? void 0 : options.disabled) {
        options.disabled = !!options.disabled;
      }
      const descendant = { node: node2, index: -1, ...options };
      this.descendants.set(node2, descendant);
      this.assignIndex(sorted);
    });
  }
};

// node_modules/@chakra-ui/react-use-merge-refs/dist/index.mjs
var import_react59 = __toESM(require_react(), 1);
"use client";
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error2) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function mergeRefs(...refs) {
  return (node2) => {
    refs.forEach((ref) => {
      assignRef(ref, node2);
    });
  };
}
function useMergeRefs(...refs) {
  return (0, import_react59.useMemo)(() => mergeRefs(...refs), refs);
}

// node_modules/@chakra-ui/descendant/dist/chunk-OCNORRQU.mjs
var import_react60 = __toESM(require_react(), 1);
"use client";
function useDescendants() {
  const descendants = (0, import_react60.useRef)(new DescendantsManager());
  useSafeLayoutEffect2(() => {
    return () => descendants.current.destroy();
  });
  return descendants.current;
}
var [DescendantsContextProvider, useDescendantsContext] = createContext2({
  name: "DescendantsProvider",
  errorMessage: "useDescendantsContext must be used within DescendantsProvider"
});
function useDescendant(options) {
  const descendants = useDescendantsContext();
  const [index3, setIndex] = (0, import_react60.useState)(-1);
  const ref = (0, import_react60.useRef)(null);
  useSafeLayoutEffect2(() => {
    return () => {
      if (!ref.current)
        return;
      descendants.unregister(ref.current);
    };
  }, []);
  useSafeLayoutEffect2(() => {
    if (!ref.current)
      return;
    const dataIndex = Number(ref.current.dataset["index"]);
    if (index3 != dataIndex && !Number.isNaN(dataIndex)) {
      setIndex(dataIndex);
    }
  });
  const refCallback = options ? cast(descendants.register(options)) : cast(descendants.register);
  return {
    descendants,
    index: index3,
    enabledIndex: descendants.enabledIndexOf(ref.current),
    register: mergeRefs(refCallback, ref)
  };
}
function createDescendantContext() {
  const ContextProvider = cast(DescendantsContextProvider);
  const _useDescendantsContext = () => cast(useDescendantsContext());
  const _useDescendant = (options) => useDescendant(options);
  const _useDescendants = () => useDescendants();
  return [
    // context provider
    ContextProvider,
    // call this when you need to read from context
    _useDescendantsContext,
    // descendants state information, to be called and passed to `ContextProvider`
    _useDescendants,
    // descendant index information
    _useDescendant
  ];
}

// node_modules/@chakra-ui/descendant/dist/index.mjs
"use client";

// node_modules/@chakra-ui/react-children-utils/dist/index.mjs
var import_react61 = __toESM(require_react(), 1);
function getValidChildren(children) {
  return import_react61.Children.toArray(children).filter(
    (child) => (0, import_react61.isValidElement)(child)
  );
}

// node_modules/@chakra-ui/button/dist/chunk-T6ZDZOLO.mjs
"use client";
var [ButtonGroupProvider, useButtonGroup] = createContext2({
  strict: false,
  name: "ButtonGroupContext"
});

// node_modules/@chakra-ui/button/dist/chunk-DA7QIPTJ.mjs
var import_react62 = __toESM(require_react(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
"use client";
var attachedStyles = {
  horizontal: {
    "> *:first-of-type:not(:last-of-type)": { borderEndRadius: 0 },
    "> *:not(:first-of-type):not(:last-of-type)": { borderRadius: 0 },
    "> *:not(:first-of-type):last-of-type": { borderStartRadius: 0 }
  },
  vertical: {
    "> *:first-of-type:not(:last-of-type)": { borderBottomRadius: 0 },
    "> *:not(:first-of-type):not(:last-of-type)": { borderRadius: 0 },
    "> *:not(:first-of-type):last-of-type": { borderTopRadius: 0 }
  }
};
var gapStyles = {
  horizontal: (spacing2) => ({
    "& > *:not(style) ~ *:not(style)": { marginStart: spacing2 }
  }),
  vertical: (spacing2) => ({
    "& > *:not(style) ~ *:not(style)": { marginTop: spacing2 }
  })
};
var ButtonGroup = forwardRef3(
  function ButtonGroup2(props, ref) {
    const {
      size: size3,
      colorScheme,
      variant,
      className,
      spacing: spacing2 = "0.5rem",
      isAttached,
      isDisabled: isDisabled2,
      orientation = "horizontal",
      ...rest
    } = props;
    const _className = cx("chakra-button__group", className);
    const context = (0, import_react62.useMemo)(
      () => ({ size: size3, colorScheme, variant, isDisabled: isDisabled2 }),
      [size3, colorScheme, variant, isDisabled2]
    );
    let groupStyles = {
      display: "inline-flex",
      ...isAttached ? attachedStyles[orientation] : gapStyles[orientation](spacing2)
    };
    const isVertical = orientation === "vertical";
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(ButtonGroupProvider, { value: context, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
      chakra.div,
      {
        ref,
        role: "group",
        __css: groupStyles,
        className: _className,
        "data-attached": isAttached ? "" : void 0,
        "data-orientation": orientation,
        flexDir: isVertical ? "column" : void 0,
        ...rest
      }
    ) });
  }
);
ButtonGroup.displayName = "ButtonGroup";

// node_modules/@chakra-ui/button/dist/chunk-J37R6SZE.mjs
var import_react63 = __toESM(require_react(), 1);
"use client";
function useButtonType(value) {
  const [isButton, setIsButton] = (0, import_react63.useState)(!value);
  const refCallback = (0, import_react63.useCallback)((node2) => {
    if (!node2)
      return;
    setIsButton(node2.tagName === "BUTTON");
  }, []);
  const type = isButton ? "button" : void 0;
  return { ref: refCallback, type };
}

// node_modules/@chakra-ui/button/dist/chunk-3RENZ2UO.mjs
var import_react64 = __toESM(require_react(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
"use client";
function ButtonIcon(props) {
  const { children, className, ...rest } = props;
  const _children = (0, import_react64.isValidElement)(children) ? (0, import_react64.cloneElement)(children, {
    "aria-hidden": true,
    focusable: false
  }) : children;
  const _className = cx("chakra-button__icon", className);
  return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
    chakra.span,
    {
      display: "inline-flex",
      alignSelf: "center",
      flexShrink: 0,
      ...rest,
      className: _className,
      children: _children
    }
  );
}
ButtonIcon.displayName = "ButtonIcon";

// node_modules/@chakra-ui/button/dist/chunk-QB2Y5VKH.mjs
var import_react65 = __toESM(require_react(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
"use client";
function ButtonSpinner(props) {
  const {
    label,
    placement,
    spacing: spacing2 = "0.5rem",
    children = /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(Spinner, { color: "currentColor", width: "1em", height: "1em" }),
    className,
    __css,
    ...rest
  } = props;
  const _className = cx("chakra-button__spinner", className);
  const marginProp = placement === "start" ? "marginEnd" : "marginStart";
  const spinnerStyles = (0, import_react65.useMemo)(
    () => ({
      display: "flex",
      alignItems: "center",
      position: label ? "relative" : "absolute",
      [marginProp]: label ? spacing2 : 0,
      fontSize: "1em",
      lineHeight: "normal",
      ...__css
    }),
    [__css, label, marginProp, spacing2]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(chakra.div, { className: _className, ...rest, __css: spinnerStyles, children });
}
ButtonSpinner.displayName = "ButtonSpinner";

// node_modules/@chakra-ui/button/dist/chunk-UVUR7MCU.mjs
var import_react66 = __toESM(require_react(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
"use client";
var Button = forwardRef3((props, ref) => {
  const group = useButtonGroup();
  const styles3 = useStyleConfig("Button", { ...group, ...props });
  const {
    isDisabled: isDisabled2 = group == null ? void 0 : group.isDisabled,
    isLoading,
    isActive,
    children,
    leftIcon,
    rightIcon,
    loadingText,
    iconSpacing: iconSpacing2 = "0.5rem",
    type,
    spinner,
    spinnerPlacement = "start",
    className,
    as,
    ...rest
  } = omitThemingProps(props);
  const buttonStyles = (0, import_react66.useMemo)(() => {
    const _focus = { ...styles3 == null ? void 0 : styles3["_focus"], zIndex: 1 };
    return {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      position: "relative",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      outline: "none",
      ...styles3,
      ...!!group && { _focus }
    };
  }, [styles3, group]);
  const { ref: _ref, type: defaultType } = useButtonType(as);
  const contentProps = { rightIcon, leftIcon, iconSpacing: iconSpacing2, children };
  return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(
    chakra.button,
    {
      ref: useMergeRefs(ref, _ref),
      as,
      type: type != null ? type : defaultType,
      "data-active": dataAttr(isActive),
      "data-loading": dataAttr(isLoading),
      __css: buttonStyles,
      className: cx("chakra-button", className),
      ...rest,
      disabled: isDisabled2 || isLoading,
      children: [
        isLoading && spinnerPlacement === "start" && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
          ButtonSpinner,
          {
            className: "chakra-button__spinner--start",
            label: loadingText,
            placement: "start",
            spacing: iconSpacing2,
            children: spinner
          }
        ),
        isLoading ? loadingText || /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(chakra.span, { opacity: 0, children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ButtonContent, { ...contentProps }) }) : /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ButtonContent, { ...contentProps }),
        isLoading && spinnerPlacement === "end" && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
          ButtonSpinner,
          {
            className: "chakra-button__spinner--end",
            label: loadingText,
            placement: "end",
            spacing: iconSpacing2,
            children: spinner
          }
        )
      ]
    }
  );
});
Button.displayName = "Button";
function ButtonContent(props) {
  const { leftIcon, rightIcon, children, iconSpacing: iconSpacing2 } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(import_jsx_runtime23.Fragment, { children: [
    leftIcon && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ButtonIcon, { marginEnd: iconSpacing2, children: leftIcon }),
    children,
    rightIcon && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ButtonIcon, { marginStart: iconSpacing2, children: rightIcon })
  ] });
}

// node_modules/@chakra-ui/button/dist/index.mjs
"use client";

// node_modules/@chakra-ui/form-control/dist/chunk-DFWC5MHP.mjs
var import_react67 = __toESM(require_react(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
"use client";
var [FormControlStylesProvider, useFormControlStyles] = createContext2({
  name: `FormControlStylesContext`,
  errorMessage: `useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `
});
var [FormControlProvider, useFormControlContext] = createContext2({
  strict: false,
  name: "FormControlContext"
});
function useFormControlProvider(props) {
  const {
    id: idProp,
    isRequired,
    isInvalid,
    isDisabled: isDisabled2,
    isReadOnly,
    ...htmlProps
  } = props;
  const uuid = (0, import_react67.useId)();
  const id2 = idProp || `field-${uuid}`;
  const labelId = `${id2}-label`;
  const feedbackId = `${id2}-feedback`;
  const helpTextId = `${id2}-helptext`;
  const [hasFeedbackText, setHasFeedbackText] = (0, import_react67.useState)(false);
  const [hasHelpText, setHasHelpText] = (0, import_react67.useState)(false);
  const [isFocused, setFocus] = (0, import_react67.useState)(false);
  const getHelpTextProps = (0, import_react67.useCallback)(
    (props2 = {}, forwardedRef = null) => ({
      id: helpTextId,
      ...props2,
      /**
       * Notify the field context when the help text is rendered on screen,
       * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
       */
      ref: mergeRefs(forwardedRef, (node2) => {
        if (!node2)
          return;
        setHasHelpText(true);
      })
    }),
    [helpTextId]
  );
  const getLabelProps = (0, import_react67.useCallback)(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      "data-focus": dataAttr(isFocused),
      "data-disabled": dataAttr(isDisabled2),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly),
      id: props2.id !== void 0 ? props2.id : labelId,
      htmlFor: props2.htmlFor !== void 0 ? props2.htmlFor : id2
    }),
    [id2, isDisabled2, isFocused, isInvalid, isReadOnly, labelId]
  );
  const getErrorMessageProps = (0, import_react67.useCallback)(
    (props2 = {}, forwardedRef = null) => ({
      id: feedbackId,
      ...props2,
      /**
       * Notify the field context when the error message is rendered on screen,
       * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
       */
      ref: mergeRefs(forwardedRef, (node2) => {
        if (!node2)
          return;
        setHasFeedbackText(true);
      }),
      "aria-live": "polite"
    }),
    [feedbackId]
  );
  const getRootProps = (0, import_react67.useCallback)(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ...htmlProps,
      ref: forwardedRef,
      role: "group",
      "data-focus": dataAttr(isFocused),
      "data-disabled": dataAttr(isDisabled2),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly)
    }),
    [htmlProps, isDisabled2, isFocused, isInvalid, isReadOnly]
  );
  const getRequiredIndicatorProps = (0, import_react67.useCallback)(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      role: "presentation",
      "aria-hidden": true,
      children: props2.children || "*"
    }),
    []
  );
  return {
    isRequired: !!isRequired,
    isInvalid: !!isInvalid,
    isReadOnly: !!isReadOnly,
    isDisabled: !!isDisabled2,
    isFocused: !!isFocused,
    onFocus: () => setFocus(true),
    onBlur: () => setFocus(false),
    hasFeedbackText,
    setHasFeedbackText,
    hasHelpText,
    setHasHelpText,
    id: id2,
    labelId,
    feedbackId,
    helpTextId,
    htmlProps,
    getHelpTextProps,
    getErrorMessageProps,
    getRootProps,
    getLabelProps,
    getRequiredIndicatorProps
  };
}
var FormControl = forwardRef3(
  function FormControl2(props, ref) {
    const styles3 = useMultiStyleConfig("Form", props);
    const ownProps = omitThemingProps(props);
    const {
      getRootProps,
      htmlProps: _,
      ...context
    } = useFormControlProvider(ownProps);
    const className = cx("chakra-form-control", props.className);
    return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(FormControlProvider, { value: context, children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(FormControlStylesProvider, { value: styles3, children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
      chakra.div,
      {
        ...getRootProps({}, ref),
        className,
        __css: styles3["container"]
      }
    ) }) });
  }
);
FormControl.displayName = "FormControl";
var FormHelperText = forwardRef3(
  function FormHelperText2(props, ref) {
    const field = useFormControlContext();
    const styles3 = useFormControlStyles();
    const className = cx("chakra-form__helper-text", props.className);
    return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
      chakra.div,
      {
        ...field == null ? void 0 : field.getHelpTextProps(props, ref),
        __css: styles3.helperText,
        className
      }
    );
  }
);
FormHelperText.displayName = "FormHelperText";

// node_modules/@chakra-ui/form-control/dist/chunk-56K2BSAJ.mjs
"use client";
function useFormControl(props) {
  const { isDisabled: isDisabled2, isInvalid, isReadOnly, isRequired, ...rest } = useFormControlProps(props);
  return {
    ...rest,
    disabled: isDisabled2,
    readOnly: isReadOnly,
    required: isRequired,
    "aria-invalid": ariaAttr(isInvalid),
    "aria-required": ariaAttr(isRequired),
    "aria-readonly": ariaAttr(isReadOnly)
  };
}
function useFormControlProps(props) {
  var _a7, _b5, _c14;
  const field = useFormControlContext();
  const {
    id: id2,
    disabled,
    readOnly,
    required,
    isRequired,
    isInvalid,
    isReadOnly,
    isDisabled: isDisabled2,
    onFocus,
    onBlur,
    ...rest
  } = props;
  const labelIds = props["aria-describedby"] ? [props["aria-describedby"]] : [];
  if ((field == null ? void 0 : field.hasFeedbackText) && (field == null ? void 0 : field.isInvalid)) {
    labelIds.push(field.feedbackId);
  }
  if (field == null ? void 0 : field.hasHelpText) {
    labelIds.push(field.helpTextId);
  }
  return {
    ...rest,
    "aria-describedby": labelIds.join(" ") || void 0,
    id: id2 != null ? id2 : field == null ? void 0 : field.id,
    isDisabled: (_a7 = disabled != null ? disabled : isDisabled2) != null ? _a7 : field == null ? void 0 : field.isDisabled,
    isReadOnly: (_b5 = readOnly != null ? readOnly : isReadOnly) != null ? _b5 : field == null ? void 0 : field.isReadOnly,
    isRequired: (_c14 = required != null ? required : isRequired) != null ? _c14 : field == null ? void 0 : field.isRequired,
    isInvalid: isInvalid != null ? isInvalid : field == null ? void 0 : field.isInvalid,
    onFocus: callAllHandlers(field == null ? void 0 : field.onFocus, onFocus),
    onBlur: callAllHandlers(field == null ? void 0 : field.onBlur, onBlur)
  };
}

// node_modules/@chakra-ui/form-control/dist/index.mjs
"use client";

// node_modules/@chakra-ui/react-use-event-listener/dist/index.mjs
var import_react68 = __toESM(require_react(), 1);
"use client";
function useEventListener(target, event, handler, options) {
  const listener = useCallbackRef(handler);
  (0, import_react68.useEffect)(() => {
    const node2 = typeof target === "function" ? target() : target != null ? target : document;
    if (!handler || !node2)
      return;
    node2.addEventListener(event, listener, options);
    return () => {
      node2.removeEventListener(event, listener, options);
    };
  }, [event, target, options, listener, handler]);
  return () => {
    const node2 = typeof target === "function" ? target() : target != null ? target : document;
    node2 == null ? void 0 : node2.removeEventListener(event, listener, options);
  };
}

// node_modules/@chakra-ui/react-use-focus-on-pointer-down/dist/index.mjs
"use client";
function isRefObject2(val) {
  return "current" in val;
}
var isDom = () => typeof window !== "undefined";
function getPlatform() {
  var _a7;
  const agent = navigator.userAgentData;
  return (_a7 = agent == null ? void 0 : agent.platform) != null ? _a7 : navigator.platform;
}
var vn = (v) => isDom() && v.test(navigator.vendor);
var pt = (v) => isDom() && v.test(getPlatform());
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isSafari = () => isApple() && vn(/apple/i);
function useFocusOnPointerDown(props) {
  const { ref, elements, enabled } = props;
  const doc = () => {
    var _a7, _b5;
    return (_b5 = (_a7 = ref.current) == null ? void 0 : _a7.ownerDocument) != null ? _b5 : document;
  };
  useEventListener(doc, "pointerdown", (event) => {
    if (!isSafari() || !enabled)
      return;
    const target = event.target;
    const els = elements != null ? elements : [ref];
    const isValidTarget = els.some((elementOrRef) => {
      const el = isRefObject2(elementOrRef) ? elementOrRef.current : elementOrRef;
      return (el == null ? void 0 : el.contains(target)) || el === target;
    });
    if (doc().activeElement !== target && isValidTarget) {
      event.preventDefault();
      target.focus();
    }
  });
}

// node_modules/@chakra-ui/dom-utils/dist/chunk-3XANSPY5.mjs
function isElement3(el) {
  return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
}
function isHTMLElement2(el) {
  var _a7;
  if (!isElement3(el))
    return false;
  const win = (_a7 = el.ownerDocument.defaultView) != null ? _a7 : window;
  return el instanceof win.HTMLElement;
}
function getOwnerWindow(node2) {
  var _a7, _b5;
  return (_b5 = (_a7 = getOwnerDocument(node2)) == null ? void 0 : _a7.defaultView) != null ? _b5 : window;
}
function getOwnerDocument(node2) {
  return isElement3(node2) ? node2.ownerDocument : document;
}
function getActiveElement(node2) {
  return getOwnerDocument(node2).activeElement;
}

// node_modules/@chakra-ui/dom-utils/dist/chunk-ROURZMX4.mjs
var hasTabIndex = (element) => element.hasAttribute("tabindex");
var hasNegativeTabIndex = (element) => hasTabIndex(element) && element.tabIndex === -1;
function isDisabled(element) {
  return Boolean(element.getAttribute("disabled")) === true || Boolean(element.getAttribute("aria-disabled")) === true;
}
function isHidden(element) {
  if (element.parentElement && isHidden(element.parentElement))
    return true;
  return element.hidden;
}
function isContentEditable(element) {
  const value = element.getAttribute("contenteditable");
  return value !== "false" && value != null;
}
function isFocusable(element) {
  if (!isHTMLElement2(element) || isHidden(element) || isDisabled(element)) {
    return false;
  }
  const { localName } = element;
  const focusableTags = ["input", "select", "textarea", "button"];
  if (focusableTags.indexOf(localName) >= 0)
    return true;
  const others2 = {
    a: () => element.hasAttribute("href"),
    audio: () => element.hasAttribute("controls"),
    video: () => element.hasAttribute("controls")
  };
  if (localName in others2) {
    return others2[localName]();
  }
  if (isContentEditable(element))
    return true;
  return hasTabIndex(element);
}
function isTabbable(element) {
  if (!element)
    return false;
  return isHTMLElement2(element) && isFocusable(element) && !hasNegativeTabIndex(element);
}

// node_modules/@chakra-ui/dom-utils/dist/index.mjs
var focusableElList = [
  "input:not(:disabled):not([disabled])",
  "select:not(:disabled):not([disabled])",
  "textarea:not(:disabled):not([disabled])",
  "embed",
  "iframe",
  "object",
  "a[href]",
  "area[href]",
  "button:not(:disabled):not([disabled])",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  "*[tabindex]:not([aria-disabled])",
  "*[contenteditable]"
];
var focusableElSelector = focusableElList.join();
var isVisible = (el) => el.offsetWidth > 0 && el.offsetHeight > 0;
function getAllFocusable(container2) {
  const focusableEls = Array.from(
    container2.querySelectorAll(focusableElSelector)
  );
  focusableEls.unshift(container2);
  return focusableEls.filter((el) => isFocusable(el) && isVisible(el));
}

// node_modules/@chakra-ui/input/dist/chunk-FKYN3ZGE.mjs
var import_react69 = __toESM(require_react(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
"use client";
var [InputGroupStylesProvider, useInputGroupStyles] = createContext2({
  name: `InputGroupStylesContext`,
  errorMessage: `useInputGroupStyles returned is 'undefined'. Seems you forgot to wrap the components in "<InputGroup />" `
});
var InputGroup = forwardRef3(
  function InputGroup2(props, ref) {
    const styles3 = useMultiStyleConfig("Input", props);
    const { children, className, ...rest } = omitThemingProps(props);
    const _className = cx("chakra-input__group", className);
    const groupStyles = {};
    const validChildren = getValidChildren(children);
    const input = styles3.field;
    validChildren.forEach((child) => {
      var _a7, _b5;
      if (!styles3)
        return;
      if (input && child.type.id === "InputLeftElement") {
        groupStyles.paddingStart = (_a7 = input.height) != null ? _a7 : input.h;
      }
      if (input && child.type.id === "InputRightElement") {
        groupStyles.paddingEnd = (_b5 = input.height) != null ? _b5 : input.h;
      }
      if (child.type.id === "InputRightAddon") {
        groupStyles.borderEndRadius = 0;
      }
      if (child.type.id === "InputLeftAddon") {
        groupStyles.borderStartRadius = 0;
      }
    });
    const clones = validChildren.map((child) => {
      var _a7, _b5;
      const theming = compact({
        size: ((_a7 = child.props) == null ? void 0 : _a7.size) || props.size,
        variant: ((_b5 = child.props) == null ? void 0 : _b5.variant) || props.variant
      });
      return child.type.id !== "Input" ? (0, import_react69.cloneElement)(child, theming) : (0, import_react69.cloneElement)(child, Object.assign(theming, groupStyles, child.props));
    });
    return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
      chakra.div,
      {
        className: _className,
        ref,
        __css: {
          width: "100%",
          display: "flex",
          position: "relative",
          // Parts of inputs override z-index to ensure that they stack correctly on each other
          // Create a new stacking context so that these overrides don't leak out and conflict with other z-indexes
          isolation: "isolate",
          ...styles3.group
        },
        "data-group": true,
        ...rest,
        children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(InputGroupStylesProvider, { value: styles3, children: clones })
      }
    );
  }
);
InputGroup.displayName = "InputGroup";

// node_modules/@chakra-ui/input/dist/chunk-2ZHRCML3.mjs
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
"use client";
var StyledInputElement = chakra("div", {
  baseStyle: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    top: "0",
    zIndex: 2
  }
});
var InputElement = forwardRef3(function InputElement2(props, ref) {
  var _a7, _b5;
  const { placement = "left", ...rest } = props;
  const styles3 = useInputGroupStyles();
  const input = styles3.field;
  const attr2 = placement === "left" ? "insetStart" : "insetEnd";
  const elementStyles = {
    [attr2]: "0",
    width: (_a7 = input == null ? void 0 : input.height) != null ? _a7 : input == null ? void 0 : input.h,
    height: (_b5 = input == null ? void 0 : input.height) != null ? _b5 : input == null ? void 0 : input.h,
    fontSize: input == null ? void 0 : input.fontSize,
    ...styles3.element
  };
  return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(StyledInputElement, { ref, __css: elementStyles, ...rest });
});
InputElement.id = "InputElement";
InputElement.displayName = "InputElement";
var InputLeftElement = forwardRef3(
  function InputLeftElement2(props, ref) {
    const { className, ...rest } = props;
    const _className = cx("chakra-input__left-element", className);
    return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      InputElement,
      {
        ref,
        placement: "left",
        className: _className,
        ...rest
      }
    );
  }
);
InputLeftElement.id = "InputLeftElement";
InputLeftElement.displayName = "InputLeftElement";
var InputRightElement = forwardRef3(
  function InputRightElement2(props, ref) {
    const { className, ...rest } = props;
    const _className = cx("chakra-input__right-element", className);
    return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      InputElement,
      {
        ref,
        placement: "right",
        className: _className,
        ...rest
      }
    );
  }
);
InputRightElement.id = "InputRightElement";
InputRightElement.displayName = "InputRightElement";

// node_modules/@chakra-ui/input/dist/chunk-6CVSDS6C.mjs
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
"use client";
var Input = forwardRef3(function Input2(props, ref) {
  const { htmlSize, ...rest } = props;
  const styles3 = useMultiStyleConfig("Input", rest);
  const ownProps = omitThemingProps(rest);
  const input = useFormControl(ownProps);
  const _className = cx("chakra-input", props.className);
  return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
    chakra.input,
    {
      size: htmlSize,
      ...input,
      __css: styles3.field,
      ref,
      className: _className
    }
  );
});
Input.displayName = "Input";
Input.id = "Input";

// node_modules/@chakra-ui/input/dist/index.mjs
"use client";

// node_modules/@chakra-ui/breakpoint-utils/dist/chunk-G72KV6MB.mjs
var breakpoints2 = Object.freeze([
  "base",
  "sm",
  "md",
  "lg",
  "xl",
  "2xl"
]);
function mapResponsive(prop, mapper) {
  if (Array.isArray(prop)) {
    return prop.map((item) => item === null ? null : mapper(item));
  }
  if (isObject(prop)) {
    return Object.keys(prop).reduce((result, key) => {
      result[key] = mapper(prop[key]);
      return result;
    }, {});
  }
  if (prop != null) {
    return mapper(prop);
  }
  return null;
}

// node_modules/@chakra-ui/layout/dist/chunk-2OOHT3W5.mjs
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
"use client";
var Text = forwardRef3(function Text2(props, ref) {
  const styles3 = useStyleConfig("Text", props);
  const { className, align, decoration, casing, ...rest } = omitThemingProps(props);
  const aliasedProps = compact({
    textAlign: props.align,
    textDecoration: props.decoration,
    textTransform: props.casing
  });
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
    chakra.p,
    {
      ref,
      className: cx("chakra-text", props.className),
      ...aliasedProps,
      ...rest,
      __css: styles3
    }
  );
});
Text.displayName = "Text";

// node_modules/@chakra-ui/layout/dist/chunk-ZFQCCYWD.mjs
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
"use client";
var StackItem = (props) => /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
  chakra.div,
  {
    className: "chakra-stack__item",
    ...props,
    __css: {
      display: "inline-block",
      flex: "0 0 auto",
      minWidth: 0,
      ...props["__css"]
    }
  }
);
StackItem.displayName = "StackItem";

// node_modules/@chakra-ui/layout/dist/chunk-5VJV6UNA.mjs
"use client";
function getDividerStyles(options) {
  const { spacing: spacing2, direction: direction2 } = options;
  const dividerStyles = {
    column: {
      my: spacing2,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    "column-reverse": {
      my: spacing2,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    row: {
      mx: spacing2,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    },
    "row-reverse": {
      mx: spacing2,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    }
  };
  return {
    "&": mapResponsive(
      direction2,
      (value) => dividerStyles[value]
    )
  };
}

// node_modules/@chakra-ui/layout/dist/chunk-ZHMYA64R.mjs
var import_react70 = __toESM(require_react(), 1);
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
"use client";
var Stack = forwardRef3((props, ref) => {
  const {
    isInline,
    direction: directionProp,
    align,
    justify,
    spacing: spacing2 = "0.5rem",
    wrap: wrap2,
    children,
    divider,
    className,
    shouldWrapChildren,
    ...rest
  } = props;
  const direction2 = isInline ? "row" : directionProp != null ? directionProp : "column";
  const dividerStyle = (0, import_react70.useMemo)(
    () => getDividerStyles({ spacing: spacing2, direction: direction2 }),
    [spacing2, direction2]
  );
  const hasDivider = !!divider;
  const shouldUseChildren = !shouldWrapChildren && !hasDivider;
  const clones = (0, import_react70.useMemo)(() => {
    const validChildren = getValidChildren(children);
    return shouldUseChildren ? validChildren : validChildren.map((child, index3) => {
      const key = typeof child.key !== "undefined" ? child.key : index3;
      const isLast = index3 + 1 === validChildren.length;
      const wrappedChild = /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(StackItem, { children: child }, key);
      const _child = shouldWrapChildren ? wrappedChild : child;
      if (!hasDivider)
        return _child;
      const clonedDivider = (0, import_react70.cloneElement)(
        divider,
        {
          __css: dividerStyle
        }
      );
      const _divider = isLast ? null : clonedDivider;
      return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(import_react70.Fragment, { children: [
        _child,
        _divider
      ] }, key);
    });
  }, [
    divider,
    dividerStyle,
    hasDivider,
    shouldUseChildren,
    shouldWrapChildren,
    children
  ]);
  const _className = cx("chakra-stack", className);
  return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
    chakra.div,
    {
      ref,
      display: "flex",
      alignItems: align,
      justifyContent: justify,
      flexDirection: direction2,
      flexWrap: wrap2,
      gap: hasDivider ? void 0 : spacing2,
      className: _className,
      ...rest,
      children: clones
    }
  );
});
Stack.displayName = "Stack";

// node_modules/@chakra-ui/layout/dist/chunk-NTCQBYKE.mjs
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
"use client";
var VStack = forwardRef3((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Stack, { align: "center", ...props, direction: "column", ref }));
VStack.displayName = "VStack";

// node_modules/@chakra-ui/layout/dist/chunk-3ASUQ6PA.mjs
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
"use client";
var HStack = forwardRef3((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Stack, { align: "center", ...props, direction: "row", ref }));
HStack.displayName = "HStack";

// node_modules/@chakra-ui/layout/dist/chunk-PULVB27S.mjs
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
"use client";
var Box = chakra("div");
Box.displayName = "Box";
var Square = forwardRef3(function Square2(props, ref) {
  const { size: size3, centerContent = true, ...rest } = props;
  const styles3 = centerContent ? { display: "flex", alignItems: "center", justifyContent: "center" } : {};
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
    Box,
    {
      ref,
      boxSize: size3,
      __css: {
        ...styles3,
        flexShrink: 0,
        flexGrow: 0
      },
      ...rest
    }
  );
});
Square.displayName = "Square";
var Circle = forwardRef3(function Circle2(props, ref) {
  const { size: size3, ...rest } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Square, { size: size3, ref, borderRadius: "9999px", ...rest });
});
Circle.displayName = "Circle";

// node_modules/@chakra-ui/layout/dist/chunk-FAWTVNS3.mjs
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
"use client";
var Center = chakra("div", {
  baseStyle: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }
});
Center.displayName = "Center";
var centerStyles = {
  horizontal: {
    insetStart: "50%",
    transform: "translateX(-50%)"
  },
  vertical: {
    top: "50%",
    transform: "translateY(-50%)"
  },
  both: {
    insetStart: "50%",
    top: "50%",
    transform: "translate(-50%, -50%)"
  }
};
var AbsoluteCenter = forwardRef3(
  function AbsoluteCenter2(props, ref) {
    const { axis = "both", ...rest } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      chakra.div,
      {
        ref,
        __css: centerStyles[axis],
        ...rest,
        position: "absolute"
      }
    );
  }
);

// node_modules/@chakra-ui/layout/dist/chunk-KRPLQIP4.mjs
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
"use client";
var Flex = forwardRef3(function Flex2(props, ref) {
  const { direction: direction2, align, justify, wrap: wrap2, basis, grow, shrink, ...rest } = props;
  const styles3 = {
    display: "flex",
    flexDirection: direction2,
    alignItems: align,
    justifyContent: justify,
    flexWrap: wrap2,
    flexBasis: basis,
    flexGrow: grow,
    flexShrink: shrink
  };
  return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(chakra.div, { ref, __css: styles3, ...rest });
});
Flex.displayName = "Flex";

// node_modules/@chakra-ui/layout/dist/index.mjs
"use client";

// node_modules/@chakra-ui/menu/dist/chunk-YSKACL7R.mjs
var import_react71 = __toESM(require_react(), 1);
"use client";
function isPrintableCharacter(event) {
  const { key } = event;
  return key.length === 1 || key.length > 1 && /[^a-zA-Z0-9]/.test(key);
}
function useShortcut(props = {}) {
  const { timeout = 300, preventDefault = () => true } = props;
  const [keys2, setKeys] = (0, import_react71.useState)([]);
  const timeoutRef = (0, import_react71.useRef)();
  const flush = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  };
  const clearKeysAfterDelay = () => {
    flush();
    timeoutRef.current = setTimeout(() => {
      setKeys([]);
      timeoutRef.current = null;
    }, timeout);
  };
  (0, import_react71.useEffect)(() => flush, []);
  function onKeyDown(fn2) {
    return (event) => {
      if (event.key === "Backspace") {
        const keysCopy = [...keys2];
        keysCopy.pop();
        setKeys(keysCopy);
        return;
      }
      if (isPrintableCharacter(event)) {
        const keysCopy = keys2.concat(event.key);
        if (preventDefault(event)) {
          event.preventDefault();
          event.stopPropagation();
        }
        setKeys(keysCopy);
        fn2(keysCopy.join(""));
        clearKeysAfterDelay();
      }
    };
  }
  return onKeyDown;
}

// node_modules/@chakra-ui/menu/dist/chunk-BWUXSGSJ.mjs
"use client";
function getNextItemFromSearch(items, searchString, itemToString, currentItem) {
  if (searchString == null) {
    return currentItem;
  }
  if (!currentItem) {
    const foundItem = items.find(
      (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
    );
    return foundItem;
  }
  const matchingItems = items.filter(
    (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
  );
  if (matchingItems.length > 0) {
    let nextIndex;
    if (matchingItems.includes(currentItem)) {
      const currentIndex = matchingItems.indexOf(currentItem);
      nextIndex = currentIndex + 1;
      if (nextIndex === matchingItems.length) {
        nextIndex = 0;
      }
      return matchingItems[nextIndex];
    }
    nextIndex = items.indexOf(matchingItems[0]);
    return items[nextIndex];
  }
  return currentItem;
}

// node_modules/@chakra-ui/clickable/dist/chunk-VDSXRTOE.mjs
var import_react72 = __toESM(require_react(), 1);
"use client";
function useEventListeners() {
  const listeners = (0, import_react72.useRef)(/* @__PURE__ */ new Map());
  const currentListeners = listeners.current;
  const add3 = (0, import_react72.useCallback)((el, type, listener, options) => {
    listeners.current.set(listener, { type, el, options });
    el.addEventListener(type, listener, options);
  }, []);
  const remove = (0, import_react72.useCallback)(
    (el, type, listener, options) => {
      el.removeEventListener(type, listener, options);
      listeners.current.delete(listener);
    },
    []
  );
  (0, import_react72.useEffect)(
    () => () => {
      currentListeners.forEach((value, key) => {
        remove(value.el, value.type, key, value.options);
      });
    },
    [remove, currentListeners]
  );
  return { add: add3, remove };
}

// node_modules/@chakra-ui/clickable/dist/chunk-AXLEE3EK.mjs
var import_react73 = __toESM(require_react(), 1);
"use client";
function isValidElement4(event) {
  const element = event.target;
  const { tagName, isContentEditable: isContentEditable4 } = element;
  return tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable4 !== true;
}
function useClickable(props = {}) {
  const {
    ref: htmlRef,
    isDisabled: isDisabled2,
    isFocusable: isFocusable2,
    clickOnEnter = true,
    clickOnSpace = true,
    onMouseDown,
    onMouseUp,
    onClick,
    onKeyDown,
    onKeyUp,
    tabIndex: tabIndexProp,
    onMouseOver,
    onMouseLeave,
    ...htmlProps
  } = props;
  const [isButton, setIsButton] = (0, import_react73.useState)(true);
  const [isPressed, setIsPressed] = (0, import_react73.useState)(false);
  const listeners = useEventListeners();
  const refCallback = (node2) => {
    if (!node2)
      return;
    if (node2.tagName !== "BUTTON") {
      setIsButton(false);
    }
  };
  const tabIndex = isButton ? tabIndexProp : tabIndexProp || 0;
  const trulyDisabled = isDisabled2 && !isFocusable2;
  const handleClick = (0, import_react73.useCallback)(
    (event) => {
      if (isDisabled2) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      const self2 = event.currentTarget;
      self2.focus();
      onClick == null ? void 0 : onClick(event);
    },
    [isDisabled2, onClick]
  );
  const onDocumentKeyUp = (0, import_react73.useCallback)(
    (e) => {
      if (isPressed && isValidElement4(e)) {
        e.preventDefault();
        e.stopPropagation();
        setIsPressed(false);
        listeners.remove(document, "keyup", onDocumentKeyUp, false);
      }
    },
    [isPressed, listeners]
  );
  const handleKeyDown = (0, import_react73.useCallback)(
    (event) => {
      onKeyDown == null ? void 0 : onKeyDown(event);
      if (isDisabled2 || event.defaultPrevented || event.metaKey) {
        return;
      }
      if (!isValidElement4(event.nativeEvent) || isButton)
        return;
      const shouldClickOnEnter = clickOnEnter && event.key === "Enter";
      const shouldClickOnSpace = clickOnSpace && event.key === " ";
      if (shouldClickOnSpace) {
        event.preventDefault();
        setIsPressed(true);
      }
      if (shouldClickOnEnter) {
        event.preventDefault();
        const self2 = event.currentTarget;
        self2.click();
      }
      listeners.add(document, "keyup", onDocumentKeyUp, false);
    },
    [
      isDisabled2,
      isButton,
      onKeyDown,
      clickOnEnter,
      clickOnSpace,
      listeners,
      onDocumentKeyUp
    ]
  );
  const handleKeyUp = (0, import_react73.useCallback)(
    (event) => {
      onKeyUp == null ? void 0 : onKeyUp(event);
      if (isDisabled2 || event.defaultPrevented || event.metaKey)
        return;
      if (!isValidElement4(event.nativeEvent) || isButton)
        return;
      const shouldClickOnSpace = clickOnSpace && event.key === " ";
      if (shouldClickOnSpace) {
        event.preventDefault();
        setIsPressed(false);
        const self2 = event.currentTarget;
        self2.click();
      }
    },
    [clickOnSpace, isButton, isDisabled2, onKeyUp]
  );
  const onDocumentMouseUp = (0, import_react73.useCallback)(
    (event) => {
      if (event.button !== 0)
        return;
      setIsPressed(false);
      listeners.remove(document, "mouseup", onDocumentMouseUp, false);
    },
    [listeners]
  );
  const handleMouseDown = (0, import_react73.useCallback)(
    (event) => {
      if (event.button !== 0)
        return;
      if (isDisabled2) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      if (!isButton) {
        setIsPressed(true);
      }
      const target = event.currentTarget;
      target.focus({ preventScroll: true });
      listeners.add(document, "mouseup", onDocumentMouseUp, false);
      onMouseDown == null ? void 0 : onMouseDown(event);
    },
    [isDisabled2, isButton, onMouseDown, listeners, onDocumentMouseUp]
  );
  const handleMouseUp = (0, import_react73.useCallback)(
    (event) => {
      if (event.button !== 0)
        return;
      if (!isButton) {
        setIsPressed(false);
      }
      onMouseUp == null ? void 0 : onMouseUp(event);
    },
    [onMouseUp, isButton]
  );
  const handleMouseOver = (0, import_react73.useCallback)(
    (event) => {
      if (isDisabled2) {
        event.preventDefault();
        return;
      }
      onMouseOver == null ? void 0 : onMouseOver(event);
    },
    [isDisabled2, onMouseOver]
  );
  const handleMouseLeave = (0, import_react73.useCallback)(
    (event) => {
      if (isPressed) {
        event.preventDefault();
        setIsPressed(false);
      }
      onMouseLeave == null ? void 0 : onMouseLeave(event);
    },
    [isPressed, onMouseLeave]
  );
  const ref = mergeRefs(htmlRef, refCallback);
  if (isButton) {
    return {
      ...htmlProps,
      ref,
      type: "button",
      "aria-disabled": trulyDisabled ? void 0 : isDisabled2,
      disabled: trulyDisabled,
      onClick: handleClick,
      onMouseDown,
      onMouseUp,
      onKeyUp,
      onKeyDown,
      onMouseOver,
      onMouseLeave
    };
  }
  return {
    ...htmlProps,
    ref,
    role: "button",
    "data-active": dataAttr(isPressed),
    "aria-disabled": isDisabled2 ? "true" : void 0,
    tabIndex: trulyDisabled ? void 0 : tabIndex,
    onClick: handleClick,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onKeyUp: handleKeyUp,
    onKeyDown: handleKeyDown,
    onMouseOver: handleMouseOver,
    onMouseLeave: handleMouseLeave
  };
}

// node_modules/@chakra-ui/clickable/dist/index.mjs
"use client";

// node_modules/@chakra-ui/react-use-focus-effect/dist/index.mjs
var import_react74 = __toESM(require_react(), 1);
"use client";
function preventReturnFocus(containerRef) {
  const el = containerRef.current;
  if (!el)
    return false;
  const activeElement2 = getActiveElement(el);
  if (!activeElement2)
    return false;
  if (el.contains(activeElement2))
    return false;
  if (isTabbable(activeElement2))
    return true;
  return false;
}
function useFocusOnHide(containerRef, options) {
  const { shouldFocus: shouldFocusProp, visible, focusRef } = options;
  const shouldFocus = shouldFocusProp && !visible;
  useUpdateEffect(() => {
    if (!shouldFocus)
      return;
    if (preventReturnFocus(containerRef)) {
      return;
    }
    const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;
    let rafId2;
    if (el) {
      rafId2 = requestAnimationFrame(() => {
        el.focus({ preventScroll: true });
      });
      return () => {
        cancelAnimationFrame(rafId2);
      };
    }
  }, [shouldFocus, containerRef, focusRef]);
}
var defaultOptions = {
  preventScroll: true,
  shouldFocus: false
};
function useFocusOnShow(target, options = defaultOptions) {
  const { focusRef, preventScroll, shouldFocus, visible } = options;
  const element = isRefObject3(target) ? target.current : target;
  const autoFocusValue = shouldFocus && visible;
  const autoFocusRef = (0, import_react74.useRef)(autoFocusValue);
  const lastVisibleRef = (0, import_react74.useRef)(visible);
  useSafeLayoutEffect(() => {
    if (!lastVisibleRef.current && visible) {
      autoFocusRef.current = autoFocusValue;
    }
    lastVisibleRef.current = visible;
  }, [visible, autoFocusValue]);
  const onFocus = (0, import_react74.useCallback)(() => {
    if (!visible || !element || !autoFocusRef.current)
      return;
    autoFocusRef.current = false;
    if (element.contains(document.activeElement))
      return;
    if (focusRef == null ? void 0 : focusRef.current) {
      requestAnimationFrame(() => {
        var _a7;
        (_a7 = focusRef.current) == null ? void 0 : _a7.focus({ preventScroll });
      });
    } else {
      const tabbableEls = getAllFocusable(element);
      if (tabbableEls.length > 0) {
        requestAnimationFrame(() => {
          tabbableEls[0].focus({ preventScroll });
        });
      }
    }
  }, [visible, preventScroll, element, focusRef]);
  useUpdateEffect(() => {
    onFocus();
  }, [onFocus]);
  useEventListener(element, "transitionend", onFocus);
}
function isRefObject3(val) {
  return "current" in val;
}

// node_modules/@chakra-ui/popper/dist/chunk-6WT2JRWX.mjs
"use client";
var toVar2 = (value, fallback) => ({
  var: value,
  varRef: fallback ? `var(${value}, ${fallback})` : `var(${value})`
});
var cssVars = {
  arrowShadowColor: toVar2("--popper-arrow-shadow-color"),
  arrowSize: toVar2("--popper-arrow-size", "8px"),
  arrowSizeHalf: toVar2("--popper-arrow-size-half"),
  arrowBg: toVar2("--popper-arrow-bg"),
  transformOrigin: toVar2("--popper-transform-origin"),
  arrowOffset: toVar2("--popper-arrow-offset")
};
function getBoxShadow(placement) {
  if (placement.includes("top"))
    return `1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("bottom"))
    return `-1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("right"))
    return `-1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("left"))
    return `1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
}
var transforms = {
  top: "bottom center",
  "top-start": "bottom left",
  "top-end": "bottom right",
  bottom: "top center",
  "bottom-start": "top left",
  "bottom-end": "top right",
  left: "right center",
  "left-start": "right top",
  "left-end": "right bottom",
  right: "left center",
  "right-start": "left top",
  "right-end": "left bottom"
};
var toTransformOrigin = (placement) => transforms[placement];
var defaultEventListeners = {
  scroll: true,
  resize: true
};
function getEventListenerOptions(value) {
  let eventListeners;
  if (typeof value === "object") {
    eventListeners = {
      enabled: true,
      options: { ...defaultEventListeners, ...value }
    };
  } else {
    eventListeners = {
      enabled: value,
      options: defaultEventListeners
    };
  }
  return eventListeners;
}

// node_modules/@chakra-ui/popper/dist/chunk-P4KPSAOW.mjs
"use client";
var matchWidth = {
  name: "matchWidth",
  enabled: true,
  phase: "beforeWrite",
  requires: ["computeStyles"],
  fn: ({ state: state2 }) => {
    state2.styles.popper.width = `${state2.rects.reference.width}px`;
  },
  effect: ({ state: state2 }) => () => {
    const reference2 = state2.elements.reference;
    state2.elements.popper.style.width = `${reference2.offsetWidth}px`;
  }
};
var transformOrigin = {
  name: "transformOrigin",
  enabled: true,
  phase: "write",
  fn: ({ state: state2 }) => {
    setTransformOrigin(state2);
  },
  effect: ({ state: state2 }) => () => {
    setTransformOrigin(state2);
  }
};
var setTransformOrigin = (state2) => {
  state2.elements.popper.style.setProperty(
    cssVars.transformOrigin.var,
    toTransformOrigin(state2.placement)
  );
};
var positionArrow = {
  name: "positionArrow",
  enabled: true,
  phase: "afterWrite",
  fn: ({ state: state2 }) => {
    setArrowStyles(state2);
  }
};
var setArrowStyles = (state2) => {
  var _a7;
  if (!state2.placement)
    return;
  const overrides = getArrowStyle(state2.placement);
  if (((_a7 = state2.elements) == null ? void 0 : _a7.arrow) && overrides) {
    Object.assign(state2.elements.arrow.style, {
      [overrides.property]: overrides.value,
      width: cssVars.arrowSize.varRef,
      height: cssVars.arrowSize.varRef,
      zIndex: -1
    });
    const vars2 = {
      [cssVars.arrowSizeHalf.var]: `calc(${cssVars.arrowSize.varRef} / 2 - 1px)`,
      [cssVars.arrowOffset.var]: `calc(${cssVars.arrowSizeHalf.varRef} * -1)`
    };
    for (const property in vars2) {
      state2.elements.arrow.style.setProperty(property, vars2[property]);
    }
  }
};
var getArrowStyle = (placement) => {
  if (placement.startsWith("top")) {
    return { property: "bottom", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("bottom")) {
    return { property: "top", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("left")) {
    return { property: "right", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("right")) {
    return { property: "left", value: cssVars.arrowOffset.varRef };
  }
};
var innerArrow = {
  name: "innerArrow",
  enabled: true,
  phase: "main",
  requires: ["arrow"],
  fn: ({ state: state2 }) => {
    setInnerArrowStyles(state2);
  },
  effect: ({ state: state2 }) => () => {
    setInnerArrowStyles(state2);
  }
};
var setInnerArrowStyles = (state2) => {
  if (!state2.elements.arrow)
    return;
  const inner2 = state2.elements.arrow.querySelector(
    "[data-popper-arrow-inner]"
  );
  if (!inner2)
    return;
  const boxShadow = getBoxShadow(state2.placement);
  if (boxShadow) {
    inner2.style.setProperty("--popper-arrow-default-shadow", boxShadow);
  }
  Object.assign(inner2.style, {
    transform: "rotate(45deg)",
    background: cssVars.arrowBg.varRef,
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    position: "absolute",
    zIndex: "inherit",
    boxShadow: `var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))`
  });
};

// node_modules/@chakra-ui/popper/dist/chunk-AUJXXV3B.mjs
"use client";
var logicals = {
  "start-start": { ltr: "left-start", rtl: "right-start" },
  "start-end": { ltr: "left-end", rtl: "right-end" },
  "end-start": { ltr: "right-start", rtl: "left-start" },
  "end-end": { ltr: "right-end", rtl: "left-end" },
  start: { ltr: "left", rtl: "right" },
  end: { ltr: "right", rtl: "left" }
};
var opposites = {
  "auto-start": "auto-end",
  "auto-end": "auto-start",
  "top-start": "top-end",
  "top-end": "top-start",
  "bottom-start": "bottom-end",
  "bottom-end": "bottom-start"
};
function getPopperPlacement(placement, dir = "ltr") {
  var _a7, _b5;
  const value = ((_a7 = logicals[placement]) == null ? void 0 : _a7[dir]) || placement;
  if (dir === "ltr")
    return value;
  return (_b5 = opposites[placement]) != null ? _b5 : value;
}

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto2 = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto2]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName2(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow2(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument = node2.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node2;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement4(node2) {
  var OwnElement = getWindow2(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement3(node2) {
  var OwnElement = getWindow2(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot2(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow2(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state2 = _ref.state;
  Object.keys(state2.elements).forEach(function(name) {
    var style = state2.styles[name] || {};
    var attributes = state2.attributes[name] || {};
    var element = state2.elements[name];
    if (!isHTMLElement3(element) || !getNodeName2(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect2(_ref2) {
  var state2 = _ref2.state;
  var initialStyles = {
    popper: {
      position: state2.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state2.elements.popper.style, initialStyles.popper);
  state2.styles = initialStyles;
  if (state2.elements.arrow) {
    Object.assign(state2.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state2.elements).forEach(function(name) {
      var element = state2.elements[name];
      var attributes = state2.attributes[name] || {};
      var styleProperties = Object.keys(state2.styles.hasOwnProperty(name) ? state2.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement3(element) || !getNodeName2(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect2,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement3(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement4(element) ? getWindow2(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains2(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot2(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle4(element) {
  return getWindow2(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName2(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement4(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode2(element) {
  if (getNodeName2(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot2(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement3(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle4(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement3(element)) {
    var elementCss = getComputedStyle4(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode2(element);
  if (isShadowRoot2(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement3(currentNode) && ["html", "body"].indexOf(getNodeName2(currentNode)) < 0) {
    var css4 = getComputedStyle4(currentNode);
    if (css4.transform !== "none" || css4.perspective !== "none" || css4.contain === "paint" || ["transform", "perspective"].indexOf(css4.willChange) !== -1 || isFirefox && css4.willChange === "filter" || isFirefox && css4.filter && css4.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow2(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle4(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName2(offsetParent) === "html" || getNodeName2(offsetParent) === "body" && getComputedStyle4(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state2) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow2(_ref) {
  var _state$modifiersData$;
  var state2 = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state2.elements.arrow;
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state2.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state2);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state2.rects.reference[len] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset3 = within(min2, center, max2);
  var axisProp = axis;
  state2.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
}
function effect3(_ref2) {
  var state2 = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state2.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains2(state2.elements.popper, arrowElement)) {
    return;
  }
  state2.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow2,
  effect: effect3,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position3 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow2(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle4(offsetParent).position !== "static" && position3 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position3
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow2(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state2 = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state2.placement),
    variation: getVariation(state2.placement),
    popper: state2.elements.popper,
    popperRect: state2.rects.popper,
    gpuAcceleration,
    isFixed: state2.options.strategy === "fixed"
  };
  if (state2.modifiersData.popperOffsets != null) {
    state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.popperOffsets,
      position: state2.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state2.modifiersData.arrow != null) {
    state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-placement": state2.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect4(_ref) {
  var state2 = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll2 = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow2(state2.elements.popper);
  var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
  if (scroll2) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll2) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect4,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash3[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash4 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash4[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node2) {
  var win = getWindow2(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow2(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle4(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle4(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName2(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement3(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode2(node2));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list2) {
  var _element$ownerDocumen;
  if (list2 === void 0) {
    list2 = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow2(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list2.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode2(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement4(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode2(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle4(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement3(element) ? getOffsetParent(element) : element;
  if (!isElement4(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement4(clippingParent) && contains2(clippingParent, clipperElement) && getNodeName2(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow2(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state2.rects.popper;
  var element = state2.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement4(element) ? element : element.contextElement || getDocumentElement(state2.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state2.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state2.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset3 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply3 = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset3[axis] * multiply3;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow2(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto2) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip2(_ref) {
  var state2 = _ref.state, options = _ref.options, name = _ref.name;
  if (state2.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state2.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto2 ? computeAutoPlacement(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow2(state2, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state2.placement !== firstFittingPlacement) {
    state2.modifiersData[name]._skip = true;
    state2.placement = firstFittingPlacement;
    state2.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip2,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide2(_ref) {
  var state2 = _ref.state, name = _ref.name;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var preventedOffsets = state2.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow2(state2, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow2(state2, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state2.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide2
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset3) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
    placement
  })) : offset3, skidding = _ref[0], distance3 = _ref[1];
  skidding = skidding || 0;
  distance3 = (distance3 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance3,
    y: skidding
  } : {
    x: skidding,
    y: distance3
  };
}
function offset2(_ref2) {
  var state2 = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset3);
    return acc;
  }, {});
  var _data$state$placement = data[state2.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state2.modifiersData.popperOffsets != null) {
    state2.modifiersData.popperOffsets.x += x;
    state2.modifiersData.popperOffsets.y += y;
  }
  state2.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset2
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state2 = _ref.state, name = _ref.name;
  state2.modifiersData[name] = computeOffsets({
    reference: state2.rects.reference,
    element: state2.rects.popper,
    strategy: "absolute",
    placement: state2.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state2 = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow2(state2, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state2.placement);
  var variation = getVariation(state2.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset3 = popperOffsets2[mainAxis];
    var min2 = offset3 + overflow[mainSide];
    var max2 = offset3 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state2.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset3 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset3, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset3;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state2.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node2) {
  if (node2 === getWindow2(node2) || !isHTMLElement3(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement3(offsetParent);
  var offsetParentIsScaled = isHTMLElement3(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement3(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll2.scrollLeft - offsets.x,
    y: rect.top + scroll2.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order2(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order2(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state2 = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state2,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
        cleanupModifierEffects();
        state2.options = Object.assign({}, defaultOptions2, state2.options, options2);
        state2.scrollParents = {
          reference: isElement4(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
        state2.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state2.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state2.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state2.reset = false;
        state2.placement = state2.options.placement;
        state2.orderedModifiers.forEach(function(modifier) {
          return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index3 = 0; index3 < state2.orderedModifiers.length; index3++) {
          if (state2.reset === true) {
            state2.reset = false;
            index3 = -1;
            continue;
          }
          var _state$orderedModifie = state2.orderedModifiers[index3], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state2 = fn2({
              state: state2,
              options: _options,
              name,
              instance
            }) || state2;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state2);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state3) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state3);
      }
    });
    function runModifierEffects() {
      state2.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
        if (typeof effect5 === "function") {
          var cleanupFn = effect5({
            state: state2,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/@chakra-ui/popper/dist/chunk-LUYFNC5G.mjs
var import_react75 = __toESM(require_react(), 1);
"use client";
function usePopper(props = {}) {
  const {
    enabled = true,
    modifiers,
    placement: placementProp = "bottom",
    strategy = "absolute",
    arrowPadding = 8,
    eventListeners = true,
    offset: offset3,
    gutter = 8,
    flip: flip3 = true,
    boundary = "clippingParents",
    preventOverflow: preventOverflow2 = true,
    matchWidth: matchWidth2,
    direction: direction2 = "ltr"
  } = props;
  const reference2 = (0, import_react75.useRef)(null);
  const popper2 = (0, import_react75.useRef)(null);
  const instance = (0, import_react75.useRef)(null);
  const placement = getPopperPlacement(placementProp, direction2);
  const cleanup = (0, import_react75.useRef)(() => {
  });
  const setupPopper = (0, import_react75.useCallback)(() => {
    var _a7;
    if (!enabled || !reference2.current || !popper2.current)
      return;
    (_a7 = cleanup.current) == null ? void 0 : _a7.call(cleanup);
    instance.current = createPopper(reference2.current, popper2.current, {
      placement,
      modifiers: [
        innerArrow,
        positionArrow,
        transformOrigin,
        {
          ...matchWidth,
          enabled: !!matchWidth2
        },
        {
          name: "eventListeners",
          ...getEventListenerOptions(eventListeners)
        },
        {
          name: "arrow",
          options: { padding: arrowPadding }
        },
        {
          name: "offset",
          options: {
            offset: offset3 != null ? offset3 : [0, gutter]
          }
        },
        {
          name: "flip",
          enabled: !!flip3,
          options: { padding: 8 }
        },
        {
          name: "preventOverflow",
          enabled: !!preventOverflow2,
          options: { boundary }
        },
        // allow users override internal modifiers
        ...modifiers != null ? modifiers : []
      ],
      strategy
    });
    instance.current.forceUpdate();
    cleanup.current = instance.current.destroy;
  }, [
    placement,
    enabled,
    modifiers,
    matchWidth2,
    eventListeners,
    arrowPadding,
    offset3,
    gutter,
    flip3,
    preventOverflow2,
    boundary,
    strategy
  ]);
  (0, import_react75.useEffect)(() => {
    return () => {
      var _a7;
      if (!reference2.current && !popper2.current) {
        (_a7 = instance.current) == null ? void 0 : _a7.destroy();
        instance.current = null;
      }
    };
  }, []);
  const referenceRef = (0, import_react75.useCallback)(
    (node2) => {
      reference2.current = node2;
      setupPopper();
    },
    [setupPopper]
  );
  const getReferenceProps = (0, import_react75.useCallback)(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(referenceRef, ref)
    }),
    [referenceRef]
  );
  const popperRef = (0, import_react75.useCallback)(
    (node2) => {
      popper2.current = node2;
      setupPopper();
    },
    [setupPopper]
  );
  const getPopperProps = (0, import_react75.useCallback)(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(popperRef, ref),
      style: {
        ...props2.style,
        position: strategy,
        minWidth: matchWidth2 ? void 0 : "max-content",
        inset: "0 auto auto 0"
      }
    }),
    [strategy, popperRef, matchWidth2]
  );
  const getArrowProps = (0, import_react75.useCallback)((props2 = {}, ref = null) => {
    const { size: size3, shadowColor, bg, style, ...rest } = props2;
    return {
      ...rest,
      ref,
      "data-popper-arrow": "",
      style: getArrowStyle2(props2)
    };
  }, []);
  const getArrowInnerProps = (0, import_react75.useCallback)(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref,
      "data-popper-arrow-inner": ""
    }),
    []
  );
  return {
    update() {
      var _a7;
      (_a7 = instance.current) == null ? void 0 : _a7.update();
    },
    forceUpdate() {
      var _a7;
      (_a7 = instance.current) == null ? void 0 : _a7.forceUpdate();
    },
    transformOrigin: cssVars.transformOrigin.varRef,
    referenceRef,
    popperRef,
    getPopperProps,
    getArrowProps,
    getArrowInnerProps,
    getReferenceProps
  };
}
function getArrowStyle2(props) {
  const { size: size3, shadowColor, bg, style } = props;
  const computedStyle = { ...style, position: "absolute" };
  if (size3) {
    computedStyle["--popper-arrow-size"] = size3;
  }
  if (shadowColor) {
    computedStyle["--popper-arrow-shadow-color"] = shadowColor;
  }
  if (bg) {
    computedStyle["--popper-arrow-bg"] = bg;
  }
  return computedStyle;
}

// node_modules/@chakra-ui/popper/dist/index.mjs
"use client";

// node_modules/@chakra-ui/react-use-disclosure/dist/index.mjs
var import_react76 = __toESM(require_react(), 1);
"use client";
function useDisclosure(props = {}) {
  const {
    onClose: onCloseProp,
    onOpen: onOpenProp,
    isOpen: isOpenProp,
    id: idProp
  } = props;
  const handleOpen = useCallbackRef(onOpenProp);
  const handleClose = useCallbackRef(onCloseProp);
  const [isOpenState, setIsOpen] = (0, import_react76.useState)(props.defaultIsOpen || false);
  const isOpen = isOpenProp !== void 0 ? isOpenProp : isOpenState;
  const isControlled = isOpenProp !== void 0;
  const uid2 = (0, import_react76.useId)();
  const id2 = idProp != null ? idProp : `disclosure-${uid2}`;
  const onClose = (0, import_react76.useCallback)(() => {
    if (!isControlled) {
      setIsOpen(false);
    }
    handleClose == null ? void 0 : handleClose();
  }, [isControlled, handleClose]);
  const onOpen = (0, import_react76.useCallback)(() => {
    if (!isControlled) {
      setIsOpen(true);
    }
    handleOpen == null ? void 0 : handleOpen();
  }, [isControlled, handleOpen]);
  const onToggle = (0, import_react76.useCallback)(() => {
    if (isOpen) {
      onClose();
    } else {
      onOpen();
    }
  }, [isOpen, onOpen, onClose]);
  function getButtonProps(props2 = {}) {
    return {
      ...props2,
      "aria-expanded": isOpen,
      "aria-controls": id2,
      onClick(event) {
        var _a7;
        (_a7 = props2.onClick) == null ? void 0 : _a7.call(props2, event);
        onToggle();
      }
    };
  }
  function getDisclosureProps(props2 = {}) {
    return {
      ...props2,
      hidden: !isOpen,
      id: id2
    };
  }
  return {
    isOpen,
    onOpen,
    onClose,
    onToggle,
    isControlled,
    getButtonProps,
    getDisclosureProps
  };
}

// node_modules/@chakra-ui/react-use-outside-click/dist/index.mjs
var import_react77 = __toESM(require_react(), 1);
"use client";
function useOutsideClick(props) {
  const { ref, handler, enabled = true } = props;
  const savedHandler = useCallbackRef(handler);
  const stateRef = (0, import_react77.useRef)({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  const state2 = stateRef.current;
  (0, import_react77.useEffect)(() => {
    if (!enabled)
      return;
    const onPointerDown = (e) => {
      if (isValidEvent(e, ref)) {
        state2.isPointerDown = true;
      }
    };
    const onMouseUp = (event) => {
      if (state2.ignoreEmulatedMouseEvents) {
        state2.ignoreEmulatedMouseEvents = false;
        return;
      }
      if (state2.isPointerDown && handler && isValidEvent(event, ref)) {
        state2.isPointerDown = false;
        savedHandler(event);
      }
    };
    const onTouchEnd = (event) => {
      state2.ignoreEmulatedMouseEvents = true;
      if (handler && state2.isPointerDown && isValidEvent(event, ref)) {
        state2.isPointerDown = false;
        savedHandler(event);
      }
    };
    const doc = getOwnerDocument2(ref.current);
    doc.addEventListener("mousedown", onPointerDown, true);
    doc.addEventListener("mouseup", onMouseUp, true);
    doc.addEventListener("touchstart", onPointerDown, true);
    doc.addEventListener("touchend", onTouchEnd, true);
    return () => {
      doc.removeEventListener("mousedown", onPointerDown, true);
      doc.removeEventListener("mouseup", onMouseUp, true);
      doc.removeEventListener("touchstart", onPointerDown, true);
      doc.removeEventListener("touchend", onTouchEnd, true);
    };
  }, [handler, ref, savedHandler, state2, enabled]);
}
function isValidEvent(event, ref) {
  var _a7;
  const target = event.target;
  if (target) {
    const doc = getOwnerDocument2(target);
    if (!doc.contains(target))
      return false;
  }
  return !((_a7 = ref.current) == null ? void 0 : _a7.contains(target));
}
function getOwnerDocument2(node2) {
  var _a7;
  return (_a7 = node2 == null ? void 0 : node2.ownerDocument) != null ? _a7 : document;
}

// node_modules/@chakra-ui/react-use-animation-state/dist/index.mjs
var import_react78 = __toESM(require_react(), 1);
"use client";
function useAnimationState(props) {
  const { isOpen, ref } = props;
  const [mounted, setMounted] = (0, import_react78.useState)(isOpen);
  const [once2, setOnce] = (0, import_react78.useState)(false);
  (0, import_react78.useEffect)(() => {
    if (!once2) {
      setMounted(isOpen);
      setOnce(true);
    }
  }, [isOpen, once2, mounted]);
  useEventListener(
    () => ref.current,
    "animationend",
    () => {
      setMounted(isOpen);
    }
  );
  const hidden = isOpen ? false : !mounted;
  return {
    present: !hidden,
    onComplete() {
      var _a7;
      const win = getOwnerWindow(ref.current);
      const evt = new win.CustomEvent("animationend", { bubbles: true });
      (_a7 = ref.current) == null ? void 0 : _a7.dispatchEvent(evt);
    }
  };
}

// node_modules/@chakra-ui/lazy-utils/dist/index.mjs
function lazyDisclosure(options) {
  const { wasSelected, enabled, isSelected, mode: mode2 = "unmount" } = options;
  if (!enabled)
    return true;
  if (isSelected)
    return true;
  if (mode2 === "keepMounted" && wasSelected)
    return true;
  return false;
}

// node_modules/@chakra-ui/menu/dist/chunk-SANI5SUM.mjs
var import_react79 = __toESM(require_react(), 1);
"use client";
var [
  MenuDescendantsProvider,
  useMenuDescendantsContext,
  useMenuDescendants,
  useMenuDescendant
] = createDescendantContext();
var [MenuProvider, useMenuContext] = createContext2({
  strict: false,
  name: "MenuContext"
});
function useIds(idProp, ...prefixes) {
  const reactId = (0, import_react79.useId)();
  const id2 = idProp || reactId;
  return (0, import_react79.useMemo)(() => {
    return prefixes.map((prefix2) => `${prefix2}-${id2}`);
  }, [id2, prefixes]);
}
function getOwnerDocument3(node2) {
  var _a7;
  return (_a7 = node2 == null ? void 0 : node2.ownerDocument) != null ? _a7 : document;
}
function isActiveElement2(element) {
  const doc = getOwnerDocument3(element);
  return doc.activeElement === element;
}
function useMenu(props = {}) {
  const {
    id: id2,
    closeOnSelect = true,
    closeOnBlur = true,
    initialFocusRef,
    autoSelect = true,
    isLazy,
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenProp,
    placement = "bottom-start",
    lazyBehavior = "unmount",
    direction: direction2,
    computePositionOnMount = false,
    ...popperProps
  } = props;
  const menuRef = (0, import_react79.useRef)(null);
  const buttonRef = (0, import_react79.useRef)(null);
  const descendants = useMenuDescendants();
  const focusMenu = (0, import_react79.useCallback)(() => {
    requestAnimationFrame(() => {
      var _a7;
      (_a7 = menuRef.current) == null ? void 0 : _a7.focus({ preventScroll: false });
    });
  }, []);
  const focusFirstItem = (0, import_react79.useCallback)(() => {
    const id22 = setTimeout(() => {
      var _a7;
      if (initialFocusRef) {
        (_a7 = initialFocusRef.current) == null ? void 0 : _a7.focus();
      } else {
        const first = descendants.firstEnabled();
        if (first)
          setFocusedIndex(first.index);
      }
    });
    timeoutIds.current.add(id22);
  }, [descendants, initialFocusRef]);
  const focusLastItem = (0, import_react79.useCallback)(() => {
    const id22 = setTimeout(() => {
      const last = descendants.lastEnabled();
      if (last)
        setFocusedIndex(last.index);
    });
    timeoutIds.current.add(id22);
  }, [descendants]);
  const onOpenInternal = (0, import_react79.useCallback)(() => {
    onOpenProp == null ? void 0 : onOpenProp();
    if (autoSelect) {
      focusFirstItem();
    } else {
      focusMenu();
    }
  }, [autoSelect, focusFirstItem, focusMenu, onOpenProp]);
  const { isOpen, onOpen, onClose, onToggle } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenInternal
  });
  useOutsideClick({
    enabled: isOpen && closeOnBlur,
    ref: menuRef,
    handler: (event) => {
      var _a7;
      if (!((_a7 = buttonRef.current) == null ? void 0 : _a7.contains(event.target))) {
        onClose();
      }
    }
  });
  const popper2 = usePopper({
    ...popperProps,
    enabled: isOpen || computePositionOnMount,
    placement,
    direction: direction2
  });
  const [focusedIndex, setFocusedIndex] = (0, import_react79.useState)(-1);
  useUpdateEffect(() => {
    if (!isOpen) {
      setFocusedIndex(-1);
    }
  }, [isOpen]);
  useFocusOnHide(menuRef, {
    focusRef: buttonRef,
    visible: isOpen,
    shouldFocus: true
  });
  const animationState = useAnimationState({ isOpen, ref: menuRef });
  const [buttonId, menuId] = useIds(id2, `menu-button`, `menu-list`);
  const openAndFocusMenu = (0, import_react79.useCallback)(() => {
    onOpen();
    focusMenu();
  }, [onOpen, focusMenu]);
  const timeoutIds = (0, import_react79.useRef)(/* @__PURE__ */ new Set([]));
  (0, import_react79.useEffect)(() => {
    const ids = timeoutIds.current;
    return () => {
      ids.forEach((id22) => clearTimeout(id22));
      ids.clear();
    };
  }, []);
  const openAndFocusFirstItem = (0, import_react79.useCallback)(() => {
    onOpen();
    focusFirstItem();
  }, [focusFirstItem, onOpen]);
  const openAndFocusLastItem = (0, import_react79.useCallback)(() => {
    onOpen();
    focusLastItem();
  }, [onOpen, focusLastItem]);
  const refocus = (0, import_react79.useCallback)(() => {
    var _a7, _b5;
    const doc = getOwnerDocument3(menuRef.current);
    const hasFocusWithin2 = (_a7 = menuRef.current) == null ? void 0 : _a7.contains(doc.activeElement);
    const shouldRefocus = isOpen && !hasFocusWithin2;
    if (!shouldRefocus)
      return;
    const node2 = (_b5 = descendants.item(focusedIndex)) == null ? void 0 : _b5.node;
    node2 == null ? void 0 : node2.focus({ preventScroll: true });
  }, [isOpen, focusedIndex, descendants]);
  const rafId2 = (0, import_react79.useRef)(null);
  return {
    openAndFocusMenu,
    openAndFocusFirstItem,
    openAndFocusLastItem,
    onTransitionEnd: refocus,
    unstable__animationState: animationState,
    descendants,
    popper: popper2,
    buttonId,
    menuId,
    forceUpdate: popper2.forceUpdate,
    orientation: "vertical",
    isOpen,
    onToggle,
    onOpen,
    onClose,
    menuRef,
    buttonRef,
    focusedIndex,
    closeOnSelect,
    closeOnBlur,
    autoSelect,
    setFocusedIndex,
    isLazy,
    lazyBehavior,
    initialFocusRef,
    rafId: rafId2
  };
}
function useMenuButton(props = {}, externalRef = null) {
  const menu = useMenuContext();
  const { onToggle, popper: popper2, openAndFocusFirstItem, openAndFocusLastItem } = menu;
  const onKeyDown = (0, import_react79.useCallback)(
    (event) => {
      const eventKey = event.key;
      const keyMap = {
        Enter: openAndFocusFirstItem,
        ArrowDown: openAndFocusFirstItem,
        ArrowUp: openAndFocusLastItem
      };
      const action = keyMap[eventKey];
      if (action) {
        event.preventDefault();
        event.stopPropagation();
        action(event);
      }
    },
    [openAndFocusFirstItem, openAndFocusLastItem]
  );
  return {
    ...props,
    ref: mergeRefs(menu.buttonRef, externalRef, popper2.referenceRef),
    id: menu.buttonId,
    "data-active": dataAttr(menu.isOpen),
    "aria-expanded": menu.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": menu.menuId,
    onClick: callAllHandlers(props.onClick, onToggle),
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  };
}
function isTargetMenuItem(target) {
  var _a7;
  return isHTMLElement4(target) && !!((_a7 = target == null ? void 0 : target.getAttribute("role")) == null ? void 0 : _a7.startsWith("menuitem"));
}
function useMenuList(props = {}, ref = null) {
  const menu = useMenuContext();
  if (!menu) {
    throw new Error(
      `useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`
    );
  }
  const {
    focusedIndex,
    setFocusedIndex,
    menuRef,
    isOpen,
    onClose,
    menuId,
    isLazy,
    lazyBehavior,
    unstable__animationState: animated
  } = menu;
  const descendants = useMenuDescendantsContext();
  const createTypeaheadHandler = useShortcut({
    preventDefault: (event) => event.key !== " " && isTargetMenuItem(event.target)
  });
  const onKeyDown = (0, import_react79.useCallback)(
    (event) => {
      if (!event.currentTarget.contains(event.target))
        return;
      const eventKey = event.key;
      const keyMap = {
        Tab: (event2) => event2.preventDefault(),
        Escape: onClose,
        ArrowDown: () => {
          const next2 = descendants.nextEnabled(focusedIndex);
          if (next2)
            setFocusedIndex(next2.index);
        },
        ArrowUp: () => {
          const prev2 = descendants.prevEnabled(focusedIndex);
          if (prev2)
            setFocusedIndex(prev2.index);
        }
      };
      const fn2 = keyMap[eventKey];
      if (fn2) {
        event.preventDefault();
        fn2(event);
        return;
      }
      const onTypeahead = createTypeaheadHandler((character2) => {
        const nextItem = getNextItemFromSearch(
          descendants.values(),
          character2,
          (item) => {
            var _a7, _b5;
            return (_b5 = (_a7 = item == null ? void 0 : item.node) == null ? void 0 : _a7.textContent) != null ? _b5 : "";
          },
          descendants.item(focusedIndex)
        );
        if (nextItem) {
          const index3 = descendants.indexOf(nextItem.node);
          setFocusedIndex(index3);
        }
      });
      if (isTargetMenuItem(event.target)) {
        onTypeahead(event);
      }
    },
    [
      descendants,
      focusedIndex,
      createTypeaheadHandler,
      onClose,
      setFocusedIndex
    ]
  );
  const hasBeenOpened = (0, import_react79.useRef)(false);
  if (isOpen) {
    hasBeenOpened.current = true;
  }
  const shouldRenderChildren = lazyDisclosure({
    wasSelected: hasBeenOpened.current,
    enabled: isLazy,
    mode: lazyBehavior,
    isSelected: animated.present
  });
  return {
    ...props,
    ref: mergeRefs(menuRef, ref),
    children: shouldRenderChildren ? props.children : null,
    tabIndex: -1,
    role: "menu",
    id: menuId,
    style: {
      ...props.style,
      transformOrigin: "var(--popper-transform-origin)"
    },
    "aria-orientation": "vertical",
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  };
}
function useMenuPositioner(props = {}) {
  const { popper: popper2, isOpen } = useMenuContext();
  return popper2.getPopperProps({
    ...props,
    style: {
      visibility: isOpen ? "visible" : "hidden",
      ...props.style
    }
  });
}
function useMenuItem(props = {}, externalRef = null) {
  const {
    onMouseEnter: onMouseEnterProp,
    onMouseMove: onMouseMoveProp,
    onMouseLeave: onMouseLeaveProp,
    onClick: onClickProp,
    onFocus: onFocusProp,
    isDisabled: isDisabled2,
    isFocusable: isFocusable2,
    closeOnSelect,
    type: typeProp,
    ...htmlProps
  } = props;
  const menu = useMenuContext();
  const {
    setFocusedIndex,
    focusedIndex,
    closeOnSelect: menuCloseOnSelect,
    onClose,
    menuRef,
    isOpen,
    menuId,
    rafId: rafId2
  } = menu;
  const ref = (0, import_react79.useRef)(null);
  const id2 = `${menuId}-menuitem-${(0, import_react79.useId)()}`;
  const { index: index3, register } = useMenuDescendant({
    disabled: isDisabled2 && !isFocusable2
  });
  const onMouseEnter = (0, import_react79.useCallback)(
    (event) => {
      onMouseEnterProp == null ? void 0 : onMouseEnterProp(event);
      if (isDisabled2)
        return;
      setFocusedIndex(index3);
    },
    [setFocusedIndex, index3, isDisabled2, onMouseEnterProp]
  );
  const onMouseMove = (0, import_react79.useCallback)(
    (event) => {
      onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
      if (ref.current && !isActiveElement2(ref.current)) {
        onMouseEnter(event);
      }
    },
    [onMouseEnter, onMouseMoveProp]
  );
  const onMouseLeave = (0, import_react79.useCallback)(
    (event) => {
      onMouseLeaveProp == null ? void 0 : onMouseLeaveProp(event);
      if (isDisabled2)
        return;
      setFocusedIndex(-1);
    },
    [setFocusedIndex, isDisabled2, onMouseLeaveProp]
  );
  const onClick = (0, import_react79.useCallback)(
    (event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (!isTargetMenuItem(event.currentTarget))
        return;
      if (closeOnSelect != null ? closeOnSelect : menuCloseOnSelect) {
        onClose();
      }
    },
    [onClose, onClickProp, menuCloseOnSelect, closeOnSelect]
  );
  const onFocus = (0, import_react79.useCallback)(
    (event) => {
      onFocusProp == null ? void 0 : onFocusProp(event);
      setFocusedIndex(index3);
    },
    [setFocusedIndex, onFocusProp, index3]
  );
  const isFocused = index3 === focusedIndex;
  const trulyDisabled = isDisabled2 && !isFocusable2;
  useUpdateEffect(() => {
    if (!isOpen)
      return;
    if (isFocused && !trulyDisabled && ref.current) {
      if (rafId2.current) {
        cancelAnimationFrame(rafId2.current);
      }
      rafId2.current = requestAnimationFrame(() => {
        var _a7;
        (_a7 = ref.current) == null ? void 0 : _a7.focus({ preventScroll: true });
        rafId2.current = null;
      });
    } else if (menuRef.current && !isActiveElement2(menuRef.current)) {
      menuRef.current.focus({ preventScroll: true });
    }
    return () => {
      if (rafId2.current) {
        cancelAnimationFrame(rafId2.current);
      }
    };
  }, [isFocused, trulyDisabled, menuRef, isOpen]);
  const clickableProps = useClickable({
    onClick,
    onFocus,
    onMouseEnter,
    onMouseMove,
    onMouseLeave,
    ref: mergeRefs(register, ref, externalRef),
    isDisabled: isDisabled2,
    isFocusable: isFocusable2
  });
  return {
    ...htmlProps,
    ...clickableProps,
    type: typeProp != null ? typeProp : clickableProps.type,
    id: id2,
    role: "menuitem",
    tabIndex: isFocused ? 0 : -1
  };
}
function isHTMLElement4(el) {
  var _a7;
  if (!isElement5(el))
    return false;
  const win = (_a7 = el.ownerDocument.defaultView) != null ? _a7 : window;
  return el instanceof win.HTMLElement;
}
function isElement5(el) {
  return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
}

// node_modules/@chakra-ui/menu/dist/chunk-UZJ3TPNQ.mjs
var import_react80 = __toESM(require_react(), 1);
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
"use client";
var [MenuStylesProvider, useMenuStyles] = createContext2({
  name: `MenuStylesContext`,
  errorMessage: `useMenuStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />" `
});
var Menu = (props) => {
  const { children } = props;
  const styles3 = useMultiStyleConfig("Menu", props);
  const ownProps = omitThemingProps(props);
  const { direction: direction2 } = useTheme2();
  const { descendants, ...ctx } = useMenu({ ...ownProps, direction: direction2 });
  const context = (0, import_react80.useMemo)(() => ctx, [ctx]);
  const { isOpen, onClose, forceUpdate } = context;
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(MenuDescendantsProvider, { value: descendants, children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(MenuProvider, { value: context, children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(MenuStylesProvider, { value: styles3, children: runIfFn(children, { isOpen, onClose, forceUpdate }) }) }) });
};
Menu.displayName = "Menu";

// node_modules/@chakra-ui/menu/dist/chunk-4CNGLKYX.mjs
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
"use client";
var MenuCommand = forwardRef3(
  (props, ref) => {
    const styles3 = useMenuStyles();
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
      chakra.span,
      {
        ref,
        ...props,
        __css: styles3.command,
        className: "chakra-menu__command"
      }
    );
  }
);
MenuCommand.displayName = "MenuCommand";

// node_modules/@chakra-ui/menu/dist/chunk-M565QO7N.mjs
var import_react81 = __toESM(require_react(), 1);
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
"use client";
var StyledMenuItem = forwardRef3(
  (props, ref) => {
    const { type, ...rest } = props;
    const styles3 = useMenuStyles();
    const btnType = rest.as || type ? type != null ? type : void 0 : "button";
    const buttonStyles = (0, import_react81.useMemo)(
      () => ({
        textDecoration: "none",
        color: "inherit",
        userSelect: "none",
        display: "flex",
        width: "100%",
        alignItems: "center",
        textAlign: "start",
        flex: "0 0 auto",
        outline: 0,
        ...styles3.item
      }),
      [styles3.item]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(chakra.button, { ref, type: btnType, ...rest, __css: buttonStyles });
  }
);

// node_modules/@chakra-ui/menu/dist/chunk-HB6KBUMZ.mjs
var import_react82 = __toESM(require_react(), 1);
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
"use client";
var MenuIcon = (props) => {
  const { className, children, ...rest } = props;
  const styles3 = useMenuStyles();
  const child = import_react82.Children.only(children);
  const clone = (0, import_react82.isValidElement)(child) ? (0, import_react82.cloneElement)(child, {
    focusable: "false",
    "aria-hidden": true,
    className: cx("chakra-menu__icon", child.props.className)
  }) : null;
  const _className = cx("chakra-menu__icon-wrapper", className);
  return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(chakra.span, { className: _className, ...rest, __css: styles3.icon, children: clone });
};
MenuIcon.displayName = "MenuIcon";

// node_modules/@chakra-ui/menu/dist/chunk-5TWLKMYI.mjs
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
"use client";
var MenuItem = forwardRef3((props, ref) => {
  const {
    icon,
    iconSpacing: iconSpacing2 = "0.75rem",
    command,
    commandSpacing = "0.75rem",
    children,
    ...rest
  } = props;
  const menuitemProps = useMenuItem(rest, ref);
  const shouldWrap = icon || command;
  const _children = shouldWrap ? /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("span", { style: { pointerEvents: "none", flex: 1 }, children }) : children;
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(
    StyledMenuItem,
    {
      ...menuitemProps,
      className: cx("chakra-menu__menuitem", menuitemProps.className),
      children: [
        icon && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(MenuIcon, { fontSize: "0.8em", marginEnd: iconSpacing2, children: icon }),
        _children,
        command && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(MenuCommand, { marginStart: commandSpacing, children: command })
      ]
    }
  );
});
MenuItem.displayName = "MenuItem";

// node_modules/@chakra-ui/menu/dist/chunk-6MF6NSK4.mjs
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
"use client";
var motionVariants = {
  enter: {
    visibility: "visible",
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    transitionEnd: {
      visibility: "hidden"
    },
    opacity: 0,
    scale: 0.8,
    transition: {
      duration: 0.1,
      easings: "easeOut"
    }
  }
};
var MenuTransition = chakra(motion.div);
var MenuList = forwardRef3(function MenuList2(props, ref) {
  var _a7, _b5;
  const { rootProps, motionProps, ...rest } = props;
  const {
    isOpen,
    onTransitionEnd,
    unstable__animationState: animated
  } = useMenuContext();
  const listProps = useMenuList(rest, ref);
  const positionerProps = useMenuPositioner(rootProps);
  const styles3 = useMenuStyles();
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
    chakra.div,
    {
      ...positionerProps,
      __css: { zIndex: (_b5 = props.zIndex) != null ? _b5 : (_a7 = styles3.list) == null ? void 0 : _a7.zIndex },
      children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
        MenuTransition,
        {
          variants: motionVariants,
          initial: false,
          animate: isOpen ? "enter" : "exit",
          __css: { outline: 0, ...styles3.list },
          ...motionProps,
          className: cx("chakra-menu__menu-list", listProps.className),
          ...listProps,
          onUpdate: onTransitionEnd,
          onAnimationComplete: callAll(
            animated.onComplete,
            listProps.onAnimationComplete
          )
        }
      )
    }
  );
});
MenuList.displayName = "MenuList";

// node_modules/@chakra-ui/menu/dist/chunk-Z3VR2BFQ.mjs
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
"use client";
var StyledMenuButton = forwardRef3((props, ref) => {
  const styles3 = useMenuStyles();
  return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
    chakra.button,
    {
      ref,
      ...props,
      __css: {
        display: "inline-flex",
        appearance: "none",
        alignItems: "center",
        outline: 0,
        ...styles3.button
      }
    }
  );
});
var MenuButton = forwardRef3(
  (props, ref) => {
    const { children, as: As, ...rest } = props;
    const buttonProps = useMenuButton(rest, ref);
    const Element2 = As || StyledMenuButton;
    return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
      Element2,
      {
        ...buttonProps,
        className: cx("chakra-menu__menu-button", props.className),
        children: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
          chakra.span,
          {
            __css: { pointerEvents: "none", flex: "1 1 auto", minW: 0 },
            children: props.children
          }
        )
      }
    );
  }
);
MenuButton.displayName = "MenuButton";

// node_modules/@chakra-ui/menu/dist/index.mjs
"use client";

// node_modules/@chakra-ui/popover/dist/chunk-Z3POGKNI.mjs
"use client";
var [PopoverProvider, usePopoverContext] = createContext2({
  name: "PopoverContext",
  errorMessage: "usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"
});
var [PopoverStylesProvider, usePopoverStyles] = createContext2({
  name: `PopoverStylesContext`,
  errorMessage: `usePopoverStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Popover />" `
});

// node_modules/@chakra-ui/popover/dist/chunk-OFUG2FGD.mjs
var import_react83 = __toESM(require_react(), 1);
"use client";
function PopoverTrigger(props) {
  const child = import_react83.Children.only(props.children);
  const { getTriggerProps } = usePopoverContext();
  return (0, import_react83.cloneElement)(child, getTriggerProps(child.props, child.ref));
}
PopoverTrigger.displayName = "PopoverTrigger";

// node_modules/@chakra-ui/popover/dist/chunk-A566ERKI.mjs
var import_react84 = __toESM(require_react(), 1);
"use client";
var TRIGGER = {
  click: "click",
  hover: "hover"
};
function usePopover(props = {}) {
  const {
    closeOnBlur = true,
    closeOnEsc = true,
    initialFocusRef,
    id: id2,
    returnFocusOnClose = true,
    autoFocus = true,
    arrowSize,
    arrowShadowColor,
    trigger = TRIGGER.click,
    openDelay = 200,
    closeDelay = 200,
    isLazy,
    lazyBehavior = "unmount",
    computePositionOnMount,
    ...popperProps
  } = props;
  const { isOpen, onClose, onOpen, onToggle } = useDisclosure(props);
  const anchorRef = (0, import_react84.useRef)(null);
  const triggerRef = (0, import_react84.useRef)(null);
  const popoverRef = (0, import_react84.useRef)(null);
  const isHoveringRef = (0, import_react84.useRef)(false);
  const hasBeenOpened = (0, import_react84.useRef)(false);
  if (isOpen) {
    hasBeenOpened.current = true;
  }
  const [hasHeader, setHasHeader] = (0, import_react84.useState)(false);
  const [hasBody, setHasBody] = (0, import_react84.useState)(false);
  const uuid = (0, import_react84.useId)();
  const uid2 = id2 != null ? id2 : uuid;
  const [triggerId, popoverId, headerId, bodyId] = [
    "popover-trigger",
    "popover-content",
    "popover-header",
    "popover-body"
  ].map((id22) => `${id22}-${uid2}`);
  const {
    referenceRef,
    getArrowProps,
    getPopperProps,
    getArrowInnerProps,
    forceUpdate
  } = usePopper({
    ...popperProps,
    enabled: isOpen || !!computePositionOnMount
  });
  const animated = useAnimationState({ isOpen, ref: popoverRef });
  useFocusOnPointerDown({
    enabled: isOpen,
    ref: triggerRef
  });
  useFocusOnHide(popoverRef, {
    focusRef: triggerRef,
    visible: isOpen,
    shouldFocus: returnFocusOnClose && trigger === TRIGGER.click
  });
  useFocusOnShow(popoverRef, {
    focusRef: initialFocusRef,
    visible: isOpen,
    shouldFocus: autoFocus && trigger === TRIGGER.click
  });
  const shouldRenderChildren = lazyDisclosure({
    wasSelected: hasBeenOpened.current,
    enabled: isLazy,
    mode: lazyBehavior,
    isSelected: animated.present
  });
  const getPopoverProps = (0, import_react84.useCallback)(
    (props2 = {}, _ref = null) => {
      const popoverProps = {
        ...props2,
        style: {
          ...props2.style,
          transformOrigin: cssVars.transformOrigin.varRef,
          [cssVars.arrowSize.var]: arrowSize ? `${arrowSize}px` : void 0,
          [cssVars.arrowShadowColor.var]: arrowShadowColor
        },
        ref: mergeRefs(popoverRef, _ref),
        children: shouldRenderChildren ? props2.children : null,
        id: popoverId,
        tabIndex: -1,
        role: "dialog",
        onKeyDown: callAllHandlers(props2.onKeyDown, (event) => {
          if (closeOnEsc && event.key === "Escape") {
            onClose();
          }
        }),
        onBlur: callAllHandlers(props2.onBlur, (event) => {
          const relatedTarget = getRelatedTarget(event);
          const targetIsPopover = contains3(popoverRef.current, relatedTarget);
          const targetIsTrigger = contains3(triggerRef.current, relatedTarget);
          const isValidBlur = !targetIsPopover && !targetIsTrigger;
          if (isOpen && closeOnBlur && isValidBlur) {
            onClose();
          }
        }),
        "aria-labelledby": hasHeader ? headerId : void 0,
        "aria-describedby": hasBody ? bodyId : void 0
      };
      if (trigger === TRIGGER.hover) {
        popoverProps.role = "tooltip";
        popoverProps.onMouseEnter = callAllHandlers(props2.onMouseEnter, () => {
          isHoveringRef.current = true;
        });
        popoverProps.onMouseLeave = callAllHandlers(
          props2.onMouseLeave,
          (event) => {
            if (event.nativeEvent.relatedTarget === null) {
              return;
            }
            isHoveringRef.current = false;
            setTimeout(() => onClose(), closeDelay);
          }
        );
      }
      return popoverProps;
    },
    [
      shouldRenderChildren,
      popoverId,
      hasHeader,
      headerId,
      hasBody,
      bodyId,
      trigger,
      closeOnEsc,
      onClose,
      isOpen,
      closeOnBlur,
      closeDelay,
      arrowShadowColor,
      arrowSize
    ]
  );
  const getPopoverPositionerProps = (0, import_react84.useCallback)(
    (props2 = {}, forwardedRef = null) => getPopperProps(
      {
        ...props2,
        style: {
          visibility: isOpen ? "visible" : "hidden",
          ...props2.style
        }
      },
      forwardedRef
    ),
    [isOpen, getPopperProps]
  );
  const getAnchorProps = (0, import_react84.useCallback)(
    (props2, _ref = null) => {
      return {
        ...props2,
        // If anchor is rendered, it is used as reference.
        ref: mergeRefs(_ref, anchorRef, referenceRef)
      };
    },
    [anchorRef, referenceRef]
  );
  const openTimeout = (0, import_react84.useRef)();
  const closeTimeout = (0, import_react84.useRef)();
  const maybeReferenceRef = (0, import_react84.useCallback)(
    (node2) => {
      if (anchorRef.current == null) {
        referenceRef(node2);
      }
    },
    [referenceRef]
  );
  const getTriggerProps = (0, import_react84.useCallback)(
    (props2 = {}, _ref = null) => {
      const triggerProps = {
        ...props2,
        ref: mergeRefs(triggerRef, _ref, maybeReferenceRef),
        id: triggerId,
        "aria-haspopup": "dialog",
        "aria-expanded": isOpen,
        "aria-controls": popoverId
      };
      if (trigger === TRIGGER.click) {
        triggerProps.onClick = callAllHandlers(props2.onClick, onToggle);
      }
      if (trigger === TRIGGER.hover) {
        triggerProps.onFocus = callAllHandlers(props2.onFocus, () => {
          if (openTimeout.current === void 0) {
            onOpen();
          }
        });
        triggerProps.onBlur = callAllHandlers(props2.onBlur, (event) => {
          const relatedTarget = getRelatedTarget(event);
          const isValidBlur = !contains3(popoverRef.current, relatedTarget);
          if (isOpen && closeOnBlur && isValidBlur) {
            onClose();
          }
        });
        triggerProps.onKeyDown = callAllHandlers(props2.onKeyDown, (event) => {
          if (event.key === "Escape") {
            onClose();
          }
        });
        triggerProps.onMouseEnter = callAllHandlers(props2.onMouseEnter, () => {
          isHoveringRef.current = true;
          openTimeout.current = window.setTimeout(() => onOpen(), openDelay);
        });
        triggerProps.onMouseLeave = callAllHandlers(props2.onMouseLeave, () => {
          isHoveringRef.current = false;
          if (openTimeout.current) {
            clearTimeout(openTimeout.current);
            openTimeout.current = void 0;
          }
          closeTimeout.current = window.setTimeout(() => {
            if (isHoveringRef.current === false) {
              onClose();
            }
          }, closeDelay);
        });
      }
      return triggerProps;
    },
    [
      triggerId,
      isOpen,
      popoverId,
      trigger,
      maybeReferenceRef,
      onToggle,
      onOpen,
      closeOnBlur,
      onClose,
      openDelay,
      closeDelay
    ]
  );
  (0, import_react84.useEffect)(() => {
    return () => {
      if (openTimeout.current) {
        clearTimeout(openTimeout.current);
      }
      if (closeTimeout.current) {
        clearTimeout(closeTimeout.current);
      }
    };
  }, []);
  const getHeaderProps = (0, import_react84.useCallback)(
    (props2 = {}, ref = null) => ({
      ...props2,
      id: headerId,
      ref: mergeRefs(ref, (node2) => {
        setHasHeader(!!node2);
      })
    }),
    [headerId]
  );
  const getBodyProps = (0, import_react84.useCallback)(
    (props2 = {}, ref = null) => ({
      ...props2,
      id: bodyId,
      ref: mergeRefs(ref, (node2) => {
        setHasBody(!!node2);
      })
    }),
    [bodyId]
  );
  return {
    forceUpdate,
    isOpen,
    onAnimationComplete: animated.onComplete,
    onClose,
    getAnchorProps,
    getArrowProps,
    getArrowInnerProps,
    getPopoverPositionerProps,
    getPopoverProps,
    getTriggerProps,
    getHeaderProps,
    getBodyProps
  };
}
function contains3(parent, child) {
  return parent === child || (parent == null ? void 0 : parent.contains(child));
}
function getRelatedTarget(event) {
  var _a7;
  const activeEl = event.currentTarget.ownerDocument.activeElement;
  return (_a7 = event.relatedTarget) != null ? _a7 : activeEl;
}

// node_modules/@chakra-ui/popover/dist/chunk-3WRTUQ76.mjs
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
"use client";
function Popover(props) {
  const styles3 = useMultiStyleConfig("Popover", props);
  const { children, ...rest } = omitThemingProps(props);
  const theme3 = useTheme2();
  const context = usePopover({ ...rest, direction: theme3.direction });
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(PopoverProvider, { value: context, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(PopoverStylesProvider, { value: styles3, children: runIfFn(children, {
    isOpen: context.isOpen,
    onClose: context.onClose,
    forceUpdate: context.forceUpdate
  }) }) });
}
Popover.displayName = "Popover";

// node_modules/@chakra-ui/popover/dist/chunk-TL4BBA7T.mjs
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
"use client";
var resolveVar = (scale2, value) => value ? `${scale2}.${value}, ${value}` : void 0;
function PopoverArrow(props) {
  var _a7;
  const { bg, bgColor, backgroundColor, shadow, boxShadow, shadowColor } = props;
  const { getArrowProps, getArrowInnerProps } = usePopoverContext();
  const styles3 = usePopoverStyles();
  const arrowBg = (_a7 = bg != null ? bg : bgColor) != null ? _a7 : backgroundColor;
  const arrowShadow = shadow != null ? shadow : boxShadow;
  return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
    chakra.div,
    {
      ...getArrowProps(),
      className: "chakra-popover__arrow-positioner",
      children: /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
        chakra.div,
        {
          className: cx("chakra-popover__arrow", props.className),
          ...getArrowInnerProps(props),
          __css: {
            "--popper-arrow-shadow-color": resolveVar("colors", shadowColor),
            "--popper-arrow-bg": resolveVar("colors", arrowBg),
            "--popper-arrow-shadow": resolveVar("shadows", arrowShadow),
            ...styles3.arrow
          }
        }
      )
    }
  );
}
PopoverArrow.displayName = "PopoverArrow";

// node_modules/@chakra-ui/popover/dist/chunk-RLMGYZLY.mjs
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
"use client";
var PopoverBody = forwardRef3(
  function PopoverBody2(props, ref) {
    const { getBodyProps } = usePopoverContext();
    const styles3 = usePopoverStyles();
    return /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
      chakra.div,
      {
        ...getBodyProps(props, ref),
        className: cx("chakra-popover__body", props.className),
        __css: styles3.body
      }
    );
  }
);
PopoverBody.displayName = "PopoverBody";

// node_modules/@chakra-ui/popover/dist/chunk-JKY3EM6P.mjs
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
"use client";
var PopoverCloseButton = forwardRef3(
  function PopoverCloseButton2(props, ref) {
    const { onClose } = usePopoverContext();
    const styles3 = usePopoverStyles();
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
      CloseButton,
      {
        size: "sm",
        onClick: onClose,
        className: cx("chakra-popover__close-btn", props.className),
        __css: styles3.closeButton,
        ref,
        ...props
      }
    );
  }
);
PopoverCloseButton.displayName = "PopoverCloseButton";

// node_modules/@chakra-ui/popover/dist/chunk-F4GPNG57.mjs
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
"use client";
function mergeVariants(variants13) {
  if (!variants13)
    return;
  return {
    enter: {
      ...variants13.enter,
      visibility: "visible"
    },
    exit: {
      ...variants13.exit,
      transitionEnd: {
        visibility: "hidden"
      }
    }
  };
}
var scaleFade = {
  exit: {
    opacity: 0,
    scale: 0.95,
    transition: {
      duration: 0.1,
      ease: [0.4, 0, 1, 1]
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      duration: 0.15,
      ease: [0, 0, 0.2, 1]
    }
  }
};
var MotionSection = chakra(motion.section);
var PopoverTransition = forwardRef3(function PopoverTransition2(props, ref) {
  const { variants: variants13 = scaleFade, ...rest } = props;
  const { isOpen } = usePopoverContext();
  return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
    MotionSection,
    {
      ref,
      variants: mergeVariants(variants13),
      initial: false,
      animate: isOpen ? "enter" : "exit",
      ...rest
    }
  );
});
PopoverTransition.displayName = "PopoverTransition";

// node_modules/@chakra-ui/popover/dist/chunk-24I2HV4N.mjs
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
"use client";
var PopoverContent = forwardRef3(
  function PopoverContent2(props, ref) {
    const { rootProps, motionProps, ...contentProps } = props;
    const { getPopoverProps, getPopoverPositionerProps, onAnimationComplete } = usePopoverContext();
    const styles3 = usePopoverStyles();
    const contentStyles = {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      ...styles3.content
    };
    return /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(
      chakra.div,
      {
        ...getPopoverPositionerProps(rootProps),
        __css: styles3.popper,
        className: "chakra-popover__popper",
        children: /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(
          PopoverTransition,
          {
            ...motionProps,
            ...getPopoverProps(contentProps, ref),
            onAnimationComplete: callAll(
              onAnimationComplete,
              contentProps.onAnimationComplete
            ),
            className: cx("chakra-popover__content", props.className),
            __css: contentStyles
          }
        )
      }
    );
  }
);
PopoverContent.displayName = "PopoverContent";

// node_modules/@chakra-ui/popover/dist/index.mjs
"use client";

// app/data/data.js
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\data\\data.js"
  );
  import.meta.hot.lastModified = "1708448307968.0066";
}
var STATUS_ON_DECK = { id: 1, name: "On Deck", color: "blue.300" };
var STATUS_IN_PROGRESS = {
  id: 2,
  name: "In Progress",
  color: "yellow.400"
};
var STATUS_TESTING = { id: 3, name: "Testing", color: "pink.300" };
var STATUS_DEPLOYED = { id: 4, name: "Deployed", color: "green.300" };
var STATUSES2 = [
  STATUS_ON_DECK,
  STATUS_IN_PROGRESS,
  STATUS_TESTING,
  STATUS_DEPLOYED
];
var DATA = [
  {
    task: "Add a New Feature",
    status: STATUS_ON_DECK,
    due: /* @__PURE__ */ new Date("2023/10/15"),
    notes: "This is a note"
  },
  {
    task: "Write Integration Tests",
    status: STATUS_IN_PROGRESS,
    due: null,
    notes: "Use Jest"
  },
  {
    task: "Add Instagram Integration",
    status: STATUS_DEPLOYED,
    due: null,
    notes: ""
  },
  {
    task: "Cleanup Database",
    status: null,
    due: /* @__PURE__ */ new Date("2023/02/15"),
    notes: "Remove old data"
  },
  {
    task: "Refactor API Endpoints",
    status: STATUS_TESTING,
    due: null,
    notes: ""
  },
  {
    task: "Add Documentation to API",
    status: null,
    due: /* @__PURE__ */ new Date("2023/09/12"),
    notes: "Add JS Docs to all endpoints"
  },
  {
    task: "Update NPM Packages",
    status: STATUS_IN_PROGRESS,
    due: null,
    notes: "Upgrade React & Chakra UI"
  }
];
var data_default = DATA;

// app/components/EditableCell.jsx
var import_react86 = __toESM(require_react());
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
if (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {
  console.warn("remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.");
} else {
  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id2) => {
    window.$RefreshRuntime$.register(type, '"app\\\\components\\\\EditableCell.jsx"' + id2);
  };
  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;
}
var prevRefreshReg;
var prevRefreshSig;
var _s = $RefreshSig$();
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\components\\EditableCell.jsx"
  );
  import.meta.hot.lastModified = "1708448307847.0332";
}
var EditableCell = ({
  getValue,
  row,
  column: column2,
  table
}) => {
  _s();
  const initialValue = getValue();
  const [value, setValue] = (0, import_react86.useState)(initialValue);
  const onBlur = () => {
    table.options.meta?.updateData(row.index, column2.id, value);
  };
  (0, import_react86.useEffect)(() => {
    setValue(initialValue);
  }, [initialValue]);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Input, { value, onChange: (e) => setValue(e.target.value), onBlur, variant: "filled", size: "sm", w: "85%", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }, void 0, false, {
    fileName: "app/components/EditableCell.jsx",
    lineNumber: 43,
    columnNumber: 10
  }, this);
};
_s(EditableCell, "tWiMN+R1KrlPc+I/v9D+hnPBFtc=");
_c3 = EditableCell;
var EditableCell_default = EditableCell;
var _c3;
$RefreshReg$(_c3, "EditableCell");
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;

// app/components/StausCell.jsx
var import_jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime());
if (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {
  console.warn("remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.");
} else {
  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id2) => {
    window.$RefreshRuntime$.register(type, '"app\\\\components\\\\StausCell.jsx"' + id2);
  };
  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;
}
var prevRefreshReg;
var prevRefreshSig;
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\components\\StausCell.jsx"
  );
  import.meta.hot.lastModified = "1708448307858.0833";
}
var ColorIcon = ({
  color: color3,
  ...props
}) => /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(Box, { w: "12px", h: "12px", bg: color3, borderRadius: "3px", ...props }, void 0, false, {
  fileName: "app/components/StausCell.jsx",
  lineNumber: 26,
  columnNumber: 7
}, this);
_c4 = ColorIcon;
var StatusCell = ({
  getValue,
  row,
  column: column2,
  table
}) => {
  const {
    name,
    color: color3
  } = getValue() || {};
  const {
    updateData
  } = table.options.meta;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(Menu, { isLazy: true, offset: [0, 0], flip: false, autoSelect: false, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(MenuButton, { h: "100%", w: "100%", textAlign: "left", p: 1.5, bg: color3 || "transparent", color: "gray.900", children: name }, void 0, false, {
      fileName: "app/components/StausCell.jsx",
      lineNumber: 42,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(MenuList, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(MenuItem, { onClick: () => updateData(row.index, column2.id, null), children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(ColorIcon, { color: "red.400", mr: 3 }, void 0, false, {
          fileName: "app/components/StausCell.jsx",
          lineNumber: 47,
          columnNumber: 11
        }, this),
        "None"
      ] }, void 0, true, {
        fileName: "app/components/StausCell.jsx",
        lineNumber: 46,
        columnNumber: 9
      }, this),
      STATUSES2.map((status) => /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(MenuItem, { onClick: () => updateData(row.index, column2.id, status), children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(ColorIcon, { color: status.color, mr: 3 }, void 0, false, {
          fileName: "app/components/StausCell.jsx",
          lineNumber: 51,
          columnNumber: 13
        }, this),
        status.name
      ] }, status.id, true, {
        fileName: "app/components/StausCell.jsx",
        lineNumber: 50,
        columnNumber: 33
      }, this))
    ] }, void 0, true, {
      fileName: "app/components/StausCell.jsx",
      lineNumber: 45,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "app/components/StausCell.jsx",
    lineNumber: 41,
    columnNumber: 10
  }, this);
};
_c22 = StatusCell;
var StausCell_default = StatusCell;
var _c4;
var _c22;
$RefreshReg$(_c4, "ColorIcon");
$RefreshReg$(_c22, "StatusCell");
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;

// app/components/DateCell.jsx
var import_react90 = __toESM(require_react());
var import_react_datepicker = __toESM(require_react_datepicker_min());

// app/components/icons/CalendarIcon.jsx
var import_jsx_dev_runtime3 = __toESM(require_jsx_dev_runtime());
if (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {
  console.warn("remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.");
} else {
  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id2) => {
    window.$RefreshRuntime$.register(type, '"app\\\\components\\\\icons\\\\CalendarIcon.jsx"' + id2);
  };
  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;
}
var prevRefreshReg;
var prevRefreshSig;
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\components\\icons\\CalendarIcon.jsx"
  );
  import.meta.hot.lastModified = "1708448307873.7605";
}
var CalendarIcon = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0v-7.5A2.25 2.25 0 015.25 9h13.5A2.25 2.25 0 0121 11.25v7.5" }, void 0, false, {
  fileName: "app/components/icons/CalendarIcon.jsx",
  lineNumber: 22,
  columnNumber: 5
}, this) }, void 0, false, {
  fileName: "app/components/icons/CalendarIcon.jsx",
  lineNumber: 21,
  columnNumber: 31
}, this);
_c5 = CalendarIcon;
var CalendarIcon_default = CalendarIcon;
var _c5;
$RefreshReg$(_c5, "CalendarIcon");
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;

// app/components/DateCell.jsx
var import_jsx_dev_runtime4 = __toESM(require_jsx_dev_runtime());
if (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {
  console.warn("remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.");
} else {
  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id2) => {
    window.$RefreshRuntime$.register(type, '"app\\\\components\\\\DateCell.jsx"' + id2);
  };
  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;
}
var prevRefreshReg;
var prevRefreshSig;
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\components\\DateCell.jsx"
  );
}
var DateCustomInput = (0, import_react90.forwardRef)(_c6 = ({
  value,
  onClick,
  clearDate
}, ref) => /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(Center, { ref, onClick, cursor: "pointer", children: value ? /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(import_jsx_dev_runtime4.Fragment, { children: [
  value,
  /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(Box, { pos: "absolute", right: 3, fontSize: "md", color: "red.300", onClick: (e) => {
    e.stopPropagation();
    clearDate();
  }, children: "\xD7" }, void 0, false, {
    fileName: "app/components/DateCell.jsx",
    lineNumber: 33,
    columnNumber: 9
  }, this)
] }, void 0, true, {
  fileName: "app/components/DateCell.jsx",
  lineNumber: 30,
  columnNumber: 14
}, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(Icon, { as: CalendarIcon_default, fontSize: "xl" }, void 0, false, {
  fileName: "app/components/DateCell.jsx",
  lineNumber: 40,
  columnNumber: 13
}, this) }, void 0, false, {
  fileName: "app/components/DateCell.jsx",
  lineNumber: 29,
  columnNumber: 12
}, this));
_c23 = DateCustomInput;
var DateCell = ({
  getValue,
  row,
  column: column2,
  table
}) => {
  const date = getValue();
  const {
    updateData
  } = table.options.meta;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(import_react_datepicker.default, { wrapperClassName: "date-wrapper", dateFormat: "MMM d", selected: date, onChange: (date2) => updateData(row.index, column2.id, date2), customInput: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(DateCustomInput, { clearDate: () => updateData(row.index, column2.id, null) }, void 0, false, {
    fileName: "app/components/DateCell.jsx",
    lineNumber: 54,
    columnNumber: 160
  }, this) }, void 0, false, {
    fileName: "app/components/DateCell.jsx",
    lineNumber: 54,
    columnNumber: 10
  }, this);
};
_c32 = DateCell;
var DateCell_default = DateCell;
var _c6;
var _c23;
var _c32;
$RefreshReg$(_c6, "DateCustomInput$forwardRef");
$RefreshReg$(_c23, "DateCustomInput");
$RefreshReg$(_c32, "DateCell");
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;

// app/components/icons/SearchIcon.jsx
var import_jsx_dev_runtime5 = __toESM(require_jsx_dev_runtime());
if (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {
  console.warn("remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.");
} else {
  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id2) => {
    window.$RefreshRuntime$.register(type, '"app\\\\components\\\\icons\\\\SearchIcon.jsx"' + id2);
  };
  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;
}
var prevRefreshReg;
var prevRefreshSig;
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\components\\icons\\SearchIcon.jsx"
  );
  import.meta.hot.lastModified = "1708448307873.7605";
}
var SearchIcon = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" }, void 0, false, {
  fileName: "app/components/icons/SearchIcon.jsx",
  lineNumber: 22,
  columnNumber: 5
}, this) }, void 0, false, {
  fileName: "app/components/icons/SearchIcon.jsx",
  lineNumber: 21,
  columnNumber: 29
}, this);
_c7 = SearchIcon;
var SearchIcon_default = SearchIcon;
var _c7;
$RefreshReg$(_c7, "SearchIcon");
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;

// app/components/icons/FilterIcon.jsx
var import_jsx_dev_runtime6 = __toESM(require_jsx_dev_runtime());
if (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {
  console.warn("remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.");
} else {
  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id2) => {
    window.$RefreshRuntime$.register(type, '"app\\\\components\\\\icons\\\\FilterIcon.jsx"' + id2);
  };
  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;
}
var prevRefreshReg;
var prevRefreshSig;
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\components\\icons\\FilterIcon.jsx"
  );
  import.meta.hot.lastModified = "1708448307873.7605";
}
var FilterIcon = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M12 3c2.755 0 5.455.232 8.083.678.533.09.917.556.917 1.096v1.044a2.25 2.25 0 01-.659 1.591l-5.432 5.432a2.25 2.25 0 00-.659 1.591v2.927a2.25 2.25 0 01-1.244 2.013L9.75 21v-6.568a2.25 2.25 0 00-.659-1.591L3.659 7.409A2.25 2.25 0 013 5.818V4.774c0-.54.384-1.006.917-1.096A48.32 48.32 0 0112 3z" }, void 0, false, {
  fileName: "app/components/icons/FilterIcon.jsx",
  lineNumber: 22,
  columnNumber: 5
}, this) }, void 0, false, {
  fileName: "app/components/icons/FilterIcon.jsx",
  lineNumber: 21,
  columnNumber: 29
}, this);
_c8 = FilterIcon;
var FilterIcon_default = FilterIcon;
var _c8;
$RefreshReg$(_c8, "FilterIcon");
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;

// app/components/FilterPopover.jsx
var import_jsx_dev_runtime7 = __toESM(require_jsx_dev_runtime());
if (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {
  console.warn("remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.");
} else {
  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id2) => {
    window.$RefreshRuntime$.register(type, '"app\\\\components\\\\FilterPopover.jsx"' + id2);
  };
  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;
}
var prevRefreshReg;
var prevRefreshSig;
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\components\\FilterPopover.jsx"
  );
  import.meta.hot.lastModified = "1708448307847.0332";
}
var StatusItem = ({
  status,
  setColumnFilters,
  isActive
}) => /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(Flex, { align: "center", cursor: "pointer", borderRadius: 5, fontWeight: "bold", p: 1.5, bg: isActive ? "gray.800" : "transparent", _hover: {
  bg: "gray.800"
}, onClick: () => setColumnFilters((prev2) => {
  const statuses = prev2.find((filter3) => filter3.id === "status")?.value;
  if (!statuses) {
    return prev2.concat({
      id: "status",
      value: [status.id]
    });
  }
  return prev2.map((f) => f.id === "status" ? {
    ...f,
    value: isActive ? statuses.filter((s) => s !== status.id) : statuses.concat(status.id)
  } : f);
}), children: [
  /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(ColorIcon, { color: status.color, mr: 3 }, void 0, false, {
    fileName: "app/components/FilterPopover.jsx",
    lineNumber: 44,
    columnNumber: 5
  }, this),
  status.name
] }, void 0, true, {
  fileName: "app/components/FilterPopover.jsx",
  lineNumber: 29,
  columnNumber: 7
}, this);
_c9 = StatusItem;
var FilterPopover = ({
  columnFilters,
  setColumnFilters
}) => {
  const filterStatuses = columnFilters.find((f) => f.id === "status")?.value || [];
  return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(Popover, { isLazy: true, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(PopoverTrigger, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(Button, { size: "sm", color: filterStatuses.length > 0 ? "blue.300" : "", leftIcon: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(Icon, { as: FilterIcon_default, fontSize: 18 }, void 0, false, {
      fileName: "app/components/FilterPopover.jsx",
      lineNumber: 55,
      columnNumber: 89
    }, this), children: "Filter" }, void 0, false, {
      fileName: "app/components/FilterPopover.jsx",
      lineNumber: 55,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "app/components/FilterPopover.jsx",
      lineNumber: 54,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(PopoverContent, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(PopoverArrow, {}, void 0, false, {
        fileName: "app/components/FilterPopover.jsx",
        lineNumber: 60,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(PopoverCloseButton, {}, void 0, false, {
        fileName: "app/components/FilterPopover.jsx",
        lineNumber: 61,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(PopoverBody, { children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(Text, { fontSize: "md", fontWeight: "bold", mb: 4, children: "Filter By:" }, void 0, false, {
          fileName: "app/components/FilterPopover.jsx",
          lineNumber: 63,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(Text, { fontWeight: "bold", color: "gray.400", mb: 1, children: "Status" }, void 0, false, {
          fileName: "app/components/FilterPopover.jsx",
          lineNumber: 66,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(VStack, { align: "flex-start", spacing: 1, children: STATUSES2.map((status) => /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(StatusItem, { status, isActive: filterStatuses.includes(status.id), setColumnFilters }, status.id, false, {
          fileName: "app/components/FilterPopover.jsx",
          lineNumber: 70,
          columnNumber: 37
        }, this)) }, void 0, false, {
          fileName: "app/components/FilterPopover.jsx",
          lineNumber: 69,
          columnNumber: 11
        }, this)
      ] }, void 0, true, {
        fileName: "app/components/FilterPopover.jsx",
        lineNumber: 62,
        columnNumber: 9
      }, this)
    ] }, void 0, true, {
      fileName: "app/components/FilterPopover.jsx",
      lineNumber: 59,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "app/components/FilterPopover.jsx",
    lineNumber: 53,
    columnNumber: 10
  }, this);
};
_c24 = FilterPopover;
var FilterPopover_default = FilterPopover;
var _c9;
var _c24;
$RefreshReg$(_c9, "StatusItem");
$RefreshReg$(_c24, "FilterPopover");
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;

// app/components/Filters.jsx
var import_jsx_dev_runtime8 = __toESM(require_jsx_dev_runtime());
if (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {
  console.warn("remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.");
} else {
  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id2) => {
    window.$RefreshRuntime$.register(type, '"app\\\\components\\\\Filters.jsx"' + id2);
  };
  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;
}
var prevRefreshReg;
var prevRefreshSig;
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\components\\Filters.jsx"
  );
  import.meta.hot.lastModified = "1708448307847.0332";
}
var Filters = ({
  columnFilters,
  setColumnFilters
}) => {
  const taskName = columnFilters.find((f) => f.id === "task")?.value || "";
  const onFilterChange = (id2, value) => setColumnFilters((prev2) => prev2.filter((f) => f.id !== id2).concat({
    id: id2,
    value
  }));
  return /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(HStack, { mb: 6, spacing: 3, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(InputGroup, { size: "sm", maxW: "12rem", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(InputLeftElement, { pointerEvents: "none", children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(Icon, { as: SearchIcon_default }, void 0, false, {
        fileName: "app/components/Filters.jsx",
        lineNumber: 36,
        columnNumber: 11
      }, this) }, void 0, false, {
        fileName: "app/components/Filters.jsx",
        lineNumber: 35,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(Input, { type: "text", variant: "filled", placeholder: "Task name", borderRadius: 5, value: taskName, onChange: (e) => onFilterChange("task", e.target.value) }, void 0, false, {
        fileName: "app/components/Filters.jsx",
        lineNumber: 38,
        columnNumber: 9
      }, this)
    ] }, void 0, true, {
      fileName: "app/components/Filters.jsx",
      lineNumber: 34,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(FilterPopover_default, { columnFilters, setColumnFilters }, void 0, false, {
      fileName: "app/components/Filters.jsx",
      lineNumber: 40,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "app/components/Filters.jsx",
    lineNumber: 33,
    columnNumber: 10
  }, this);
};
_c10 = Filters;
var Filters_default = Filters;
var _c10;
$RefreshReg$(_c10, "Filters");
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;

// app/components/icons/SortIcon.jsx
var import_jsx_dev_runtime9 = __toESM(require_jsx_dev_runtime());
if (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {
  console.warn("remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.");
} else {
  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id2) => {
    window.$RefreshRuntime$.register(type, '"app\\\\components\\\\icons\\\\SortIcon.jsx"' + id2);
  };
  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;
}
var prevRefreshReg;
var prevRefreshSig;
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\components\\icons\\SortIcon.jsx"
  );
  import.meta.hot.lastModified = "1708448307873.7605";
}
var SortIcon = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M3 7.5L7.5 3m0 0L12 7.5M7.5 3v13.5m13.5 0L16.5 21m0 0L12 16.5m4.5 4.5V7.5" }, void 0, false, {
  fileName: "app/components/icons/SortIcon.jsx",
  lineNumber: 22,
  columnNumber: 5
}, this) }, void 0, false, {
  fileName: "app/components/icons/SortIcon.jsx",
  lineNumber: 21,
  columnNumber: 27
}, this);
_c11 = SortIcon;
var SortIcon_default = SortIcon;
var _c11;
$RefreshReg$(_c11, "SortIcon");
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;

// app/components/TaskTable.jsx
var import_jsx_dev_runtime10 = __toESM(require_jsx_dev_runtime());
if (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {
  console.warn("remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.");
} else {
  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id2) => {
    window.$RefreshRuntime$.register(type, '"app\\\\components\\\\TaskTable.jsx"' + id2);
  };
  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;
}
var prevRefreshReg;
var prevRefreshSig;
var _s2 = $RefreshSig$();
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\components\\TaskTable.jsx"
  );
  import.meta.hot.lastModified = "1708448307858.0833";
}
var columns = [{
  accessorKey: "task",
  header: "Task",
  size: 225,
  cell: EditableCell_default,
  enableColumnFilter: true,
  filterFn: "includesString"
}, {
  accessorKey: "status",
  header: "Status",
  cell: StausCell_default,
  enableSorting: false,
  enableColumnFilter: true,
  filterFn: (row, columnId, filterStatuses) => {
    if (filterStatuses.length === 0)
      return true;
    const status = row.getValue(columnId);
    return filterStatuses.includes(status?.id);
  }
}, {
  accessorKey: "due",
  header: "Due",
  cell: DateCell_default
}, {
  accessorKey: "notes",
  header: "Notes",
  size: 225,
  cell: EditableCell_default
}];
var TaskTable = () => {
  _s2();
  const [data, setData] = (0, import_react94.useState)(data_default);
  const [columnFilters, setColumnFilters] = (0, import_react94.useState)([]);
  const table = useReactTable({
    data,
    columns,
    state: {
      columnFilters
    },
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    columnResizeMode: "onChange",
    meta: {
      updateData: (rowIndex, columnId, value) => setData((prev2) => prev2.map((row, index3) => index3 === rowIndex ? {
        ...prev2[rowIndex],
        [columnId]: value
      } : row))
    }
  });
  return /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Box, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Filters_default, { columnFilters, setColumnFilters }, void 0, false, {
      fileName: "app/components/TaskTable.jsx",
      lineNumber: 82,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Box, { className: "table", w: table.getTotalSize(), children: [
      table.getHeaderGroups().map((headerGroup) => /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Box, { className: "tr", children: headerGroup.headers.map((header) => /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Box, { className: "th", w: header.getSize(), children: [
        header.column.columnDef.header,
        header.column.getCanSort() && /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Icon, { as: SortIcon_default, mx: 3, fontSize: 14, onClick: header.column.getToggleSortingHandler() }, void 0, false, {
          fileName: "app/components/TaskTable.jsx",
          lineNumber: 87,
          columnNumber: 48
        }, this),
        {
          asc: " \u{1F53C}",
          desc: " \u{1F53D}"
        }[header.column.getIsSorted()],
        /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Box, { onMouseDown: header.getResizeHandler(), onTouchStart: header.getResizeHandler(), className: `resizer ${header.column.getIsResizing() ? "isResizing" : ""}` }, void 0, false, {
          fileName: "app/components/TaskTable.jsx",
          lineNumber: 92,
          columnNumber: 17
        }, this)
      ] }, header.id, true, {
        fileName: "app/components/TaskTable.jsx",
        lineNumber: 85,
        columnNumber: 48
      }, this)) }, headerGroup.id, false, {
        fileName: "app/components/TaskTable.jsx",
        lineNumber: 84,
        columnNumber: 53
      }, this)),
      table.getRowModel().rows.map((row) => /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Box, { className: "tr", children: row.getVisibleCells().map((cell) => /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Box, { className: "td", w: cell.column.getSize(), children: flexRender(cell.column.columnDef.cell, cell.getContext()) }, cell.id, false, {
        fileName: "app/components/TaskTable.jsx",
        lineNumber: 96,
        columnNumber: 48
      }, this)) }, row.id, false, {
        fileName: "app/components/TaskTable.jsx",
        lineNumber: 95,
        columnNumber: 46
      }, this))
    ] }, void 0, true, {
      fileName: "app/components/TaskTable.jsx",
      lineNumber: 83,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("br", {}, void 0, false, {
      fileName: "app/components/TaskTable.jsx",
      lineNumber: 101,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Text, { mb: 2, children: [
      "Page ",
      table.getState().pagination.pageIndex + 1,
      " of",
      " ",
      table.getPageCount()
    ] }, void 0, true, {
      fileName: "app/components/TaskTable.jsx",
      lineNumber: 102,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(ButtonGroup, { size: "sm", isAttached: true, variant: "outline", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Button, { onClick: () => table.previousPage(), isDisabled: !table.getCanPreviousPage(), children: "<" }, void 0, false, {
        fileName: "app/components/TaskTable.jsx",
        lineNumber: 107,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Button, { onClick: () => table.nextPage(), isDisabled: !table.getCanNextPage(), children: ">" }, void 0, false, {
        fileName: "app/components/TaskTable.jsx",
        lineNumber: 110,
        columnNumber: 9
      }, this)
    ] }, void 0, true, {
      fileName: "app/components/TaskTable.jsx",
      lineNumber: 106,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "app/components/TaskTable.jsx",
    lineNumber: 81,
    columnNumber: 10
  }, this);
};
_s2(TaskTable, "aomV9N5hVybHj7IE0J/zPx2EI18=", false, function() {
  return [useReactTable];
});
_c12 = TaskTable;
var TaskTable_default = TaskTable;
var _c12;
$RefreshReg$(_c12, "TaskTable");
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;

// app/styles/styles.js
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\styles\\styles.js"
  );
  import.meta.hot.lastModified = "1708448308234.2375";
}
var styles2 = {
  global: {
    "html, body": {
      backgroundColor: "gray.900",
      color: "black"
    },
    svg: {
      cursor: "pointer"
    },
    ".table": {
      border: "1px solid #424242"
    },
    ".tr": {
      display: "flex",
      width: "fit-content"
    },
    ".th, .td": { boxShadow: "inset 0 0 0 1px #424242" },
    ".th": {
      position: "relative",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      color: "gray.400",
      padding: "0.5rem",
      fontWeight: "bold",
      fontSize: "xs",
      textTransform: "uppercase",
      textAlign: "center"
    },
    ".td > input": {
      m: "1",
      padding: "0.2rem",
      bg: "transparent",
      maxW: "100%"
    },
    ".date-wrapper": {
      display: "flex",
      alignItems: "center",
      w: "100%",
      h: "100%"
    },
    ".resizer": {
      position: "absolute",
      opacity: 0,
      top: 0,
      right: 0,
      h: "100%",
      w: "5px",
      bg: "#27bbff",
      cursor: "col-resize",
      userSelect: "none",
      touchAction: "none",
      borderRadius: "6px"
    },
    ".resizer.isResizing": {
      bg: "#2eff31",
      opacity: 1
    },
    "*:hover > .resizer": {
      opacity: 1
    }
  }
};
var styles_default = styles2;

// app/styles/theme.js
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\styles\\theme.js"
  );
  import.meta.hot.lastModified = "1708448308234.2375";
}
var theme2 = extendTheme({
  styles: styles_default
});
var theme_default = theme2;

// app/routes/snop.table.jsx
var import_jsx_dev_runtime11 = __toESM(require_jsx_dev_runtime());
if (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {
  console.warn("remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.");
} else {
  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id2) => {
    window.$RefreshRuntime$.register(type, '"app\\\\routes\\\\snop.table.jsx"' + id2);
  };
  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;
}
var prevRefreshReg;
var prevRefreshSig;
if (import.meta) {
  import.meta.hot = createHotContext(
    //@ts-expect-error
    "app\\routes\\snop.table.jsx"
  );
  import.meta.hot.lastModified = "1708448308203.9727";
}
function App() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(import_jsx_dev_runtime11.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(ChakraProvider2, { theme: theme_default, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("h1", { className: "mb-10 ", children: "TanStack Table" }, void 0, false, {
      fileName: "app/routes/snop.table.jsx",
      lineNumber: 27,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(TaskTable_default, {}, void 0, false, {
      fileName: "app/routes/snop.table.jsx",
      lineNumber: 29,
      columnNumber: 9
    }, this)
  ] }, void 0, true, {
    fileName: "app/routes/snop.table.jsx",
    lineNumber: 26,
    columnNumber: 7
  }, this) }, void 0, false, {
    fileName: "app/routes/snop.table.jsx",
    lineNumber: 25,
    columnNumber: 10
  }, this);
}
_c13 = App;
var _c13;
$RefreshReg$(_c13, "App");
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;
export {
  App as default
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=/build/routes/snop.table-W75YGGNR.js.map
